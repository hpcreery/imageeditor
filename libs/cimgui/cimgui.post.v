@[translated]
module cimgui

// module C:\Users\phcre\Documents\v\imageeditor\thirdparty\cimgui

// This file is automatically generated by generator.lua from https://github.com/cimgui/cimgui
// based on imgui.h file version "1.91.1" 19110 from Dear ImGui https://github.com/ocornut/imgui
// with imgui_internal.h api
// docking branch
pub type ImU64 = i64

// typedef unsigned long long ImU64;
pub struct C.ImVector_const_charPtr {
pub:
	size     int
	capacity int
	data     &&u8
}

pub type ImVector_const_charPtr = C.ImVector_const_charPtr

pub type ImGuiID = u32
pub type ImS8 = i8
pub type ImU8 = u8
pub type ImS16 = i16
pub type ImU16 = u16
pub type ImS32 = int
pub type ImU32 = u32
pub type ImS64 = i64

// pub type ImGuiCol = int
// pub type ImGuiCond = int
// pub type ImGuiDatatype = int
// pub type ImGuiMouseButton = int
// pub type ImGuiMouseCursor = int
// pub type ImGuiStyleVar = int
// pub type ImGuiTableBgTarget = int
// pub type ImDrawFlags = int
// pub type ImDrawListFlags = int
// pub type ImFontAtlasFlags = int
// pub type ImGuiBackendFlags = int
// pub type ImGuiButtonFlags = int
// pub type ImGuiChildFlags = int
// pub type ImGuiColorEditFlags = int
// pub type ImGuiConfigFlags = int
// pub type ImGuiComboFlags = int
// pub type ImGuiDockNodeFlags = int
// pub type ImGuiDragDropFlags = int
// pub type ImGuiFocusedFlags = int
// pub type ImGuiHoveredFlags = int
// pub type ImGuiInputFlags = int
// pub type ImGuiInputTextFlags = int
// pub type ImGuiItemFlags = int
pub type ImGuiKeyChord = int

// pub type ImGuiPopupFlags = int
// pub type ImGuiMultiSelectFlags = int
// pub type ImGuiSelectableFlags = int
// pub type ImGuiSliderFlags = int
// pub type ImGuiTabBarFlags = int
// pub type ImGuiTabItemFlags = int
// pub type ImGuiTableFlags = int
// pub type ImGuiTableColumnFlags = int
// pub type ImGuiTableRowFlags = int
// pub type ImGuiTreeNodeFlags = int
// pub type ImGuiViewportFlags = int
// pub type ImGuiWindowFlags = int
pub type ImTextureID = voidptr
pub type ImDrawIdx = u16
pub type ImWchar32 = u32
pub type ImWchar16 = u16
pub type ImWchar = u16
pub type ImGuiSelectionUserData = i64
pub type ImGuiMemAllocFunc = fn (usize, voidptr) voidptr

pub type ImGuiMemFreeFunc = fn (voidptr, voidptr)

// typedef int (*ImGuiInputTextCallback)(ImGuiInputTextCallbackData *data);
// typedef void (*ImGuiSizeCallback)(ImGuiSizeCallbackData *data);

pub type ImGuiInputTextCallback = fn (voidptr) int

pub type ImGuiSizeCallback = fn (ImGuiSizeCallbackData) voidptr

@[typedef]
pub struct C.ImVec2 {
pub:
	x f32
	y f32
}

pub type ImVec2 = C.ImVec2

pub struct C.ImVec4 {
pub:
	x f32
	y f32
	z f32
	w f32
}

pub type ImVec4 = C.ImVec4

pub enum ImGuiWindowFlags {
	im_gui_window_flags_none                        = 0
	im_gui_window_flags_no_title_bar                = 1 << 0
	im_gui_window_flags_no_resize                   = 1 << 1
	im_gui_window_flags_no_move                     = 1 << 2
	im_gui_window_flags_no_scrollbar                = 1 << 3
	im_gui_window_flags_no_scroll_with_mouse        = 1 << 4
	im_gui_window_flags_no_collapse                 = 1 << 5
	im_gui_window_flags_always_auto_resize          = 1 << 6
	im_gui_window_flags_no_background               = 1 << 7
	im_gui_window_flags_no_saved_settings           = 1 << 8
	im_gui_window_flags_no_mouse_inputs             = 1 << 9
	im_gui_window_flags_menu_bar                    = 1 << 10
	im_gui_window_flags_horizontal_scrollbar        = 1 << 11
	im_gui_window_flags_no_focus_on_appearing       = 1 << 12
	im_gui_window_flags_no_bring_to_front_on_focus  = 1 << 13
	im_gui_window_flags_always_vertical_scrollbar   = 1 << 14
	im_gui_window_flags_always_horizontal_scrollbar = 1 << 15
	im_gui_window_flags_no_nav_inputs               = 1 << 16
	im_gui_window_flags_no_nav_focus                = 1 << 17
	im_gui_window_flags_unsaved_document            = 1 << 18
	im_gui_window_flags_no_docking                  = 1 << 19
	im_gui_window_flags_no_nav                      = 1 << 16 | 1 << 17
	im_gui_window_flags_no_decoration               = 1 << 0 | 1 << 1 | 1 << 3 | 1 << 5
	im_gui_window_flags_no_inputs                   = 1 << 9 | 1 << 16 | 1 << 17
	im_gui_window_flags_child_window                = 1 << 24
	im_gui_window_flags_tooltip                     = 1 << 25
	im_gui_window_flags_popup                       = 1 << 26
	im_gui_window_flags_modal                       = 1 << 27
	im_gui_window_flags_child_menu                  = 1 << 28
	im_gui_window_flags_dock_node_host              = 1 << 29
}

pub enum ImGuiChildFlags {
	im_gui_child_flags_none                      = 0
	im_gui_child_flags_borders                   = 1 << 0
	im_gui_child_flags_always_use_window_padding = 1 << 1
	im_gui_child_flags_resize_x                  = 1 << 2
	im_gui_child_flags_resize_y                  = 1 << 3
	im_gui_child_flags_auto_resize_x             = 1 << 4
	im_gui_child_flags_auto_resize_y             = 1 << 5
	im_gui_child_flags_always_auto_resize        = 1 << 6
	im_gui_child_flags_frame_style               = 1 << 7
	im_gui_child_flags_nav_flattened             = 1 << 8
}

pub enum ImGuiItemFlags {
	im_gui_item_flags_none                 = 0
	im_gui_item_flags_no_tab_stop          = 1 << 0
	im_gui_item_flags_no_nav               = 1 << 1
	im_gui_item_flags_no_nav_default_focus = 1 << 2
	im_gui_item_flags_button_repeat        = 1 << 3
	im_gui_item_flags_auto_close_popups    = 1 << 4
}

pub enum ImGuiInputTextFlags {
	im_gui_input_text_flags_none                    = 0
	im_gui_input_text_flags_chars_decimal           = 1 << 0
	im_gui_input_text_flags_chars_hexadecimal       = 1 << 1
	im_gui_input_text_flags_chars_scientific        = 1 << 2
	im_gui_input_text_flags_chars_uppercase         = 1 << 3
	im_gui_input_text_flags_chars_no_blank          = 1 << 4
	im_gui_input_text_flags_allow_tab_input         = 1 << 5
	im_gui_input_text_flags_enter_returns_true      = 1 << 6
	im_gui_input_text_flags_escape_clears_all       = 1 << 7
	im_gui_input_text_flags_ctrl_enter_for_new_line = 1 << 8
	im_gui_input_text_flags_read_only               = 1 << 9
	im_gui_input_text_flags_password                = 1 << 10
	im_gui_input_text_flags_always_overwrite        = 1 << 11
	im_gui_input_text_flags_auto_select_all         = 1 << 12
	im_gui_input_text_flags_parse_empty_ref_val     = 1 << 13
	im_gui_input_text_flags_display_empty_ref_val   = 1 << 14
	im_gui_input_text_flags_no_horizontal_scroll    = 1 << 15
	im_gui_input_text_flags_no_undo_redo            = 1 << 16
	im_gui_input_text_flags_callback_completion     = 1 << 17
	im_gui_input_text_flags_callback_history        = 1 << 18
	im_gui_input_text_flags_callback_always         = 1 << 19
	im_gui_input_text_flags_callback_char_filter    = 1 << 20
	im_gui_input_text_flags_callback_resize         = 1 << 21
	im_gui_input_text_flags_callback_edit           = 1 << 22
}

pub enum ImGuiTreeNodeFlags {
	im_gui_tree_node_flags_none                     = 0
	im_gui_tree_node_flags_selected                 = 1 << 0
	im_gui_tree_node_flags_framed                   = 1 << 1
	im_gui_tree_node_flags_allow_overlap            = 1 << 2
	im_gui_tree_node_flags_no_tree_push_on_open     = 1 << 3
	im_gui_tree_node_flags_no_auto_open_on_log      = 1 << 4
	im_gui_tree_node_flags_default_open             = 1 << 5
	im_gui_tree_node_flags_open_on_double_click     = 1 << 6
	im_gui_tree_node_flags_open_on_arrow            = 1 << 7
	im_gui_tree_node_flags_leaf                     = 1 << 8
	im_gui_tree_node_flags_bullet                   = 1 << 9
	im_gui_tree_node_flags_frame_padding            = 1 << 10
	im_gui_tree_node_flags_span_avail_width         = 1 << 11
	im_gui_tree_node_flags_span_full_width          = 1 << 12
	im_gui_tree_node_flags_span_text_width          = 1 << 13
	im_gui_tree_node_flags_span_all_columns         = 1 << 14
	im_gui_tree_node_flags_nav_left_jumps_back_here = 1 << 15
	im_gui_tree_node_flags_collapsing_header        = 1 << 1 | 1 << 3 | 1 << 4
}

pub enum ImGuiPopupFlags {
	im_gui_popup_flags_none                        = 0
	im_gui_popup_flags_mouse_button_left           = 0
	im_gui_popup_flags_mouse_button_right          = 1
	im_gui_popup_flags_mouse_button_middle         = 2
	im_gui_popup_flags_mouse_button_mask_          = 31
	im_gui_popup_flags_mouse_button_default_       = 1
	im_gui_popup_flags_no_reopen                   = 1 << 5
	im_gui_popup_flags_no_open_over_existing_popup = 1 << 7
	im_gui_popup_flags_no_open_over_items          = 1 << 8
	im_gui_popup_flags_any_popup_id                = 1 << 10
	im_gui_popup_flags_any_popup_level             = 1 << 11
	im_gui_popup_flags_any_popup                   = 1 << 10 | 1 << 11
}

pub enum ImGuiSelectableFlags {
	im_gui_selectable_flags_none                 = 0
	im_gui_selectable_flags_no_auto_close_popups = 1 << 0
	im_gui_selectable_flags_span_all_columns     = 1 << 1
	im_gui_selectable_flags_allow_double_click   = 1 << 2
	im_gui_selectable_flags_disabled             = 1 << 3
	im_gui_selectable_flags_allow_overlap        = 1 << 4
	im_gui_selectable_flags_highlight            = 1 << 5
}

pub enum ImGuiComboFlags {
	im_gui_combo_flags_none              = 0
	im_gui_combo_flags_popup_align_left  = 1 << 0
	im_gui_combo_flags_height_small      = 1 << 1
	im_gui_combo_flags_height_regular    = 1 << 2
	im_gui_combo_flags_height_large      = 1 << 3
	im_gui_combo_flags_height_largest    = 1 << 4
	im_gui_combo_flags_no_arrow_button   = 1 << 5
	im_gui_combo_flags_no_preview        = 1 << 6
	im_gui_combo_flags_width_fit_preview = 1 << 7
	im_gui_combo_flags_height_mask_      = 1 << 1 | 1 << 2 | 1 << 3 | 1 << 4
}

pub enum ImGuiTabBarFlags {
	im_gui_tab_bar_flags_none                              = 0
	im_gui_tab_bar_flags_reorderable                       = 1 << 0
	im_gui_tab_bar_flags_auto_select_new_tabs              = 1 << 1
	im_gui_tab_bar_flags_tab_list_popup_button             = 1 << 2
	im_gui_tab_bar_flags_no_close_with_middle_mouse_button = 1 << 3
	im_gui_tab_bar_flags_no_tab_list_scrolling_buttons     = 1 << 4
	im_gui_tab_bar_flags_no_tooltip                        = 1 << 5
	im_gui_tab_bar_flags_draw_selected_overline            = 1 << 6
	im_gui_tab_bar_flags_fitting_policy_resize_down        = 1 << 7
	im_gui_tab_bar_flags_fitting_policy_scroll             = 1 << 8
	im_gui_tab_bar_flags_fitting_policy_mask_              = 1 << 7 | 1 << 8
	im_gui_tab_bar_flags_fitting_policy_default_           = 1 << 7
}

pub enum ImGuiTabItemFlags {
	im_gui_tab_item_flags_none                              = 0
	im_gui_tab_item_flags_unsaved_document                  = 1 << 0
	im_gui_tab_item_flags_set_selected                      = 1 << 1
	im_gui_tab_item_flags_no_close_with_middle_mouse_button = 1 << 2
	im_gui_tab_item_flags_no_push_id                        = 1 << 3
	im_gui_tab_item_flags_no_tooltip                        = 1 << 4
	im_gui_tab_item_flags_no_reorder                        = 1 << 5
	im_gui_tab_item_flags_leading                           = 1 << 6
	im_gui_tab_item_flags_trailing                          = 1 << 7
	im_gui_tab_item_flags_no_assumed_closure                = 1 << 8
}

pub enum ImGuiFocusedFlags {
	im_gui_focused_flags_none                   = 0
	im_gui_focused_flags_child_windows          = 1 << 0
	im_gui_focused_flags_root_window            = 1 << 1
	im_gui_focused_flags_any_window             = 1 << 2
	im_gui_focused_flags_no_popup_hierarchy     = 1 << 3
	im_gui_focused_flags_dock_hierarchy         = 1 << 4
	im_gui_focused_flags_root_and_child_windows = 1 << 1 | 1 << 0
}

pub enum ImGuiHoveredFlags {
	im_gui_hovered_flags_none                              = 0
	im_gui_hovered_flags_child_windows                     = 1 << 0
	im_gui_hovered_flags_root_window                       = 1 << 1
	im_gui_hovered_flags_any_window                        = 1 << 2
	im_gui_hovered_flags_no_popup_hierarchy                = 1 << 3
	im_gui_hovered_flags_dock_hierarchy                    = 1 << 4
	im_gui_hovered_flags_allow_when_blocked_by_popup       = 1 << 5
	im_gui_hovered_flags_allow_when_blocked_by_active_item = 1 << 7
	im_gui_hovered_flags_allow_when_overlapped_by_item     = 1 << 8
	im_gui_hovered_flags_allow_when_overlapped_by_window   = 1 << 9
	im_gui_hovered_flags_allow_when_disabled               = 1 << 10
	im_gui_hovered_flags_no_nav_override                   = 1 << 11
	im_gui_hovered_flags_allow_when_overlapped             = 1 << 8 | 1 << 9
	im_gui_hovered_flags_rect_only                         = 1 << 5 | 1 << 7 | 1 << 8 | 1 << 9
	im_gui_hovered_flags_root_and_child_windows            = 1 << 1 | 1 << 0
	im_gui_hovered_flags_for_tooltip                       = 1 << 12
	im_gui_hovered_flags_stationary                        = 1 << 13
	im_gui_hovered_flags_delay_none                        = 1 << 14
	im_gui_hovered_flags_delay_short                       = 1 << 15
	im_gui_hovered_flags_delay_normal                      = 1 << 16
	im_gui_hovered_flags_no_shared_delay                   = 1 << 17
}

pub enum ImGuiDockNodeFlags {
	im_gui_dock_node_flags_none                         = 0
	im_gui_dock_node_flags_keep_alive_only              = 1 << 0
	im_gui_dock_node_flags_no_docking_over_central_node = 1 << 2
	im_gui_dock_node_flags_passthru_central_node        = 1 << 3
	im_gui_dock_node_flags_no_docking_split             = 1 << 4
	im_gui_dock_node_flags_no_resize                    = 1 << 5
	im_gui_dock_node_flags_auto_hide_tab_bar            = 1 << 6
	im_gui_dock_node_flags_no_undocking                 = 1 << 7
}

pub enum ImGuiDragDropFlags {
	im_gui_drag_drop_flags_none                          = 0
	im_gui_drag_drop_flags_source_no_preview_tooltip     = 1 << 0
	im_gui_drag_drop_flags_source_no_disable_hover       = 1 << 1
	im_gui_drag_drop_flags_source_no_hold_to_open_others = 1 << 2
	im_gui_drag_drop_flags_source_allow_null_id          = 1 << 3
	im_gui_drag_drop_flags_source_extern                 = 1 << 4
	im_gui_drag_drop_flags_payload_auto_expire           = 1 << 5
	im_gui_drag_drop_flags_payload_no_cross_context      = 1 << 6
	im_gui_drag_drop_flags_payload_no_cross_process      = 1 << 7
	im_gui_drag_drop_flags_accept_before_delivery        = 1 << 10
	im_gui_drag_drop_flags_accept_no_draw_default_rect   = 1 << 11
	im_gui_drag_drop_flags_accept_no_preview_tooltip     = 1 << 12
	im_gui_drag_drop_flags_accept_peek_only              = 1 << 10 | 1 << 11
}

pub enum ImGuiDataType {
	im_gui_data_type_s8
	im_gui_data_type_u8
	im_gui_data_type_s16
	im_gui_data_type_u16
	im_gui_data_type_s32
	im_gui_data_type_u32
	im_gui_data_type_s64
	im_gui_data_type_u64
	im_gui_data_type_float
	im_gui_data_type_double
	im_gui_data_type_bool
	im_gui_data_type_count
}

pub enum ImGuiDir {
	im_gui_dir_none  = -1
	im_gui_dir_left  = 0
	im_gui_dir_right = 1
	im_gui_dir_up    = 2
	im_gui_dir_down  = 3
	im_gui_dir_count = 4
}

pub enum ImGuiSortDirection {
	im_gui_sort_direction_none       = 0
	im_gui_sort_direction_ascending  = 1
	im_gui_sort_direction_descending = 2
}

pub enum ImGuiKey {
	im_gui_key_none                   = 0
	im_gui_key_tab                    = 512
	im_gui_key_left_arrow             = 513
	im_gui_key_right_arrow            = 514
	im_gui_key_up_arrow               = 515
	im_gui_key_down_arrow             = 516
	im_gui_key_page_up                = 517
	im_gui_key_page_down              = 518
	im_gui_key_home                   = 519
	im_gui_key_end                    = 520
	im_gui_key_insert                 = 521
	im_gui_key_delete                 = 522
	im_gui_key_backspace              = 523
	im_gui_key_space                  = 524
	im_gui_key_enter                  = 525
	im_gui_key_escape                 = 526
	im_gui_key_left_ctrl              = 527
	im_gui_key_left_shift             = 528
	im_gui_key_left_alt               = 529
	im_gui_key_left_super             = 530
	im_gui_key_right_ctrl             = 531
	im_gui_key_right_shift            = 532
	im_gui_key_right_alt              = 533
	im_gui_key_right_super            = 534
	im_gui_key_menu                   = 535
	im_gui_key_0                      = 536
	im_gui_key_1                      = 537
	im_gui_key_2                      = 538
	im_gui_key_3                      = 539
	im_gui_key_4                      = 540
	im_gui_key_5                      = 541
	im_gui_key_6                      = 542
	im_gui_key_7                      = 543
	im_gui_key_8                      = 544
	im_gui_key_9                      = 545
	im_gui_key_a                      = 546
	im_gui_key_b                      = 547
	im_gui_key_c                      = 548
	im_gui_key_d                      = 549
	im_gui_key_e                      = 550
	im_gui_key_f                      = 551
	im_gui_key_g                      = 552
	im_gui_key_h                      = 553
	im_gui_key_i                      = 554
	im_gui_key_j                      = 555
	im_gui_key_k                      = 556
	im_gui_key_l                      = 557
	im_gui_key_m                      = 558
	im_gui_key_n                      = 559
	im_gui_key_o                      = 560
	im_gui_key_p                      = 561
	im_gui_key_q                      = 562
	im_gui_key_r                      = 563
	im_gui_key_s                      = 564
	im_gui_key_t                      = 565
	im_gui_key_u                      = 566
	im_gui_key_v                      = 567
	im_gui_key_w                      = 568
	im_gui_key_x                      = 569
	im_gui_key_y                      = 570
	im_gui_key_z                      = 571
	im_gui_key_f1                     = 572
	im_gui_key_f2                     = 573
	im_gui_key_f3                     = 574
	im_gui_key_f4                     = 575
	im_gui_key_f5                     = 576
	im_gui_key_f6                     = 577
	im_gui_key_f7                     = 578
	im_gui_key_f8                     = 579
	im_gui_key_f9                     = 580
	im_gui_key_f10                    = 581
	im_gui_key_f11                    = 582
	im_gui_key_f12                    = 583
	im_gui_key_f13                    = 584
	im_gui_key_f14                    = 585
	im_gui_key_f15                    = 586
	im_gui_key_f16                    = 587
	im_gui_key_f17                    = 588
	im_gui_key_f18                    = 589
	im_gui_key_f19                    = 590
	im_gui_key_f20                    = 591
	im_gui_key_f21                    = 592
	im_gui_key_f22                    = 593
	im_gui_key_f23                    = 594
	im_gui_key_f24                    = 595
	im_gui_key_apostrophe             = 596
	im_gui_key_comma                  = 597
	im_gui_key_minus                  = 598
	im_gui_key_period                 = 599
	im_gui_key_slash                  = 600
	im_gui_key_semicolon              = 601
	im_gui_key_equal                  = 602
	im_gui_key_left_bracket           = 603
	im_gui_key_backslash              = 604
	im_gui_key_right_bracket          = 605
	im_gui_key_grave_accent           = 606
	im_gui_key_caps_lock              = 607
	im_gui_key_scroll_lock            = 608
	im_gui_key_num_lock               = 609
	im_gui_key_print_screen           = 610
	im_gui_key_pause                  = 611
	im_gui_key_keypad0                = 612
	im_gui_key_keypad1                = 613
	im_gui_key_keypad2                = 614
	im_gui_key_keypad3                = 615
	im_gui_key_keypad4                = 616
	im_gui_key_keypad5                = 617
	im_gui_key_keypad6                = 618
	im_gui_key_keypad7                = 619
	im_gui_key_keypad8                = 620
	im_gui_key_keypad9                = 621
	im_gui_key_keypad_decimal         = 622
	im_gui_key_keypad_divide          = 623
	im_gui_key_keypad_multiply        = 624
	im_gui_key_keypad_subtract        = 625
	im_gui_key_keypad_add             = 626
	im_gui_key_keypad_enter           = 627
	im_gui_key_keypad_equal           = 628
	im_gui_key_app_back               = 629
	im_gui_key_app_forward            = 630
	im_gui_key_gamepad_start          = 631
	im_gui_key_gamepad_back           = 632
	im_gui_key_gamepad_face_left      = 633
	im_gui_key_gamepad_face_right     = 634
	im_gui_key_gamepad_face_up        = 635
	im_gui_key_gamepad_face_down      = 636
	im_gui_key_gamepad_dpad_left      = 637
	im_gui_key_gamepad_dpad_right     = 638
	im_gui_key_gamepad_dpad_up        = 639
	im_gui_key_gamepad_dpad_down      = 640
	im_gui_key_gamepad_l1             = 641
	im_gui_key_gamepad_r1             = 642
	im_gui_key_gamepad_l2             = 643
	im_gui_key_gamepad_r2             = 644
	im_gui_key_gamepad_l3             = 645
	im_gui_key_gamepad_r3             = 646
	im_gui_key_gamepad_ls_tick_left   = 647
	im_gui_key_gamepad_ls_tick_right  = 648
	im_gui_key_gamepad_ls_tick_up     = 649
	im_gui_key_gamepad_ls_tick_down   = 650
	im_gui_key_gamepad_rs_tick_left   = 651
	im_gui_key_gamepad_rs_tick_right  = 652
	im_gui_key_gamepad_rs_tick_up     = 653
	im_gui_key_gamepad_rs_tick_down   = 654
	im_gui_key_mouse_left             = 655
	im_gui_key_mouse_right            = 656
	im_gui_key_mouse_middle           = 657
	im_gui_key_mouse_x1               = 658
	im_gui_key_mouse_x2               = 659
	im_gui_key_mouse_wheel_x          = 660
	im_gui_key_mouse_wheel_y          = 661
	im_gui_key_reserved_for_mod_ctrl  = 662
	im_gui_key_reserved_for_mod_shift = 663
	im_gui_key_reserved_for_mod_alt   = 664
	im_gui_key_reserved_for_mod_super = 665
	im_gui_key_count                  = 666
	im_gui_mod_none                   = 0
	im_gui_mod_ctrl                   = 1 << 12
	im_gui_mod_shift                  = 1 << 13
	im_gui_mod_alt                    = 1 << 14
	im_gui_mod_super                  = 1 << 15
	im_gui_mod_mask_                  = 61440
	im_gui_key_named_key_begin        = 512
	im_gui_key_named_key_end          = 666
	im_gui_key_named_key_count        = 666 - 512
	im_gui_key_keys_data_size         = 666 - 512
	im_gui_key_keys_data_offset       = 512
}

pub enum ImGuiInputFlags {
	im_gui_input_flags_none                    = 0
	im_gui_input_flags_repeat                  = 1 << 0
	im_gui_input_flags_route_active            = 1 << 10
	im_gui_input_flags_route_focused           = 1 << 11
	im_gui_input_flags_route_global            = 1 << 12
	im_gui_input_flags_route_always            = 1 << 13
	im_gui_input_flags_route_over_focused      = 1 << 14
	im_gui_input_flags_route_over_active       = 1 << 15
	im_gui_input_flags_route_unless_bg_focused = 1 << 16
	im_gui_input_flags_route_from_root_window  = 1 << 17
	im_gui_input_flags_tooltip                 = 1 << 18
}

pub enum ImGuiConfigFlags {
	im_gui_config_flags_none                       = 0
	im_gui_config_flags_nav_enable_keyboard        = 1 << 0
	im_gui_config_flags_nav_enable_gamepad         = 1 << 1
	im_gui_config_flags_nav_enable_set_mouse_pos   = 1 << 2
	im_gui_config_flags_nav_no_capture_keyboard    = 1 << 3
	im_gui_config_flags_no_mouse                   = 1 << 4
	im_gui_config_flags_no_mouse_cursor_change     = 1 << 5
	im_gui_config_flags_no_keyboard                = 1 << 6
	im_gui_config_flags_docking_enable             = 1 << 7
	im_gui_config_flags_viewports_enable           = 1 << 10
	im_gui_config_flags_dpi_enable_scale_viewports = 1 << 14
	im_gui_config_flags_dpi_enable_scale_fonts     = 1 << 15
	im_gui_config_flags_is_srgb                    = 1 << 20
	im_gui_config_flags_is_touch_screen            = 1 << 21
}

pub enum ImGuiBackendFlags {
	im_gui_backend_flags_none                       = 0
	im_gui_backend_flags_has_gamepad                = 1 << 0
	im_gui_backend_flags_has_mouse_cursors          = 1 << 1
	im_gui_backend_flags_has_set_mouse_pos          = 1 << 2
	im_gui_backend_flags_renderer_has_vtx_offset    = 1 << 3
	im_gui_backend_flags_platform_has_viewports     = 1 << 10
	im_gui_backend_flags_has_mouse_hovered_viewport = 1 << 11
	im_gui_backend_flags_renderer_has_viewports     = 1 << 12
}

pub enum ImGuiCol {
	im_gui_col_text
	im_gui_col_text_disabled
	im_gui_col_window_bg
	im_gui_col_child_bg
	im_gui_col_popup_bg
	im_gui_col_border
	im_gui_col_border_shadow
	im_gui_col_frame_bg
	im_gui_col_frame_bg_hovered
	im_gui_col_frame_bg_active
	im_gui_col_title_bg
	im_gui_col_title_bg_active
	im_gui_col_title_bg_collapsed
	im_gui_col_menu_bar_bg
	im_gui_col_scrollbar_bg
	im_gui_col_scrollbar_grab
	im_gui_col_scrollbar_grab_hovered
	im_gui_col_scrollbar_grab_active
	im_gui_col_check_mark
	im_gui_col_slider_grab
	im_gui_col_slider_grab_active
	im_gui_col_button
	im_gui_col_button_hovered
	im_gui_col_button_active
	im_gui_col_header
	im_gui_col_header_hovered
	im_gui_col_header_active
	im_gui_col_separator
	im_gui_col_separator_hovered
	im_gui_col_separator_active
	im_gui_col_resize_grip
	im_gui_col_resize_grip_hovered
	im_gui_col_resize_grip_active
	im_gui_col_tab_hovered
	im_gui_col_tab
	im_gui_col_tab_selected
	im_gui_col_tab_selected_overline
	im_gui_col_tab_dimmed
	im_gui_col_tab_dimmed_selected
	im_gui_col_tab_dimmed_selected_overline
	im_gui_col_docking_preview
	im_gui_col_docking_empty_bg
	im_gui_col_plot_lines
	im_gui_col_plot_lines_hovered
	im_gui_col_plot_histogram
	im_gui_col_plot_histogram_hovered
	im_gui_col_table_header_bg
	im_gui_col_table_border_strong
	im_gui_col_table_border_light
	im_gui_col_table_row_bg
	im_gui_col_table_row_bg_alt
	im_gui_col_text_link
	im_gui_col_text_selected_bg
	im_gui_col_drag_drop_target
	im_gui_col_nav_highlight
	im_gui_col_nav_windowing_highlight
	im_gui_col_nav_windowing_dim_bg
	im_gui_col_modal_window_dim_bg
	im_gui_col_count
}

pub enum ImGuiStyleVar {
	im_gui_style_var_alpha
	im_gui_style_var_disabled_alpha
	im_gui_style_var_window_padding
	im_gui_style_var_window_rounding
	im_gui_style_var_window_border_size
	im_gui_style_var_window_min_size
	im_gui_style_var_window_title_align
	im_gui_style_var_child_rounding
	im_gui_style_var_child_border_size
	im_gui_style_var_popup_rounding
	im_gui_style_var_popup_border_size
	im_gui_style_var_frame_padding
	im_gui_style_var_frame_rounding
	im_gui_style_var_frame_border_size
	im_gui_style_var_item_spacing
	im_gui_style_var_item_inner_spacing
	im_gui_style_var_indent_spacing
	im_gui_style_var_cell_padding
	im_gui_style_var_scrollbar_size
	im_gui_style_var_scrollbar_rounding
	im_gui_style_var_grab_min_size
	im_gui_style_var_grab_rounding
	im_gui_style_var_tab_rounding
	im_gui_style_var_tab_border_size
	im_gui_style_var_tab_bar_border_size
	im_gui_style_var_tab_bar_overline_size
	im_gui_style_var_table_angled_headers_angle
	im_gui_style_var_table_angled_headers_text_align
	im_gui_style_var_button_text_align
	im_gui_style_var_selectable_text_align
	im_gui_style_var_separator_text_border_size
	im_gui_style_var_separator_text_align
	im_gui_style_var_separator_text_padding
	im_gui_style_var_docking_separator_size
	im_gui_style_var_count
}

pub enum ImGuiButtonFlags {
	im_gui_button_flags_none                = 0
	im_gui_button_flags_mouse_button_left   = 1 << 0
	im_gui_button_flags_mouse_button_right  = 1 << 1
	im_gui_button_flags_mouse_button_middle = 1 << 2
	im_gui_button_flags_mouse_button_mask_  = 1 << 0 | 1 << 1 | 1 << 2
}

pub enum ImGuiColorEditFlags {
	im_gui_color_edit_flags_none               = 0
	im_gui_color_edit_flags_no_alpha           = 1 << 1
	im_gui_color_edit_flags_no_picker          = 1 << 2
	im_gui_color_edit_flags_no_options         = 1 << 3
	im_gui_color_edit_flags_no_small_preview   = 1 << 4
	im_gui_color_edit_flags_no_inputs          = 1 << 5
	im_gui_color_edit_flags_no_tooltip         = 1 << 6
	im_gui_color_edit_flags_no_label           = 1 << 7
	im_gui_color_edit_flags_no_side_preview    = 1 << 8
	im_gui_color_edit_flags_no_drag_drop       = 1 << 9
	im_gui_color_edit_flags_no_border          = 1 << 10
	im_gui_color_edit_flags_alpha_bar          = 1 << 16
	im_gui_color_edit_flags_alpha_preview      = 1 << 17
	im_gui_color_edit_flags_alpha_preview_half = 1 << 18
	im_gui_color_edit_flags_hdr                = 1 << 19
	im_gui_color_edit_flags_display_rgb        = 1 << 20
	im_gui_color_edit_flags_display_hsv        = 1 << 21
	im_gui_color_edit_flags_display_hex        = 1 << 22
	im_gui_color_edit_flags_uint8              = 1 << 23
	im_gui_color_edit_flags_float              = 1 << 24
	im_gui_color_edit_flags_picker_hue_bar     = 1 << 25
	im_gui_color_edit_flags_picker_hue_wheel   = 1 << 26
	im_gui_color_edit_flags_input_rgb          = 1 << 27
	im_gui_color_edit_flags_input_hsv          = 1 << 28
	// im_gui_color_edit_flags_default_options_   = 1 << 23 | .im_gui_color_edit_flags_display_rgb | .im_gui_color_edit_flags_input_rgb | .im_gui_color_edit_flags_picker_hue_bar
	im_gui_color_edit_flags_display_mask_ = 1 << 20 | 1 << 21 | 1 << 22
	// im_gui_color_edit_flags_data_type_mask_ = .im_gui_color_edit_flags_uint8 | .im_gui_color_edit_flags_float
	// im_gui_color_edit_flags_picker_mask_    = .im_gui_color_edit_flags_picker_hue_wheel | .im_gui_color_edit_flags_picker_hue_bar
	// im_gui_color_edit_flags_input_mask_     = .im_gui_color_edit_flags_input_rgb | .im_gui_color_edit_flags_input_hsv
}

pub enum ImGuiSliderFlags {
	im_gui_slider_flags_none               = 0
	im_gui_slider_flags_always_clamp       = 1 << 4
	im_gui_slider_flags_logarithmic        = 1 << 5
	im_gui_slider_flags_no_round_to_format = 1 << 6
	im_gui_slider_flags_no_input           = 1 << 7
	im_gui_slider_flags_wrap_around        = 1 << 8
	im_gui_slider_flags_invalid_mask_      = 1879048207
}

pub enum ImGuiMouseButton {
	im_gui_mouse_button_left   = 0
	im_gui_mouse_button_right  = 1
	im_gui_mouse_button_middle = 2
	im_gui_mouse_button_count  = 5
}

pub enum ImGuiMouseCursor {
	im_gui_mouse_cursor_none  = -1
	im_gui_mouse_cursor_arrow = 0
	im_gui_mouse_cursor_text_input
	im_gui_mouse_cursor_resize_all
	im_gui_mouse_cursor_resize_ns
	im_gui_mouse_cursor_resize_ew
	im_gui_mouse_cursor_resize_nesw
	im_gui_mouse_cursor_resize_nwse
	im_gui_mouse_cursor_hand
	im_gui_mouse_cursor_not_allowed
	im_gui_mouse_cursor_count
}

pub enum ImGuiMouseSource {
	im_gui_mouse_source_mouse        = 0
	im_gui_mouse_source_touch_screen = 1
	im_gui_mouse_source_pen          = 2
	im_gui_mouse_source_count        = 3
}

pub enum ImGuiCond {
	im_gui_cond_none           = 0
	im_gui_cond_always         = 1 << 0
	im_gui_cond_once           = 1 << 1
	im_gui_cond_first_use_ever = 1 << 2
	im_gui_cond_appearing      = 1 << 3
}

pub enum ImGuiTableFlags {
	im_gui_table_flags_none                 = 0
	im_gui_table_flags_resizable            = 1 << 0
	im_gui_table_flags_reorderable          = 1 << 1
	im_gui_table_flags_hideable             = 1 << 2
	im_gui_table_flags_sortable             = 1 << 3
	im_gui_table_flags_no_saved_settings    = 1 << 4
	im_gui_table_flags_context_menu_in_body = 1 << 5
	im_gui_table_flags_row_bg               = 1 << 6
	im_gui_table_flags_borders_inner_h      = 1 << 7
	im_gui_table_flags_borders_outer_h      = 1 << 8
	im_gui_table_flags_borders_inner_v      = 1 << 9
	im_gui_table_flags_borders_outer_v      = 1 << 10
	// im_gui_table_flags_borders_h                       = .im_gui_table_flags_borders_inner_h | .im_gui_table_flags_borders_outer_h
	// im_gui_table_flags_borders_v                       = .im_gui_table_flags_borders_inner_v | .im_gui_table_flags_borders_outer_v
	// im_gui_table_flags_borders_inner                   = .im_gui_table_flags_borders_inner_v | .im_gui_table_flags_borders_inner_h
	// im_gui_table_flags_borders_outer                   = .im_gui_table_flags_borders_outer_v | .im_gui_table_flags_borders_outer_h
	// im_gui_table_flags_borders                         = .im_gui_table_flags_borders_inner | .im_gui_table_flags_borders_outer
	im_gui_table_flags_no_borders_in_body              = 1 << 11
	im_gui_table_flags_no_borders_in_body_until_resize = 1 << 12
	im_gui_table_flags_sizing_fixed_fit                = 1 << 13
	im_gui_table_flags_sizing_fixed_same               = 2 << 13
	im_gui_table_flags_sizing_stretch_prop             = 3 << 13
	im_gui_table_flags_sizing_stretch_same             = 4 << 13
	im_gui_table_flags_no_host_extend_x                = 1 << 16
	im_gui_table_flags_no_host_extend_y                = 1 << 17
	im_gui_table_flags_no_keep_columns_visible         = 1 << 18
	im_gui_table_flags_precise_widths                  = 1 << 19
	im_gui_table_flags_no_clip                         = 1 << 20
	im_gui_table_flags_pad_outer_x                     = 1 << 21
	im_gui_table_flags_no_pad_outer_x                  = 1 << 22
	im_gui_table_flags_no_pad_inner_x                  = 1 << 23
	im_gui_table_flags_scroll_x                        = 1 << 24
	im_gui_table_flags_scroll_y                        = 1 << 25
	im_gui_table_flags_sort_multi                      = 1 << 26
	im_gui_table_flags_sort_tristate                   = 1 << 27
	im_gui_table_flags_highlight_hovered_column        = 1 << 28
	// im_gui_table_flags_sizing_mask_                    = .im_gui_table_flags_sizing_fixed_fit | .im_gui_table_flags_sizing_fixed_same | .im_gui_table_flags_sizing_stretch_prop | .im_gui_table_flags_sizing_stretch_same
}

pub enum ImGuiTableColumnFlags {
	im_gui_table_column_flags_none                   = 0
	im_gui_table_column_flags_disabled               = 1 << 0
	im_gui_table_column_flags_default_hide           = 1 << 1
	im_gui_table_column_flags_default_sort           = 1 << 2
	im_gui_table_column_flags_width_stretch          = 1 << 3
	im_gui_table_column_flags_width_fixed            = 1 << 4
	im_gui_table_column_flags_no_resize              = 1 << 5
	im_gui_table_column_flags_no_reorder             = 1 << 6
	im_gui_table_column_flags_no_hide                = 1 << 7
	im_gui_table_column_flags_no_clip                = 1 << 8
	im_gui_table_column_flags_no_sort                = 1 << 9
	im_gui_table_column_flags_no_sort_ascending      = 1 << 10
	im_gui_table_column_flags_no_sort_descending     = 1 << 11
	im_gui_table_column_flags_no_header_label        = 1 << 12
	im_gui_table_column_flags_no_header_width        = 1 << 13
	im_gui_table_column_flags_prefer_sort_ascending  = 1 << 14
	im_gui_table_column_flags_prefer_sort_descending = 1 << 15
	im_gui_table_column_flags_indent_enable          = 1 << 16
	im_gui_table_column_flags_indent_disable         = 1 << 17
	im_gui_table_column_flags_angled_header          = 1 << 18
	im_gui_table_column_flags_is_enabled             = 1 << 24
	im_gui_table_column_flags_is_visible             = 1 << 25
	im_gui_table_column_flags_is_sorted              = 1 << 26
	im_gui_table_column_flags_is_hovered             = 1 << 27
	// im_gui_table_column_flags_width_mask_            = .im_gui_table_column_flags_width_stretch | .im_gui_table_column_flags_width_fixed
	// im_gui_table_column_flags_indent_mask_           = .im_gui_table_column_flags_indent_enable | .im_gui_table_column_flags_indent_disable
	// im_gui_table_column_flags_status_mask_           = .im_gui_table_column_flags_is_enabled | .im_gui_table_column_flags_is_visible | .im_gui_table_column_flags_is_sorted | .im_gui_table_column_flags_is_hovered
	im_gui_table_column_flags_no_direct_resize_ = 1 << 30
}

pub enum ImGuiTableRowFlags {
	im_gui_table_row_flags_none    = 0
	im_gui_table_row_flags_headers = 1 << 0
}

pub enum ImGuiTableBgTarget {
	im_gui_table_bg_target_none    = 0
	im_gui_table_bg_target_row_bg0 = 1
	im_gui_table_bg_target_row_bg1 = 2
	im_gui_table_bg_target_cell_bg = 3
}

pub struct C.ImGuiTableSortSpecs {
pub:
	specs      &C.ImGuiTableColumnSortSpecs
	specsCount int
	specsDirty bool
}

pub type ImGuiTableSortSpecs = C.ImGuiTableSortSpecs

pub struct C.ImGuiTableColumnSortSpecs {
pub:
	columnUserID  ImGuiID
	columnIndex   ImS16
	sortOrder     ImS16
	sortDirection ImGuiSortDirection
}

pub type ImGuiTableColumnSortSpecs = C.ImGuiTableColumnSortSpecs

pub struct C.ImGuiStyle {
pub:
	alpha                       f32
	disabledAlpha               f32
	windowPadding               C.ImVec2
	windowRounding              f32
	windowBorderSize            f32
	windowMinSize               C.ImVec2
	windowTitleAlign            C.ImVec2
	windowMenuButtonPosition    ImGuiDir
	childRounding               f32
	childBorderSize             f32
	popupRounding               f32
	popupBorderSize             f32
	FramePadding                C.ImVec2
	frameRounding               f32
	frameBorderSize             f32
	itemSpacing                 C.ImVec2
	itemInnerSpacing            C.ImVec2
	cellPadding                 C.ImVec2
	touchExtraPadding           C.ImVec2
	indentSpacing               f32
	columnsMinSpacing           f32
	scrollbarSize               f32
	scrollbarRounding           f32
	grabMinSize                 f32
	grabRounding                f32
	logSliderDeadzone           f32
	tabRounding                 f32
	tabBorderSize               f32
	tabMinWidthForCloseButton   f32
	tabBarBorderSize            f32
	tabBarOverlineSize          f32
	tableAngledHeadersAngle     f32
	tableAngledHeadersTextAlign C.ImVec2
	colorButtonPosition         ImGuiDir
	buttonTextAlign             C.ImVec2
	selectableTextAlign         C.ImVec2
	separatorTextBorderSize     f32
	separatorTextAlign          C.ImVec2
	separatorTextPadding        C.ImVec2
	displayWindowPadding        C.ImVec2
	displaySafeAreaPadding      C.ImVec2
	dockingSeparatorSize        f32
	mouseCursorScale            f32
	antiAliasedLines            bool
	antiAliasedLinesUseTex      bool
	antiAliasedFill             bool
	curveTessellationTol        f32
	circleTessellationMaxError  f32
	colors                      [58]ImVec4
	hoverStationaryDelay        f32
	hoverDelayShort             f32
	hoverDelayNormal            f32
	hoverFlagsForTooltipMouse   ImGuiHoveredFlags
	hoverFlagsForTooltipNav     ImGuiHoveredFlags
}

pub type ImGuiStyle = C.ImGuiStyle

pub struct C.ImGuiKeyData {
pub:
	down             bool
	downDuration     f32
	downDurationPrev f32
	analogValue      f32
}

pub type ImGuiKeyData = C.ImGuiKeyData

pub struct C.ImVector_ImWchar {
pub:
	size     int
	capacity int
	data     &ImWchar
}

pub type ImVector_ImWchar = C.ImVector_ImWchar

pub struct C.ImGuiIO {
pub:
	configFlags                       ImGuiConfigFlags
	backendFlags                      ImGuiBackendFlags
	displaySize                       C.ImVec2
	deltaTime                         f32
	iniSavingRate                     f32
	iniFilename                       &i8
	logFilename                       &i8
	userData                          voidptr
	fonts                             &C.ImFontAtlas
	fontGlobalScale                   f32
	fontAllowUserScaling              bool
	fontDefault                       &C.ImFont
	displayFramebufferScale           C.ImVec2
	configDockingNoSplit              bool
	configDockingWithShift            bool
	configDockingAlwaysTabBar         bool
	configDockingTransparentPayload   bool
	configViewportsNoAutoMerge        bool
	configViewportsNoTaskBarIcon      bool
	configViewportsNoDecoration       bool
	configViewportsNoDefaultParent    bool
	mouseDrawCursor                   bool
	configMacOSXBehaviors             bool
	configNavSwapGamepadButtons       bool
	configInputTrickleEventQueue      bool
	configInputTextCursorBlink        bool
	configInputTextEnterKeepActive    bool
	configDragClickToInputText        bool
	configWindowsResizeFromEdges      bool
	configWindowsMoveFromTitleBarOnly bool
	configMemoryCompactTimer          f32
	mouseDoubleClickTime              f32
	mouseDoubleClickMaxDist           f32
	mouseDragThreshold                f32
	keyRepeatDelay                    f32
	keyRepeatRate                     f32
	configDebugIsDebuggerPresent      bool
	configDebugBeginReturnValueOnce   bool
	configDebugBeginReturnValueLoop   bool
	configDebugIgnoreFocusLoss        bool
	configDebugIniSettings            bool
	backendPlatformName               &i8
	backendRendererName               &i8
	backendPlatformUserData           voidptr
	backendRendererUserData           voidptr
	backendLanguageUserData           voidptr
	wantCaptureMouse                  bool
	wantCaptureKeyboard               bool
	wantTextInput                     bool
	wantSetMousePos                   bool
	wantSaveIniSettings               bool
	navActive                         bool
	navVisible                        bool
	framerate                         f32
	metricsRenderVertices             int
	metricsRenderIndices              int
	metricsRenderWindows              int
	metricsActiveWindows              int
	mouseDelta                        C.ImVec2
	ctx                               &C.ImGuiContext
	mousePos                          C.ImVec2
	mouseDown                         [5]bool
	mouseWheel                        f32
	mouseWheelH                       f32
	mouseSource                       ImGuiMouseSource
	mouseHoveredViewport              ImGuiID
	keyCtrl                           bool
	keyShift                          bool
	keyAlt                            bool
	keySuper                          bool
	keyMods                           ImGuiKeyChord
	keysData                          [154]ImGuiKeyData
	wantCaptureMouseUnlessPopupClose  bool
	mousePosPrev                      C.ImVec2
	mouseClickedPos                   [5]ImVec2
	mouseClickedTime                  [5]f64
	mouseClicked                      [5]bool
	mouseDoubleClicked                [5]bool
	mouseClickedCount                 [5]ImU16
	mouseClickedLastCount             [5]ImU16
	mouseReleased                     [5]bool
	mouseDownOwned                    [5]bool
	mouseDownOwnedUnlessPopupClose    [5]bool
	mouseWheelRequestAxisSwap         bool
	mouseCtrlLeftAsRightClick         bool
	mouseDownDuration                 [5]f32
	mouseDownDurationPrev             [5]f32
	mouseDragMaxDistanceAbs           [5]ImVec2
	mouseDragMaxDistanceSqr           [5]f32
	penPressure                       f32
	appFocusLost                      bool
	appAcceptingEvents                bool
	backendUsingLegacyKeyArrays       ImS8
	backendUsingLegacyNavInputArray   bool
	inputQueueSurrogate               ImWchar16
	inputQueueCharacters              C.ImVector_ImWchar
}

pub type ImGuiIO = C.ImGuiIO

pub struct C.ImGuiInputTextCallbackData {
pub:
	ctx            &C.ImGuiContext
	eventFlag      ImGuiInputTextFlags
	flags          ImGuiInputTextFlags
	userData       voidptr
	eventChar      ImWchar
	eventKey       ImGuiKey
	buf            &i8
	bufTextLen     int
	bufSize        int
	bufDirty       bool
	cursorPos      int
	selectionStart int
	selectionEnd   int
}

pub type ImGuiInputTextCallbackData = C.ImGuiInputTextCallbackData

pub struct C.ImGuiSizeCallbackData {
pub:
	userData    voidptr
	pos         C.ImVec2
	currentSize C.ImVec2
	desiredSize C.ImVec2
}

pub type ImGuiSizeCallbackData = C.ImGuiSizeCallbackData

pub struct C.ImGuiWindowClass {
pub:
	classId                    ImGuiID
	parentViewportId           ImGuiID
	focusRouteParentWindowId   ImGuiID
	viewportFlagsOverrideSet   ImGuiViewportFlags
	viewportFlagsOverrideClear ImGuiViewportFlags
	tabItemFlagsOverrideSet    ImGuiTabItemFlags
	dockNodeFlagsOverrideSet   ImGuiDockNodeFlags
	dockingAlwaysTabBar        bool
	dockingAllowUnclassed      bool
}

pub type ImGuiWindowClass = C.ImGuiWindowClass

pub struct C.ImGuiPayload {
pub:
	data           voidptr
	dataSize       int
	sourceId       ImGuiID
	sourceParentId ImGuiID
	dataFrameCount int
	dataType       [33]i8
	preview        bool
	delivery       bool
}

pub type ImGuiPayload = C.ImGuiPayload

pub struct C.ImGuiOnceUponAFrame {
pub:
	refFrame int
}

pub type ImGuiOnceUponAFrame = C.ImGuiOnceUponAFrame

pub struct C.ImGuiTextRange {
pub:
	b &i8
	e &i8
}

pub type ImGuiTextRange = C.ImGuiTextRange

pub struct C.ImVector_ImGuiTextRange {
pub:
	size     int
	capacity int
	data     &C.ImGuiTextRange
}

pub type ImVector_ImGuiTextRange = C.ImVector_ImGuiTextRange

pub struct C.ImGuiTextFilter {
pub:
	inputBuf  [256]i8
	filters   C.ImVector_ImGuiTextRange
	countGrep int
}

pub type ImGuiTextFilter = C.ImGuiTextFilter

pub struct C.ImVector_char {
pub:
	size     int
	capacity int
	data     &i8
}

pub type ImVector_char = C.ImVector_char

pub struct C.ImGuiTextBuffer {
pub:
	buf C.ImVector_char
}

pub type ImGuiTextBuffer = C.ImGuiTextBuffer

pub struct C.ImGuiStoragePair {
pub:
	key ImGuiID
}

pub type ImGuiStoragePair = C.ImGuiStoragePair

pub struct C.ImVector_ImGuiStoragePair {
pub:
	size     int
	capacity int
	data     &C.ImGuiStoragePair
}

pub type ImVector_ImGuiStoragePair = C.ImVector_ImGuiStoragePair

pub struct C.ImGuiStorage {
pub:
	data C.ImVector_ImGuiStoragePair
}

pub type ImGuiStorage = C.ImGuiStorage

pub struct C.ImGuiListClipper {
pub:
	ctx              &C.ImGuiContext
	displayStart     int
	displayEnd       int
	itemsCount       int
	itemsHeight      f32
	startPosY        f32
	startSeekOffsetY f64
	tempData         voidptr
}

pub type ImGuiListClipper = C.ImGuiListClipper

pub struct C.ImColor {
pub:
	value C.ImVec4
}

pub type ImColor = C.ImColor

pub enum ImGuiMultiSelectFlags {
	im_gui_multi_select_flags_none                      = 0
	im_gui_multi_select_flags_single_select             = 1 << 0
	im_gui_multi_select_flags_no_select_all             = 1 << 1
	im_gui_multi_select_flags_no_range_select           = 1 << 2
	im_gui_multi_select_flags_no_auto_select            = 1 << 3
	im_gui_multi_select_flags_no_auto_clear             = 1 << 4
	im_gui_multi_select_flags_no_auto_clear_on_reselect = 1 << 5
	im_gui_multi_select_flags_box_select1d              = 1 << 6
	im_gui_multi_select_flags_box_select2d              = 1 << 7
	im_gui_multi_select_flags_box_select_no_scroll      = 1 << 8
	im_gui_multi_select_flags_clear_on_escape           = 1 << 9
	im_gui_multi_select_flags_clear_on_click_void       = 1 << 10
	im_gui_multi_select_flags_scope_window              = 1 << 11
	im_gui_multi_select_flags_scope_rect                = 1 << 12
	im_gui_multi_select_flags_select_on_click           = 1 << 13
	im_gui_multi_select_flags_select_on_click_release   = 1 << 14
	im_gui_multi_select_flags_nav_wrap_x                = 1 << 16
}

pub struct C.ImVector_ImGuiSelectionRequest {
pub:
	size     int
	capacity int
	data     &C.ImGuiSelectionRequest
}

pub type ImVector_ImGuiSelectionRequest = C.ImVector_ImGuiSelectionRequest

pub struct C.ImGuiMultiSelectIO {
pub:
	requests      C.ImVector_ImGuiSelectionRequest
	rangeSrcItem  ImGuiSelectionUserData
	navIdItem     ImGuiSelectionUserData
	navIdSelected bool
	rangeSrcReset bool
	itemsCount    int
}

pub type ImGuiMultiSelectIO = C.ImGuiMultiSelectIO

pub enum ImGuiSelectionRequestType {
	im_gui_selection_request_type_none = 0
	im_gui_selection_request_type_set_all
	im_gui_selection_request_type_set_range
}

pub struct C.ImGuiSelectionRequest {
pub:
	type           ImGuiSelectionRequestType
	selected       bool
	rangeDirection ImS8
	rangeFirstItem ImGuiSelectionUserData
	rangeLastItem  ImGuiSelectionUserData
}

pub type ImGuiSelectionRequest = C.ImGuiSelectionRequest

pub struct C.ImGuiSelectionBasicStorage {
pub:
	size                    int
	preserveOrder           bool
	userData                voidptr
	adapterIndexToStorageId fn (&C.ImGuiSelectionBasicStorage, int) ImGuiID
	_SelectionOrder         int
	_Storage                C.ImGuiStorage
}

pub type ImGuiSelectionBasicStorage = C.ImGuiSelectionBasicStorage

pub struct C.ImGuiSelectionExternalStorage {
pub:
	userData               voidptr
	adapterSetItemSelected fn (&C.ImGuiSelectionExternalStorage, int, bool)
}

pub type ImGuiSelectionExternalStorage = C.ImGuiSelectionExternalStorage

// typedef void (*ImDrawCallback)(const C.ImDrawList *parent_list, const C.ImDrawCmd *cmd);
pub type ImDrawCallback = fn (&C.ImDrawList, &C.ImDrawCmd)

pub struct C.ImDrawCmd {
pub:
	clipRect         C.ImVec4
	textureId        ImTextureID
	vtxOffset        u32
	idxOffset        u32
	elemCount        u32
	userCallback     ImDrawCallback
	userCallbackData voidptr
}

pub type ImDrawCmd = C.ImDrawCmd

pub struct C.ImDrawVert {
pub:
	pos C.ImVec2
	uv  C.ImVec2
	col ImU32
}

pub type ImDrawVert = C.ImDrawVert

pub struct C.ImDrawCmdHeader {
pub:
	clipRect  C.ImVec4
	textureId ImTextureID
	vtxOffset u32
}

pub type ImDrawCmdHeader = C.ImDrawCmdHeader

pub struct C.ImVector_ImDrawCmd {
pub:
	size     int
	capacity int
	data     &C.ImDrawCmd
}

pub type ImVector_ImDrawCmd = C.ImVector_ImDrawCmd

pub struct C.ImVector_ImDrawIdx {
pub:
	size     int
	capacity int
	data     &ImDrawIdx
}

pub type ImVector_ImDrawIdx = C.ImVector_ImDrawIdx

pub struct C.ImDrawChannel {
pub:
	_CmdBuffer C.ImVector_ImDrawCmd
	_IdxBuffer C.ImVector_ImDrawIdx
}

pub type ImDrawChannel = C.ImDrawChannel

pub struct C.ImVector_ImDrawChannel {
pub:
	size     int
	capacity int
	data     &C.ImDrawChannel
}

pub type ImVector_ImDrawChannel = C.ImVector_ImDrawChannel

pub struct C.ImDrawListSplitter {
pub:
	_Current  int
	_Count    int
	_Channels C.ImVector_ImDrawChannel
}

pub type ImDrawListSplitter = C.ImDrawListSplitter

enum ImDrawFlags {
	im_draw_flags_none                       = 0
	im_draw_flags_closed                     = 1 << 0
	im_draw_flags_round_corners_top_left     = 1 << 4
	im_draw_flags_round_corners_top_right    = 1 << 5
	im_draw_flags_round_corners_bottom_left  = 1 << 6
	im_draw_flags_round_corners_bottom_right = 1 << 7
	im_draw_flags_round_corners_none         = 1 << 8
	// im_draw_flags_round_corners_top          = .im_draw_flags_round_corners_top_left | .im_draw_flags_round_corners_top_right
	// im_draw_flags_round_corners_bottom       = .im_draw_flags_round_corners_bottom_left | .im_draw_flags_round_corners_bottom_right
	// im_draw_flags_round_corners_left         = .im_draw_flags_round_corners_bottom_left | .im_draw_flags_round_corners_top_left
	// im_draw_flags_round_corners_right        = .im_draw_flags_round_corners_bottom_right | .im_draw_flags_round_corners_top_right
	// im_draw_flags_round_corners_all          = .im_draw_flags_round_corners_top_left | .im_draw_flags_round_corners_top_right | .im_draw_flags_round_corners_bottom_left | .im_draw_flags_round_corners_bottom_right
	// im_draw_flags_round_corners_default_     = .im_draw_flags_round_corners_all
	// im_draw_flags_round_corners_mask_ = .im_draw_flags_round_corners_all | .im_draw_flags_round_corners_none
}

enum ImDrawListFlags {
	im_draw_list_flags_none                       = 0
	im_draw_list_flags_anti_aliased_lines         = 1 << 0
	im_draw_list_flags_anti_aliased_lines_use_tex = 1 << 1
	im_draw_list_flags_anti_aliased_fill          = 1 << 2
	im_draw_list_flags_allow_vtx_offset           = 1 << 3
}

pub struct C.ImVector_ImDrawVert {
pub:
	size     int
	capacity int
	data     &C.ImDrawVert
}

pub type ImVector_ImDrawVert = C.ImVector_ImDrawVert

pub struct C.ImVector_ImVec2 {
pub:
	size     int
	capacity int
	data     &C.ImVec2
}

pub type ImVector_ImVec2 = C.ImVector_ImVec2

pub struct C.ImVector_ImVec4 {
pub:
	size     int
	capacity int
	data     &C.ImVec4
}

pub type ImVector_ImVec4 = C.ImVector_ImVec4

pub struct C.ImVector_ImTextureID {
pub:
	size     int
	capacity int
	data     &ImTextureID
}

pub type ImVector_ImTextureID = C.ImVector_ImTextureID

pub struct C.ImDrawList {
pub:
	cmdBuffer       C.ImVector_ImDrawCmd
	idxBuffer       C.ImVector_ImDrawIdx
	vtxBuffer       C.ImVector_ImDrawVert
	flags           ImDrawListFlags
	_VtxCurrentIdx  u32
	_Data           &C.ImDrawListSharedData
	_VtxWritePtr    &C.ImDrawVert
	_IdxWritePtr    &ImDrawIdx
	_Path           C.ImVector_ImVec2
	_CmdHeader      C.ImDrawCmdHeader
	_Splitter       C.ImDrawListSplitter
	_ClipRectStack  C.ImVector_ImVec4
	_TextureIdStack C.ImVector_ImTextureID
	_FringeScale    f32
	_OwnerName      &i8
}

pub type ImDrawList = C.ImDrawList

pub struct C.ImVector_ImDrawListPtr {
pub:
	size     int
	capacity int
	data     &&C.ImDrawList
}

pub type ImVector_ImDrawListPtr = C.ImVector_ImDrawListPtr

pub struct C.ImDrawData {
pub:
	valid            bool
	cmdListsCount    int
	totalIdxCount    int
	totalVtxCount    int
	cmdLists         C.ImVector_ImDrawListPtr
	displayPos       C.ImVec2
	displaySize      C.ImVec2
	framebufferScale C.ImVec2
	ownerViewport    &C.ImGuiViewport
}

pub type ImDrawData = C.ImDrawData

pub struct C.ImFontConfig {
pub:
	fontData             voidptr
	fontDataSize         int
	fontDataOwnedByAtlas bool
	fontNo               int
	sizePixels           f32
	oversampleH          int
	oversampleV          int
	pixelSnapH           bool
	glyphExtraSpacing    C.ImVec2
	glyphOffset          C.ImVec2
	glyphRanges          &ImWchar
	glyphMinAdvanceX     f32
	glyphMaxAdvanceX     f32
	mergeMode            bool
	fontBuilderFlags     u32
	rasterizerMultiply   f32
	rasterizerDensity    f32
	ellipsisChar         ImWchar
	name                 [40]i8
	dstFont              &C.ImFont
}

pub type ImFontConfig = C.ImFontConfig

pub struct C.ImFontGlyph {
pub:
	colored   u32
	visible   u32
	codepoint u32
	advanceX  f32
	x0        f32
	y0        f32
	x1        f32
	y1        f32
	u0        f32
	v0        f32
	u1        f32
	v1        f32
}

pub type ImFontGlyph = C.ImFontGlyph

pub struct C.ImVector_ImU32 {
pub:
	size     int
	capacity int
	data     &ImU32
}

pub type ImVector_ImU32 = C.ImVector_ImU32

pub struct C.ImFontGlyphRangesBuilder {
pub:
	usedChars C.ImVector_ImU32
}

pub type ImFontGlyphRangesBuilder = C.ImFontGlyphRangesBuilder

pub struct C.ImFontAtlasCustomRect {
pub:
	width         u16
	height        u16
	x             u16
	y             u16
	glyphID       u32
	glyphAdvanceX f32
	glyphOffset   C.ImVec2
	font          &C.ImFont
}

pub type ImFontAtlasCustomRect = C.ImFontAtlasCustomRect

enum ImFontAtlasFlags {
	im_font_atlas_flags_none                   = 0
	im_font_atlas_flags_no_power_of_two_height = 1 << 0
	im_font_atlas_flags_no_mouse_cursors       = 1 << 1
	im_font_atlas_flags_no_baked_lines         = 1 << 2
}

pub struct C.ImVector_ImFontPtr {
pub:
	size     int
	capacity int
	data     &&C.ImFont
}

pub type ImVector_ImFontPtr = C.ImVector_ImFontPtr

pub struct C.ImVector_ImFontAtlasCustomRect {
pub:
	size     int
	capacity int
	data     &C.ImFontAtlasCustomRect
}

pub type ImVector_ImFontAtlasCustomRect = C.ImVector_ImFontAtlasCustomRect

pub struct C.ImVector_ImFontConfig {
pub:
	size     int
	capacity int
	data     &C.ImFontConfig
}

pub type ImVector_ImFontConfig = C.ImVector_ImFontConfig

pub struct C.ImFontAtlas {
pub:
	flags              ImFontAtlasFlags
	texID              ImTextureID
	texDesiredWidth    int
	texGlyphPadding    int
	locked             bool
	userData           voidptr
	texReady           bool
	texPixelsUseColors bool
	texPixelsAlpha8    &u8
	texPixelsRGBA32    &u32
	texWidth           int
	texHeight          int
	texUvScale         C.ImVec2
	texUvWhitePixel    C.ImVec2
	fonts              C.ImVector_ImFontPtr
	customRects        C.ImVector_ImFontAtlasCustomRect
	configData         C.ImVector_ImFontConfig
	texUvLines         [64]ImVec4
	fontBuilderIO      &C.ImFontBuilderIO
	fontBuilderFlags   u32
	packIdMouseCursors int
	packIdLines        int
}

pub type ImFontAtlas = C.ImFontAtlas

pub struct C.ImVector_float {
pub:
	size     int
	capacity int
	data     &f32
}

pub type ImVector_float = C.ImVector_float

pub struct C.ImVector_ImFontGlyph {
pub:
	size     int
	capacity int
	data     &C.ImFontGlyph
}

pub type ImVector_ImFontGlyph = C.ImVector_ImFontGlyph

pub struct C.ImFont {
pub:
	indexAdvanceX       C.ImVector_float
	fallbackAdvanceX    f32
	fontSize            f32
	indexLookup         C.ImVector_ImWchar
	glyphs              C.ImVector_ImFontGlyph
	fallbackGlyph       &C.ImFontGlyph
	containerAtlas      &C.ImFontAtlas
	configData          &C.ImFontConfig
	configDataCount     i16
	fallbackChar        ImWchar
	ellipsisChar        ImWchar
	ellipsisCharCount   i16
	ellipsisWidth       f32
	ellipsisCharStep    f32
	dirtyLookupTables   bool
	scale               f32
	ascent              f32
	descent             f32
	metricsTotalSurface int
	used4kPagesMap      [2]ImU8
}

pub type ImFont = C.ImFont

pub enum ImGuiViewportFlags {
	im_gui_viewport_flags_none                   = 0
	im_gui_viewport_flags_is_platform_window     = 1 << 0
	im_gui_viewport_flags_is_platform_monitor    = 1 << 1
	im_gui_viewport_flags_owned_by_app           = 1 << 2
	im_gui_viewport_flags_no_decoration          = 1 << 3
	im_gui_viewport_flags_no_task_bar_icon       = 1 << 4
	im_gui_viewport_flags_no_focus_on_appearing  = 1 << 5
	im_gui_viewport_flags_no_focus_on_click      = 1 << 6
	im_gui_viewport_flags_no_inputs              = 1 << 7
	im_gui_viewport_flags_no_renderer_clear      = 1 << 8
	im_gui_viewport_flags_no_auto_merge          = 1 << 9
	im_gui_viewport_flags_top_most               = 1 << 10
	im_gui_viewport_flags_can_host_other_windows = 1 << 11
	im_gui_viewport_flags_is_minimized           = 1 << 12
	im_gui_viewport_flags_is_focused             = 1 << 13
}

pub struct C.ImGuiViewport {
pub:
	iD                    ImGuiID
	flags                 ImGuiViewportFlags
	pos                   C.ImVec2
	size                  C.ImVec2
	workPos               C.ImVec2
	workSize              C.ImVec2
	dpiScale              f32
	parentViewportId      ImGuiID
	drawData              &C.ImDrawData
	rendererUserData      voidptr
	platformUserData      voidptr
	platformHandle        voidptr
	platformHandleRaw     voidptr
	platformWindowCreated bool
	platformRequestMove   bool
	platformRequestResize bool
	platformRequestClose  bool
}

pub type ImGuiViewport = C.ImGuiViewport

pub struct C.ImVector_ImGuiPlatformMonitor {
pub:
	size     int
	capacity int
	data     &C.ImGuiPlatformMonitor
}

pub type ImVector_ImGuiPlatformMonitor = C.ImVector_ImGuiPlatformMonitor

pub struct C.ImVector_ImGuiViewportPtr {
pub:
	size     int
	capacity int
	data     &&C.ImGuiViewport
}

pub type ImVector_ImGuiViewportPtr = C.ImVector_ImGuiViewportPtr

pub struct C.ImGuiPlatformIO {
pub:
	platform_GetClipboardTextFn      fn (&C.ImGuiContext) &i8
	platform_SetClipboardTextFn      fn (&C.ImGuiContext, &i8)
	platform_ClipboardUserData       voidptr
	platform_OpenInShellFn           fn (&C.ImGuiContext, &i8) bool
	platform_OpenInShellUserData     voidptr
	platform_SetImeDataFn            fn (&C.ImGuiContext, &C.ImGuiViewport, &C.ImGuiPlatformImeData)
	platform_ImeUserData             voidptr
	platform_LocaleDecimalPoint      ImWchar
	platform_CreateWindow            fn (&C.ImGuiViewport)
	platform_DestroyWindow           fn (&C.ImGuiViewport)
	platform_ShowWindow              fn (&C.ImGuiViewport)
	platform_SetWindowPos            fn (&C.ImGuiViewport, C.ImVec2)
	platform_GetWindowPos            fn (&C.ImGuiViewport) C.ImVec2
	platform_SetWindowSize           fn (&C.ImGuiViewport, C.ImVec2)
	platform_GetWindowSize           fn (&C.ImGuiViewport) C.ImVec2
	platform_SetWindowFocus          fn (&C.ImGuiViewport)
	platform_GetWindowFocus          fn (&C.ImGuiViewport) bool
	platform_GetWindowMinimized      fn (&C.ImGuiViewport) bool
	platform_SetWindowTitle          fn (&C.ImGuiViewport, &i8)
	platform_SetWindowAlpha          fn (&C.ImGuiViewport, f32)
	platform_UpdateWindow            fn (&C.ImGuiViewport)
	platform_RenderWindow            fn (&C.ImGuiViewport, voidptr)
	platform_SwapBuffers             fn (&C.ImGuiViewport, voidptr)
	platform_GetWindowDpiScale       fn (&C.ImGuiViewport) f32
	platform_OnChangedViewport       fn (&C.ImGuiViewport)
	platform_GetWindowWorkAreaInsets fn (&C.ImGuiViewport) C.ImVec4
	platform_CreateVkSurface         fn (&C.ImGuiViewport, ImU64, voidptr, &ImU64) int
	renderer_CreateWindow            fn (&C.ImGuiViewport)
	renderer_DestroyWindow           fn (&C.ImGuiViewport)
	renderer_SetWindowSize           fn (&C.ImGuiViewport, C.ImVec2)
	renderer_RenderWindow            fn (&C.ImGuiViewport, voidptr)
	renderer_SwapBuffers             fn (&C.ImGuiViewport, voidptr)
	monitors                         C.ImVector_ImGuiPlatformMonitor
	viewports                        C.ImVector_ImGuiViewportPtr
}

pub type ImGuiPlatformIO = C.ImGuiPlatformIO

pub struct C.ImGuiPlatformMonitor {
pub:
	mainPos        C.ImVec2
	mainSize       C.ImVec2
	workPos        C.ImVec2
	workSize       C.ImVec2
	dpiScale       f32
	platformHandle voidptr
}

pub type ImGuiPlatformMonitor = C.ImGuiPlatformMonitor

pub struct C.ImGuiPlatformImeData {
pub:
	wantVisible     bool
	inputPos        C.ImVec2
	inputLineHeight f32
}

pub type ImGuiPlatformImeData = C.ImGuiPlatformImeData

pub type ImGuiDataAuthority = int
pub type ImGuiLayoutType = int

// type ImGuiActivateFlags = int
// type ImGuiDebugLogFlags = int
// type ImGuiFocusRequestFlags = int
// type ImGuiItemStatusFlags = int
// type ImGuiOldColumnFlags = int
// type ImGuiNavHighlightFlags = int
// type ImGuiNavMoveFlags = int
// type ImGuiNextItemDataFlags = int
// type ImGuiNextWindowDataFlags = int
// type ImGuiScrollFlags = int
// type ImGuiSeparatorFlags = int
// type ImGuiTextFlags = int
// type ImGuiTooltipFlags = int
// type ImGuiTypingSelectFlags = int
// type ImGuiWindowRefreshFlags = int
pub type ImGuiErrorLogCallback = fn (voidptr, ...&i8)

pub struct C.StbUndoRecord {
pub:
	where         int
	insert_length int
	delete_length int
	char_storage  int
}

pub type StbUndoRecord = C.StbUndoRecord

pub struct C.StbUndoState {
pub:
	undo_rec        [99]StbUndoRecord
	undo_char       [999]ImWchar
	undo_point      i16
	redo_point      i16
	undo_char_point int
	redo_char_point int
}

pub type StbUndoState = C.StbUndoState

pub struct C.STB_TexteditState {
pub:
	cursor                int
	select_start          int
	select_end            int
	insert_mode           u8
	row_count_per_page    int
	cursor_at_end_of_line u8
	initialized           u8
	has_preferred_x       u8
	single_line           u8
	padding1              u8
	padding2              u8
	padding3              u8
	preferred_x           f32
	undostate             StbUndoState
}

pub type STB_TexteditState = C.STB_TexteditState

@[typedef]
pub struct C.ImFileHandle {
pub:
	x0               f32
	x1               f32
	baseline_y_delta f32
	ymin             f32
	ymax             f32
	num_chars        int
}

pub type ImFileHandle = C.ImFileHandle

pub struct C.ImVec1 {
pub:
	x f32
}

pub type ImVec1 = C.ImVec1

pub struct C.ImVec2ih {
pub:
	x i16
	y i16
}

pub type ImVec2ih = C.ImVec2ih

pub struct C.ImRect {
pub:
	min C.ImVec2
	max C.ImVec2
}

pub type ImRect = C.ImRect

// typedef ImU32 *ImBitArrayPtr;
pub type ImBitArrayPtr = &u32

pub struct C.ImBitVector {
pub:
	storage C.ImVector_ImU32
}

pub type ImBitVector = C.ImBitVector

pub struct C.ImVector_int {
pub:
	size     int
	capacity int
	data     &int
}

pub type ImVector_int = C.ImVector_int

// typedef int ImPoolIdx;
pub type ImPoolIdx = int

pub struct C.ImGuiTextIndex {
pub:
	lineOffsets C.ImVector_int
	endOffset   int
}

pub type ImGuiTextIndex = C.ImGuiTextIndex

pub struct C.ImDrawListSharedData {
pub:
	texUvWhitePixel       C.ImVec2
	font                  &C.ImFont
	fontSize              f32
	fontScale             f32
	curveTessellationTol  f32
	circleSegmentMaxError f32
	clipRectFullscreen    C.ImVec4
	initialFlags          ImDrawListFlags
	tempBuffer            C.ImVector_ImVec2
	arcFastVtx            [48]ImVec2
	arcFastRadiusCutoff   f32
	circleSegmentCounts   [64]ImU8
	texUvLines            &C.ImVec4
}

pub type ImDrawListSharedData = C.ImDrawListSharedData

pub struct C.ImDrawDataBuilder {
pub:
	layers     [2]&C.ImVector_ImDrawListPtr
	layerData1 C.ImVector_ImDrawListPtr
}

pub type ImDrawDataBuilder = C.ImDrawDataBuilder

pub struct C.ImGuiDataVarInfo {
pub:
	type   ImGuiDataType
	count  ImU32
	offset ImU32
}

pub type ImGuiDataVarInfo = C.ImGuiDataVarInfo

pub struct C.ImGuiDataTypeStorage {
pub:
	data [8]ImU8
}

pub type ImGuiDataTypeStorage = C.ImGuiDataTypeStorage

pub struct C.ImGuiDataTypeInfo {
pub:
	size     usize
	name     &i8
	printFmt &i8
	scanFmt  &i8
}

pub type ImGuiDataTypeInfo = C.ImGuiDataTypeInfo

pub enum ImGuiDataTypePrivate_ {
	// im_gui_data_type_string = .im_gui_data_type_count + 1
	im_gui_data_type_pointer
	im_gui_data_type_id
}

pub enum ImGuiItemFlagsPrivate_ {
	im_gui_item_flags_disabled                  = 1 << 10
	im_gui_item_flags_read_only                 = 1 << 11
	im_gui_item_flags_mixed_value               = 1 << 12
	im_gui_item_flags_no_window_hoverable_check = 1 << 13
	im_gui_item_flags_allow_overlap             = 1 << 14
	im_gui_item_flags_inputable                 = 1 << 20
	im_gui_item_flags_has_selection_user_data   = 1 << 21
	im_gui_item_flags_is_multi_select           = 1 << 22
	im_gui_item_flags_default_                  = 1 << 4
}

pub enum ImGuiItemStatusFlags {
	im_gui_item_status_flags_none              = 0
	im_gui_item_status_flags_hovered_rect      = 1 << 0
	im_gui_item_status_flags_has_display_rect  = 1 << 1
	im_gui_item_status_flags_edited            = 1 << 2
	im_gui_item_status_flags_toggled_selection = 1 << 3
	im_gui_item_status_flags_toggled_open      = 1 << 4
	im_gui_item_status_flags_has_deactivated   = 1 << 5
	im_gui_item_status_flags_deactivated       = 1 << 6
	im_gui_item_status_flags_hovered_window    = 1 << 7
	im_gui_item_status_flags_visible           = 1 << 8
	im_gui_item_status_flags_has_clip_rect     = 1 << 9
	im_gui_item_status_flags_has_shortcut      = 1 << 10
}

// pub enum ImGuiHoveredFlagsPrivate_ {
// im_gui_hovered_flags_delay_mask_                        = .im_gui_hovered_flags_delay_none | .im_gui_hovered_flags_delay_short | .im_gui_hovered_flags_delay_normal | .im_gui_hovered_flags_no_shared_delay
// im_gui_hovered_flags_allowed_mask_for_is_window_hovered = .im_gui_hovered_flags_child_windows | .im_gui_hovered_flags_root_window | .im_gui_hovered_flags_any_window | .im_gui_hovered_flags_no_popup_hierarchy | .im_gui_hovered_flags_dock_hierarchy | .im_gui_hovered_flags_allow_when_blocked_by_popup | .im_gui_hovered_flags_allow_when_blocked_by_active_item | .im_gui_hovered_flags_for_tooltip | .im_gui_hovered_flags_stationary
// im_gui_hovered_flags_allowed_mask_for_is_item_hovered   = .im_gui_hovered_flags_allow_when_blocked_by_popup | .im_gui_hovered_flags_allow_when_blocked_by_active_item | .im_gui_hovered_flags_allow_when_overlapped | .im_gui_hovered_flags_allow_when_disabled | .im_gui_hovered_flags_no_nav_override | .im_gui_hovered_flags_for_tooltip | .im_gui_hovered_flags_stationary | .im_gui_hovered_flags_delay_mask_
// }

pub enum ImGuiInputTextFlagsPrivate_ {
	im_gui_input_text_flags_multiline              = 1 << 26
	im_gui_input_text_flags_no_mark_edited         = 1 << 27
	im_gui_input_text_flags_merged_item            = 1 << 28
	im_gui_input_text_flags_localize_decimal_point = 1 << 29
}

pub enum ImGuiButtonFlagsPrivate_ {
	im_gui_button_flags_pressed_on_click                  = 1 << 4
	im_gui_button_flags_pressed_on_click_release          = 1 << 5
	im_gui_button_flags_pressed_on_click_release_anywhere = 1 << 6
	im_gui_button_flags_pressed_on_release                = 1 << 7
	im_gui_button_flags_pressed_on_double_click           = 1 << 8
	im_gui_button_flags_pressed_on_drag_drop_hold         = 1 << 9
	im_gui_button_flags_repeat                            = 1 << 10
	im_gui_button_flags_flatten_children                  = 1 << 11
	im_gui_button_flags_allow_overlap                     = 1 << 12
	im_gui_button_flags_dont_close_popups                 = 1 << 13
	im_gui_button_flags_align_text_base_line              = 1 << 15
	im_gui_button_flags_no_key_modifiers                  = 1 << 16
	im_gui_button_flags_no_holding_active_id              = 1 << 17
	im_gui_button_flags_no_nav_focus                      = 1 << 18
	im_gui_button_flags_no_hovered_on_focus               = 1 << 19
	im_gui_button_flags_no_set_key_owner                  = 1 << 20
	im_gui_button_flags_no_test_key_owner                 = 1 << 21
	// im_gui_button_flags_pressed_on_mask_                  = .im_gui_button_flags_pressed_on_click | .im_gui_button_flags_pressed_on_click_release | .im_gui_button_flags_pressed_on_click_release_anywhere | .im_gui_button_flags_pressed_on_release | .im_gui_button_flags_pressed_on_double_click | .im_gui_button_flags_pressed_on_drag_drop_hold
	im_gui_button_flags_pressed_on_default_ = 1 << 5
}

pub enum ImGuiComboFlagsPrivate_ {
	im_gui_combo_flags_custom_preview = 1 << 20
}

pub enum ImGuiSliderFlagsPrivate_ {
	im_gui_slider_flags_vertical  = 1 << 20
	im_gui_slider_flags_read_only = 1 << 21
}

pub enum ImGuiSelectableFlagsPrivate_ {
	im_gui_selectable_flags_no_holding_active_id     = 1 << 20
	im_gui_selectable_flags_select_on_nav            = 1 << 21
	im_gui_selectable_flags_select_on_click          = 1 << 22
	im_gui_selectable_flags_select_on_release        = 1 << 23
	im_gui_selectable_flags_span_avail_width         = 1 << 24
	im_gui_selectable_flags_set_nav_id_on_hover      = 1 << 25
	im_gui_selectable_flags_no_pad_with_half_spacing = 1 << 26
	im_gui_selectable_flags_no_set_key_owner         = 1 << 27
}

pub enum ImGuiTreeNodeFlagsPrivate_ {
	im_gui_tree_node_flags_clip_label_for_trailing_button = 1 << 28
	im_gui_tree_node_flags_upside_down_arrow              = 1 << 29
	// im_gui_tree_node_flags_open_on_mask_                  = .im_gui_tree_node_flags_open_on_double_click | .im_gui_tree_node_flags_open_on_arrow
}

pub enum ImGuiSeparatorFlags {
	im_gui_separator_flags_none             = 0
	im_gui_separator_flags_horizontal       = 1 << 0
	im_gui_separator_flags_vertical         = 1 << 1
	im_gui_separator_flags_span_all_columns = 1 << 2
}

pub enum ImGuiFocusRequestFlags {
	im_gui_focus_request_flags_none                  = 0
	im_gui_focus_request_flags_restore_focused_child = 1 << 0
	im_gui_focus_request_flags_unless_below_modal    = 1 << 1
}

pub enum ImGuiTextFlags {
	im_gui_text_flags_none                            = 0
	im_gui_text_flags_no_width_for_large_clipped_text = 1 << 0
}

pub enum ImGuiTooltipFlags {
	im_gui_tooltip_flags_none              = 0
	im_gui_tooltip_flags_override_previous = 1 << 1
}

pub enum ImGuiLayoutType_ {
	im_gui_layout_type_horizontal = 0
	im_gui_layout_type_vertical   = 1
}

pub enum ImGuiLogType {
	im_gui_log_type_none = 0
	im_gui_log_type_tty
	im_gui_log_type_file
	im_gui_log_type_buffer
	im_gui_log_type_clipboard
}

pub enum ImGuiAxis {
	im_gui_axis_none = -1
	im_gui_axis_x    = 0
	im_gui_axis_y    = 1
}

pub enum ImGuiPlotType {
	im_gui_plot_type_lines
	im_gui_plot_type_histogram
}

pub struct C.ImGuiColorMod {
pub:
	col         ImGuiCol
	backupValue C.ImVec4
}

pub type ImGuiColorMod = C.ImGuiColorMod

pub struct C.ImGuiStyleMod {
pub:
	varIdx ImGuiStyleVar
}

pub type ImGuiStyleMod = C.ImGuiStyleMod

pub struct C.ImGuiComboPreviewData {
pub:
	previewRect                  C.ImRect
	backupCursorPos              C.ImVec2
	backupCursorMaxPos           C.ImVec2
	backupCursorPosPrevLine      C.ImVec2
	backupPrevLineTextBaseOffset f32
	backupLayout                 ImGuiLayoutType
}

pub type ImGuiComboPreviewData = C.ImGuiComboPreviewData

pub struct C.ImGuiGroupData {
pub:
	windowID                           ImGuiID
	backupCursorPos                    C.ImVec2
	backupCursorMaxPos                 C.ImVec2
	backupCursorPosPrevLine            C.ImVec2
	backupIndent                       C.ImVec1
	backupGroupOffset                  C.ImVec1
	backupCurrLineSize                 C.ImVec2
	backupCurrLineTextBaseOffset       f32
	backupActiveIdIsAlive              ImGuiID
	backupActiveIdPreviousFrameIsAlive bool
	backupHoveredIdIsAlive             bool
	backupIsSameLine                   bool
	emitItem                           bool
}

pub type ImGuiGroupData = C.ImGuiGroupData

pub struct C.ImGuiMenuColumns {
pub:
	totalWidth     ImU32
	nextTotalWidth ImU32
	spacing        ImU16
	offsetIcon     ImU16
	offsetLabel    ImU16
	offsetShortcut ImU16
	offsetMark     ImU16
	widths         [4]ImU16
}

pub type ImGuiMenuColumns = C.ImGuiMenuColumns

pub struct C.ImGuiInputTextDeactivatedState {
pub:
	iD    ImGuiID
	textA C.ImVector_char
}

pub type ImGuiInputTextDeactivatedState = C.ImGuiInputTextDeactivatedState

pub struct C.ImGuiInputTextState {
pub:
	ctx                  &C.ImGuiContext
	iD                   ImGuiID
	curLenW              int
	curLenA              int
	textW                C.ImVector_ImWchar
	textA                C.ImVector_char
	initialTextA         C.ImVector_char
	textAIsValid         bool
	bufCapacityA         int
	scroll               C.ImVec2
	stb                  STB_TexteditState
	cursorAnim           f32
	cursorFollow         bool
	selectedAllMouseLock bool
	edited               bool
	flags                ImGuiInputTextFlags
	reloadUserBuf        bool
	reloadSelectionStart int
	reloadSelectionEnd   int
}

pub type ImGuiInputTextState = C.ImGuiInputTextState

pub enum ImGuiWindowRefreshFlags {
	im_gui_window_refresh_flags_none                 = 0
	im_gui_window_refresh_flags_try_to_avoid_refresh = 1 << 0
	im_gui_window_refresh_flags_refresh_on_hover     = 1 << 1
	im_gui_window_refresh_flags_refresh_on_focus     = 1 << 2
}

pub enum ImGuiNextWindowDataFlags {
	im_gui_next_window_data_flags_none                = 0
	im_gui_next_window_data_flags_has_pos             = 1 << 0
	im_gui_next_window_data_flags_has_size            = 1 << 1
	im_gui_next_window_data_flags_has_content_size    = 1 << 2
	im_gui_next_window_data_flags_has_collapsed       = 1 << 3
	im_gui_next_window_data_flags_has_size_constraint = 1 << 4
	im_gui_next_window_data_flags_has_focus           = 1 << 5
	im_gui_next_window_data_flags_has_bg_alpha        = 1 << 6
	im_gui_next_window_data_flags_has_scroll          = 1 << 7
	im_gui_next_window_data_flags_has_child_flags     = 1 << 8
	im_gui_next_window_data_flags_has_refresh_policy  = 1 << 9
	im_gui_next_window_data_flags_has_viewport        = 1 << 10
	im_gui_next_window_data_flags_has_dock            = 1 << 11
	im_gui_next_window_data_flags_has_window_class    = 1 << 12
}

pub struct C.ImGuiNextWindowData {
pub:
	flags                ImGuiNextWindowDataFlags
	posCond              ImGuiCond
	sizeCond             ImGuiCond
	collapsedCond        ImGuiCond
	dockCond             ImGuiCond
	posVal               C.ImVec2
	posPivotVal          C.ImVec2
	sizeVal              C.ImVec2
	contentSizeVal       C.ImVec2
	scrollVal            C.ImVec2
	childFlags           ImGuiChildFlags
	posUndock            bool
	collapsedVal         bool
	sizeConstraintRect   C.ImRect
	sizeCallback         ImGuiSizeCallback
	sizeCallbackUserData voidptr
	bgAlphaVal           f32
	viewportId           ImGuiID
	dockId               ImGuiID
	windowClass          C.ImGuiWindowClass
	menuBarOffsetMinVal  C.ImVec2
	refreshFlagsVal      ImGuiWindowRefreshFlags
}

pub type ImGuiNextWindowData = C.ImGuiNextWindowData

pub enum ImGuiNextItemDataFlags {
	im_gui_next_item_data_flags_none           = 0
	im_gui_next_item_data_flags_has_width      = 1 << 0
	im_gui_next_item_data_flags_has_open       = 1 << 1
	im_gui_next_item_data_flags_has_shortcut   = 1 << 2
	im_gui_next_item_data_flags_has_ref_val    = 1 << 3
	im_gui_next_item_data_flags_has_storage_id = 1 << 4
}

pub struct C.ImGuiNextItemData {
pub:
	flags             ImGuiNextItemDataFlags
	itemFlags         ImGuiItemFlags
	focusScopeId      ImGuiID
	selectionUserData ImGuiSelectionUserData
	width             f32
	shortcut          ImGuiKeyChord
	shortcutFlags     ImGuiInputFlags
	openVal           bool
	openCond          ImU8
	refVal            C.ImGuiDataTypeStorage
	storageId         ImGuiID
}

pub type ImGuiNextItemData = C.ImGuiNextItemData

pub struct C.ImGuiLastItemData {
pub:
	iD          ImGuiID
	inFlags     ImGuiItemFlags
	statusFlags ImGuiItemStatusFlags
	rect        C.ImRect
	navRect     C.ImRect
	displayRect C.ImRect
	clipRect    C.ImRect
	shortcut    ImGuiKeyChord
}

pub type ImGuiLastItemData = C.ImGuiLastItemData

pub struct C.ImGuiTreeNodeStackData {
pub:
	iD        ImGuiID
	treeFlags ImGuiTreeNodeFlags
	inFlags   ImGuiItemFlags
	navRect   C.ImRect
}

pub type ImGuiTreeNodeStackData = C.ImGuiTreeNodeStackData

pub struct C.ImGuiStackSizes {
pub:
	sizeOfIDStack         i16
	sizeOfColorStack      i16
	sizeOfStyleVarStack   i16
	sizeOfFontStack       i16
	sizeOfFocusScopeStack i16
	sizeOfGroupStack      i16
	sizeOfItemFlagsStack  i16
	sizeOfBeginPopupStack i16
	sizeOfDisabledStack   i16
}

pub type ImGuiStackSizes = C.ImGuiStackSizes

pub struct C.ImGuiWindowStackData {
pub:
	window                   &C.ImGuiWindow
	parentLastItemDataBackup C.ImGuiLastItemData
	stackSizesOnBegin        C.ImGuiStackSizes
	disabledOverrideReenable bool
}

pub type ImGuiWindowStackData = C.ImGuiWindowStackData

pub struct C.ImGuiShrinkWidthItem {
pub:
	index        int
	width        f32
	initialWidth f32
}

pub type ImGuiShrinkWidthItem = C.ImGuiShrinkWidthItem

pub struct C.ImGuiPtrOrIndex {
pub:
	ptr   voidptr
	index int
}

pub type ImGuiPtrOrIndex = C.ImGuiPtrOrIndex

pub enum ImGuiPopupPositionPolicy {
	im_gui_popup_position_policy_default
	im_gui_popup_position_policy_combo_box
	im_gui_popup_position_policy_tooltip
}

pub struct C.ImGuiPopupData {
pub:
	popupId          ImGuiID
	window           &C.ImGuiWindow
	restoreNavWindow &C.ImGuiWindow
	parentNavLayer   int
	openFrameCount   int
	openParentId     ImGuiID
	openPopupPos     C.ImVec2
	openMousePos     C.ImVec2
}

pub type ImGuiPopupData = C.ImGuiPopupData

pub struct C.ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN {
pub:
	storage [5]ImU32
}

pub type ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN = C.ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN

pub type ImBitArrayForNamedKeys = C.ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN

pub enum ImGuiInputEventType {
	im_gui_input_event_type_none = 0
	im_gui_input_event_type_mouse_pos
	im_gui_input_event_type_mouse_wheel
	im_gui_input_event_type_mouse_button
	im_gui_input_event_type_mouse_viewport
	im_gui_input_event_type_key
	im_gui_input_event_type_text
	im_gui_input_event_type_focus
	im_gui_input_event_type_count
}

pub enum ImGuiInputSource {
	im_gui_input_source_none = 0
	im_gui_input_source_mouse
	im_gui_input_source_keyboard
	im_gui_input_source_gamepad
	im_gui_input_source_count
}

pub struct C.ImGuiInputEventMousePos {
pub:
	posX        f32
	posY        f32
	mouseSource ImGuiMouseSource
}

pub type ImGuiInputEventMousePos = C.ImGuiInputEventMousePos

pub struct C.ImGuiInputEventMouseWheel {
pub:
	wheelX      f32
	wheelY      f32
	mouseSource ImGuiMouseSource
}

pub type ImGuiInputEventMouseWheel = C.ImGuiInputEventMouseWheel

pub struct C.ImGuiInputEventMouseButton {
pub:
	button      int
	down        bool
	mouseSource ImGuiMouseSource
}

pub type ImGuiInputEventMouseButton = C.ImGuiInputEventMouseButton

pub struct C.ImGuiInputEventMouseViewport {
pub:
	hoveredViewportID ImGuiID
}

pub type ImGuiInputEventMouseViewport = C.ImGuiInputEventMouseViewport

pub struct C.ImGuiInputEventKey {
pub:
	key         ImGuiKey
	down        bool
	analogValue f32
}

pub type ImGuiInputEventKey = C.ImGuiInputEventKey

pub struct C.ImGuiInputEventText {
pub:
	char u32
}

pub type ImGuiInputEventText = C.ImGuiInputEventText

pub struct C.ImGuiInputEventAppFocused {
pub:
	focused bool
}

pub type ImGuiInputEventAppFocused = C.ImGuiInputEventAppFocused

pub struct C.ImGuiInputEvent {
pub:
	type              ImGuiInputEventType
	source            ImGuiInputSource
	eventId           ImU32
	addedByTestEngine bool
}

pub type ImGuiInputEvent = C.ImGuiInputEvent

// typedef ImS16 ImGuiKeyRoutingIndex;
pub type ImGuiKeyRoutingIndex = i16

pub struct C.ImGuiKeyRoutingData {
pub:
	nextEntryIndex   ImGuiKeyRoutingIndex
	mods             ImU16
	routingCurrScore ImU8
	routingNextScore ImU8
	routingCurr      ImGuiID
	routingNext      ImGuiID
}

pub type ImGuiKeyRoutingData = C.ImGuiKeyRoutingData

pub struct C.ImVector_ImGuiKeyRoutingData {
pub:
	size     int
	capacity int
	data     &C.ImGuiKeyRoutingData
}

pub type ImVector_ImGuiKeyRoutingData = C.ImVector_ImGuiKeyRoutingData

pub struct C.ImGuiKeyRoutingTable {
pub:
	index       [154]ImGuiKeyRoutingIndex
	entries     C.ImVector_ImGuiKeyRoutingData
	entriesNext C.ImVector_ImGuiKeyRoutingData
}

pub type ImGuiKeyRoutingTable = C.ImGuiKeyRoutingTable

pub struct C.ImGuiKeyOwnerData {
pub:
	ownerCurr        ImGuiID
	ownerNext        ImGuiID
	lockThisFrame    bool
	lockUntilRelease bool
}

pub type ImGuiKeyOwnerData = C.ImGuiKeyOwnerData

pub enum ImGuiInputFlagsPrivate_ {
	im_gui_input_flags_repeat_rate_default                    = 1 << 1
	im_gui_input_flags_repeat_rate_nav_move                   = 1 << 2
	im_gui_input_flags_repeat_rate_nav_tweak                  = 1 << 3
	im_gui_input_flags_repeat_until_release                   = 1 << 4
	im_gui_input_flags_repeat_until_key_mods_change           = 1 << 5
	im_gui_input_flags_repeat_until_key_mods_change_from_none = 1 << 6
	im_gui_input_flags_repeat_until_other_key_press           = 1 << 7
	im_gui_input_flags_lock_this_frame                        = 1 << 20
	im_gui_input_flags_lock_until_release                     = 1 << 21
	im_gui_input_flags_cond_hovered                           = 1 << 22
	im_gui_input_flags_cond_active                            = 1 << 23
	// im_gui_input_flags_cond_default_                          = .im_gui_input_flags_cond_hovered | .im_gui_input_flags_cond_active
	// im_gui_input_flags_repeat_rate_mask_                      = .im_gui_input_flags_repeat_rate_default | .im_gui_input_flags_repeat_rate_nav_move | .im_gui_input_flags_repeat_rate_nav_tweak
	// im_gui_input_flags_repeat_until_mask_                     = .im_gui_input_flags_repeat_until_release | .im_gui_input_flags_repeat_until_key_mods_change | .im_gui_input_flags_repeat_until_key_mods_change_from_none | .im_gui_input_flags_repeat_until_other_key_press
	// im_gui_input_flags_repeat_mask_                           = .im_gui_input_flags_repeat | .im_gui_input_flags_repeat_rate_mask_ | .im_gui_input_flags_repeat_until_mask_
	// im_gui_input_flags_cond_mask_                             = .im_gui_input_flags_cond_hovered | .im_gui_input_flags_cond_active
	// im_gui_input_flags_route_type_mask_                       = .im_gui_input_flags_route_active | .im_gui_input_flags_route_focused | .im_gui_input_flags_route_global | .im_gui_input_flags_route_always
	// im_gui_input_flags_route_options_mask_                    = .im_gui_input_flags_route_over_focused | .im_gui_input_flags_route_over_active | .im_gui_input_flags_route_unless_bg_focused | .im_gui_input_flags_route_from_root_window
	// im_gui_input_flags_supported_by_is_key_pressed            = .im_gui_input_flags_repeat_mask_
	// im_gui_input_flags_supported_by_is_mouse_clicked          = .im_gui_input_flags_repeat_mask_
	// im_gui_input_flags_supported_by_shortcut               = .im_gui_input_flags_repeat_mask_ | .im_gui_input_flags_route_type_mask_ | .im_gui_input_flags_route_options_mask_
	// im_gui_input_flags_supported_by_set_next_item_shortcut = .im_gui_input_flags_repeat_mask_ | .im_gui_input_flags_route_type_mask_ | .im_gui_input_flags_route_options_mask_ | .im_gui_input_flags_tooltip
	// im_gui_input_flags_supported_by_set_key_owner          = .im_gui_input_flags_lock_this_frame | .im_gui_input_flags_lock_until_release
	// im_gui_input_flags_supported_by_set_item_key_owner     = .im_gui_input_flags_supported_by_set_key_owner | .im_gui_input_flags_cond_mask_
}

pub struct C.ImGuiListClipperRange {
pub:
	min                 int
	max                 int
	posToIndexConvert   bool
	posToIndexOffsetMin ImS8
	posToIndexOffsetMax ImS8
}

pub type ImGuiListClipperRange = C.ImGuiListClipperRange

pub struct C.ImVector_ImGuiListClipperRange {
pub:
	size     int
	capacity int
	data     &C.ImGuiListClipperRange
}

pub type ImVector_ImGuiListClipperRange = C.ImVector_ImGuiListClipperRange

pub struct C.ImGuiListClipperData {
pub:
	listClipper     &C.ImGuiListClipper
	lossynessOffset f32
	stepNo          int
	itemsFrozen     int
	ranges          C.ImVector_ImGuiListClipperRange
}

pub type ImGuiListClipperData = C.ImGuiListClipperData

pub enum ImGuiActivateFlags {
	im_gui_activate_flags_none                  = 0
	im_gui_activate_flags_prefer_input          = 1 << 0
	im_gui_activate_flags_prefer_tweak          = 1 << 1
	im_gui_activate_flags_try_to_preserve_state = 1 << 2
	im_gui_activate_flags_from_tabbing          = 1 << 3
	im_gui_activate_flags_from_shortcut         = 1 << 4
}

pub enum ImGuiScrollFlags {
	im_gui_scroll_flags_none                  = 0
	im_gui_scroll_flags_keep_visible_edge_x   = 1 << 0
	im_gui_scroll_flags_keep_visible_edge_y   = 1 << 1
	im_gui_scroll_flags_keep_visible_center_x = 1 << 2
	im_gui_scroll_flags_keep_visible_center_y = 1 << 3
	im_gui_scroll_flags_always_center_x       = 1 << 4
	im_gui_scroll_flags_always_center_y       = 1 << 5
	im_gui_scroll_flags_no_scroll_parent      = 1 << 6
	// im_gui_scroll_flags_mask_x_               = .im_gui_scroll_flags_keep_visible_edge_x | .im_gui_scroll_flags_keep_visible_center_x | .im_gui_scroll_flags_always_center_x
	// im_gui_scroll_flags_mask_y_               = .im_gui_scroll_flags_keep_visible_edge_y | .im_gui_scroll_flags_keep_visible_center_y | .im_gui_scroll_flags_always_center_y
}

pub enum ImGuiNavHighlightFlags {
	im_gui_nav_highlight_flags_none        = 0
	im_gui_nav_highlight_flags_compact     = 1 << 1
	im_gui_nav_highlight_flags_always_draw = 1 << 2
	im_gui_nav_highlight_flags_no_rounding = 1 << 3
}

pub enum ImGuiNavMoveFlags {
	im_gui_nav_move_flags_none   = 0
	im_gui_nav_move_flags_loop_x = 1 << 0
	im_gui_nav_move_flags_loop_y = 1 << 1
	im_gui_nav_move_flags_wrap_x = 1 << 2
	im_gui_nav_move_flags_wrap_y = 1 << 3
	// im_gui_nav_move_flags_wrap_mask_             = .im_gui_nav_move_flags_loop_x | .im_gui_nav_move_flags_loop_y | .im_gui_nav_move_flags_wrap_x | .im_gui_nav_move_flags_wrap_y
	im_gui_nav_move_flags_allow_current_nav_id   = 1 << 4
	im_gui_nav_move_flags_also_score_visible_set = 1 << 5
	im_gui_nav_move_flags_scroll_to_edge_y       = 1 << 6
	im_gui_nav_move_flags_forwarded              = 1 << 7
	im_gui_nav_move_flags_debug_no_result        = 1 << 8
	im_gui_nav_move_flags_focus_api              = 1 << 9
	im_gui_nav_move_flags_is_tabbing             = 1 << 10
	im_gui_nav_move_flags_is_page_move           = 1 << 11
	im_gui_nav_move_flags_activate               = 1 << 12
	im_gui_nav_move_flags_no_select              = 1 << 13
	im_gui_nav_move_flags_no_set_nav_highlight   = 1 << 14
	im_gui_nav_move_flags_no_clear_active_id     = 1 << 15
}

pub enum ImGuiNavLayer {
	im_gui_nav_layer_main = 0
	im_gui_nav_layer_menu = 1
	im_gui_nav_layer_count
}

pub struct C.ImGuiNavItemData {
pub:
	window            &C.ImGuiWindow
	iD                ImGuiID
	focusScopeId      ImGuiID
	rectRel           C.ImRect
	inFlags           ImGuiItemFlags
	distBox           f32
	distCenter        f32
	distAxial         f32
	selectionUserData ImGuiSelectionUserData
}

pub type ImGuiNavItemData = C.ImGuiNavItemData

pub struct C.ImGuiFocusScopeData {
pub:
	iD       ImGuiID
	windowID ImGuiID
}

pub type ImGuiFocusScopeData = C.ImGuiFocusScopeData

pub enum ImGuiTypingSelectFlags {
	im_gui_typing_select_flags_none                   = 0
	im_gui_typing_select_flags_allow_backspace        = 1 << 0
	im_gui_typing_select_flags_allow_single_char_mode = 1 << 1
}

pub struct C.ImGuiTypingSelectRequest {
pub:
	flags           ImGuiTypingSelectFlags
	searchBufferLen int
	searchBuffer    &i8
	selectRequest   bool
	singleCharMode  bool
	singleCharSize  ImS8
}

pub type ImGuiTypingSelectRequest = C.ImGuiTypingSelectRequest

pub struct C.ImGuiTypingSelectState {
pub:
	request            C.ImGuiTypingSelectRequest
	searchBuffer       [64]i8
	focusScope         ImGuiID
	lastRequestFrame   int
	lastRequestTime    f32
	singleCharModeLock bool
}

pub type ImGuiTypingSelectState = C.ImGuiTypingSelectState

pub enum ImGuiOldColumnFlags {
	im_gui_old_column_flags_none                      = 0
	im_gui_old_column_flags_no_border                 = 1 << 0
	im_gui_old_column_flags_no_resize                 = 1 << 1
	im_gui_old_column_flags_no_preserve_widths        = 1 << 2
	im_gui_old_column_flags_no_force_within_window    = 1 << 3
	im_gui_old_column_flags_grow_parent_contents_size = 1 << 4
}

pub struct C.ImGuiOldColumnData {
pub:
	offsetNorm             f32
	offsetNormBeforeResize f32
	flags                  ImGuiOldColumnFlags
	clipRect               C.ImRect
}

pub type ImGuiOldColumnData = C.ImGuiOldColumnData

pub struct C.ImVector_ImGuiOldColumnData {
pub:
	size     int
	capacity int
	data     &C.ImGuiOldColumnData
}

pub type ImVector_ImGuiOldColumnData = C.ImVector_ImGuiOldColumnData

pub struct C.ImGuiOldColumns {
pub:
	iD                       ImGuiID
	flags                    ImGuiOldColumnFlags
	isFirstFrame             bool
	isBeingResized           bool
	current                  int
	count                    int
	offMinX                  f32
	offMaxX                  f32
	lineMinY                 f32
	lineMaxY                 f32
	hostCursorPosY           f32
	hostCursorMaxPosX        f32
	hostInitialClipRect      C.ImRect
	hostBackupClipRect       C.ImRect
	hostBackupParentWorkRect C.ImRect
	columns                  C.ImVector_ImGuiOldColumnData
	splitter                 C.ImDrawListSplitter
}

pub type ImGuiOldColumns = C.ImGuiOldColumns

pub struct C.ImGuiBoxSelectState {
pub:
	iD                    ImGuiID
	isActive              bool
	isStarting            bool
	isStartedFromVoid     bool
	isStartedSetNavIdOnce bool
	requestClear          bool
	keyMods               ImGuiKeyChord
	startPosRel           C.ImVec2
	endPosRel             C.ImVec2
	scrollAccum           C.ImVec2
	window                &C.ImGuiWindow
	unclipMode            bool
	unclipRect            C.ImRect
	boxSelectRectPrev     C.ImRect
	boxSelectRectCurr     C.ImRect
}

pub type ImGuiBoxSelectState = C.ImGuiBoxSelectState

pub struct C.ImGuiMultiSelectTempData {
pub:
	iO                 C.ImGuiMultiSelectIO
	storage            &C.ImGuiMultiSelectState
	focusScopeId       ImGuiID
	flags              ImGuiMultiSelectFlags
	scopeRectMin       C.ImVec2
	backupCursorMaxPos C.ImVec2
	lastSubmittedItem  ImGuiSelectionUserData
	boxSelectId        ImGuiID
	keyMods            ImGuiKeyChord
	loopRequestSetAll  ImS8
	isEndIO            bool
	isFocused          bool
	isKeyboardSetRange bool
	navIdPassedBy      bool
	rangeSrcPassedBy   bool
	rangeDstPassedBy   bool
}

pub type ImGuiMultiSelectTempData = C.ImGuiMultiSelectTempData

pub struct C.ImGuiMultiSelectState {
pub:
	window            &C.ImGuiWindow
	iD                ImGuiID
	lastFrameActive   int
	lastSelectionSize int
	rangeSelected     ImS8
	navIdSelected     ImS8
	rangeSrcItem      ImGuiSelectionUserData
	navIdItem         ImGuiSelectionUserData
}

pub type ImGuiMultiSelectState = C.ImGuiMultiSelectState

pub enum ImGuiDockNodeFlagsPrivate_ {
	im_gui_dock_node_flags_dock_space                    = 1 << 10
	im_gui_dock_node_flags_central_node                  = 1 << 11
	im_gui_dock_node_flags_no_tab_bar                    = 1 << 12
	im_gui_dock_node_flags_hidden_tab_bar                = 1 << 13
	im_gui_dock_node_flags_no_window_menu_button         = 1 << 14
	im_gui_dock_node_flags_no_close_button               = 1 << 15
	im_gui_dock_node_flags_no_resize_x                   = 1 << 16
	im_gui_dock_node_flags_no_resize_y                   = 1 << 17
	im_gui_dock_node_flags_docked_windows_in_focus_route = 1 << 18
	im_gui_dock_node_flags_no_docking_split_other        = 1 << 19
	im_gui_dock_node_flags_no_docking_over_me            = 1 << 20
	im_gui_dock_node_flags_no_docking_over_other         = 1 << 21
	im_gui_dock_node_flags_no_docking_over_empty         = 1 << 22
	// im_gui_dock_node_flags_no_docking                    = .im_gui_dock_node_flags_no_docking_over_me | .im_gui_dock_node_flags_no_docking_over_other | .im_gui_dock_node_flags_no_docking_over_empty | .im_gui_dock_node_flags_no_docking_split | .im_gui_dock_node_flags_no_docking_split_other
	// im_gui_dock_node_flags_shared_flags_inherit_mask_    = ~0
	// im_gui_dock_node_flags_no_resize_flags_mask_      = .im_gui_dock_node_flags_no_resize | .im_gui_dock_node_flags_no_resize_x | .im_gui_dock_node_flags_no_resize_y
	// im_gui_dock_node_flags_local_flags_transfer_mask_ = .im_gui_dock_node_flags_no_docking_split | .im_gui_dock_node_flags_no_resize_flags_mask_ | .im_gui_dock_node_flags_auto_hide_tab_bar | .im_gui_dock_node_flags_central_node | .im_gui_dock_node_flags_no_tab_bar | .im_gui_dock_node_flags_hidden_tab_bar | .im_gui_dock_node_flags_no_window_menu_button | .im_gui_dock_node_flags_no_close_button
	// im_gui_dock_node_flags_saved_flags_mask_          = .im_gui_dock_node_flags_no_resize_flags_mask_ | .im_gui_dock_node_flags_dock_space | .im_gui_dock_node_flags_central_node | .im_gui_dock_node_flags_no_tab_bar | .im_gui_dock_node_flags_hidden_tab_bar | .im_gui_dock_node_flags_no_window_menu_button | .im_gui_dock_node_flags_no_close_button
}

pub enum ImGuiDataAuthority_ {
	im_gui_data_authority_auto
	im_gui_data_authority_dock_node
	im_gui_data_authority_window
}

pub enum ImGuiDockNodeState {
	im_gui_dock_node_state_unknown
	im_gui_dock_node_state_host_window_hidden_because_single_window
	im_gui_dock_node_state_host_window_hidden_because_windows_are_resizing
	im_gui_dock_node_state_host_window_visible
}

pub struct C.ImVector_ImGuiWindowPtr {
pub:
	size     int
	capacity int
	data     &&C.ImGuiWindow
}

pub type ImVector_ImGuiWindowPtr = C.ImVector_ImGuiWindowPtr

pub struct C.ImGuiDockNode {
pub:
	iD                     ImGuiID
	sharedFlags            ImGuiDockNodeFlags
	localFlags             ImGuiDockNodeFlags
	localFlagsInWindows    ImGuiDockNodeFlags
	mergedFlags            ImGuiDockNodeFlags
	state                  ImGuiDockNodeState
	parentNode             &C.ImGuiDockNode
	childNodes             [2]&C.ImGuiDockNode
	windows                C.ImVector_ImGuiWindowPtr
	tabBar                 &C.ImGuiTabBar
	pos                    C.ImVec2
	size                   C.ImVec2
	sizeRef                C.ImVec2
	splitAxis              ImGuiAxis
	windowClass            C.ImGuiWindowClass
	lastBgColor            ImU32
	hostWindow             &C.ImGuiWindow
	visibleWindow          &C.ImGuiWindow
	centralNode            &C.ImGuiDockNode
	onlyNodeWithWindows    &C.ImGuiDockNode
	countNodeWithWindows   int
	lastFrameAlive         int
	lastFrameActive        int
	lastFrameFocused       int
	lastFocusedNodeId      ImGuiID
	selectedTabId          ImGuiID
	wantCloseTabId         ImGuiID
	refViewportId          ImGuiID
	authorityForPos        ImGuiDataAuthority
	authorityForSize       ImGuiDataAuthority
	authorityForViewport   ImGuiDataAuthority
	isVisible              bool
	isFocused              bool
	isBgDrawnThisFrame     bool
	hasCloseButton         bool
	hasWindowMenuButton    bool
	hasCentralNodeChild    bool
	wantCloseAll           bool
	wantLockSizeOnce       bool
	wantMouseMove          bool
	wantHiddenTabBarUpdate bool
	wantHiddenTabBarToggle bool
}

pub type ImGuiDockNode = C.ImGuiDockNode

pub enum ImGuiWindowDockStyleCol {
	im_gui_window_dock_style_col_text
	im_gui_window_dock_style_col_tab_hovered
	im_gui_window_dock_style_col_tab_focused
	im_gui_window_dock_style_col_tab_selected
	im_gui_window_dock_style_col_tab_selected_overline
	im_gui_window_dock_style_col_tab_dimmed
	im_gui_window_dock_style_col_tab_dimmed_selected
	im_gui_window_dock_style_col_tab_dimmed_selected_overline
	im_gui_window_dock_style_col_count
}

pub struct C.ImGuiWindowDockStyle {
pub:
	colors [8]ImU32
}

pub type ImGuiWindowDockStyle = C.ImGuiWindowDockStyle

// pub struct ImVector_ImGuiDockRequest {
// pub:
// 	size     int
// 	capacity int
// 	data     &ImGuiDockRequest
// }

pub struct C.ImVector_ImGuiDockNodeSettings {
pub:
	size     int
	capacity int
	// data     &ImGuiDockNodeSettings
}

pub type ImVector_ImGuiDockNodeSettings = C.ImVector_ImGuiDockNodeSettings

pub struct C.ImGuiDockContext {
pub:
	nodes C.ImGuiStorage
	// requests        ImVector_ImGuiDockRequest
	nodesSettings   C.ImVector_ImGuiDockNodeSettings
	wantFullRebuild bool
}

pub type ImGuiDockContext = C.ImGuiDockContext

pub struct C.ImGuiViewportP {
pub:
	_ImGuiViewport          C.ImGuiViewport
	window                  &C.ImGuiWindow
	idx                     int
	lastFrameActive         int
	lastFocusedStampCount   int
	lastNameHash            ImGuiID
	lastPos                 C.ImVec2
	alpha                   f32
	lastAlpha               f32
	lastFocusedHadNavWindow bool
	platformMonitor         i16
	bgFgDrawListsLastFrame  [2]int
	bgFgDrawLists           [2]&C.ImDrawList
	drawDataP               C.ImDrawData
	drawDataBuilder         C.ImDrawDataBuilder
	lastPlatformPos         C.ImVec2
	lastPlatformSize        C.ImVec2
	lastRendererSize        C.ImVec2
	workInsetMin            C.ImVec2
	workInsetMax            C.ImVec2
	buildWorkInsetMin       C.ImVec2
	buildWorkInsetMax       C.ImVec2
}

pub type ImGuiViewportP = C.ImGuiViewportP

pub struct C.ImGuiWindowSettings {
pub:
	iD          ImGuiID
	pos         C.ImVec2ih
	size        C.ImVec2ih
	viewportPos C.ImVec2ih
	viewportId  ImGuiID
	dockId      ImGuiID
	classId     ImGuiID
	dockOrder   i16
	collapsed   bool
	isChild     bool
	wantApply   bool
	wantDelete  bool
}

pub type ImGuiWindowSettings = C.ImGuiWindowSettings

pub struct C.ImGuiSettingsHandler {
pub:
	typeName   &i8
	typeHash   ImGuiID
	clearAllFn fn (&C.ImGuiContext, &C.ImGuiSettingsHandler)
	readInitFn fn (&C.ImGuiContext, &C.ImGuiSettingsHandler)
	readOpenFn fn (&C.ImGuiContext, &C.ImGuiSettingsHandler, &i8) voidptr
	readLineFn fn (&C.ImGuiContext, &C.ImGuiSettingsHandler, voidptr, &i8)
	applyAllFn fn (&C.ImGuiContext, &C.ImGuiSettingsHandler)
	writeAllFn fn (&C.ImGuiContext, &C.ImGuiSettingsHandler, &C.ImGuiTextBuffer)
	userData   voidptr
}

pub type ImGuiSettingsHandler = C.ImGuiSettingsHandler

pub enum ImGuiLocKey {
	im_gui_loc_key_version_str                         = 0
	im_gui_loc_key_table_size_one                      = 1
	im_gui_loc_key_table_size_all_fit                  = 2
	im_gui_loc_key_table_size_all_default              = 3
	im_gui_loc_key_table_reset_order                   = 4
	im_gui_loc_key_windowing_main_menu_bar             = 5
	im_gui_loc_key_windowing_popup                     = 6
	im_gui_loc_key_windowing_untitled                  = 7
	im_gui_loc_key_copy_link                           = 8
	im_gui_loc_key_docking_hide_tab_bar                = 9
	im_gui_loc_key_docking_hold_shift_to_dock          = 10
	im_gui_loc_key_docking_drag_to_undock_or_move_node = 11
	im_gui_loc_key_count                               = 12
}

pub struct C.ImGuiLocEntry {
pub:
	key  ImGuiLocKey
	text &i8
}

pub type ImGuiLocEntry = C.ImGuiLocEntry

pub enum ImGuiDebugLogFlags {
	im_gui_debug_log_flags_none                = 0
	im_gui_debug_log_flags_event_active_id     = 1 << 0
	im_gui_debug_log_flags_event_focus         = 1 << 1
	im_gui_debug_log_flags_event_popup         = 1 << 2
	im_gui_debug_log_flags_event_nav           = 1 << 3
	im_gui_debug_log_flags_event_clipper       = 1 << 4
	im_gui_debug_log_flags_event_selection     = 1 << 5
	im_gui_debug_log_flags_event_io            = 1 << 6
	im_gui_debug_log_flags_event_input_routing = 1 << 7
	im_gui_debug_log_flags_event_docking       = 1 << 8
	im_gui_debug_log_flags_event_viewport      = 1 << 9
	// im_gui_debug_log_flags_event_mask_           = .im_gui_debug_log_flags_event_active_id | .im_gui_debug_log_flags_event_focus | .im_gui_debug_log_flags_event_popup | .im_gui_debug_log_flags_event_nav | .im_gui_debug_log_flags_event_clipper | .im_gui_debug_log_flags_event_selection | .im_gui_debug_log_flags_event_io | .im_gui_debug_log_flags_event_input_routing | .im_gui_debug_log_flags_event_docking | .im_gui_debug_log_flags_event_viewport
	im_gui_debug_log_flags_output_to_tty         = 1 << 20
	im_gui_debug_log_flags_output_to_test_engine = 1 << 21
}

pub struct C.ImGuiDebugAllocEntry {
pub:
	frameCount int
	allocCount ImS16
	freeCount  ImS16
}

pub type ImGuiDebugAllocEntry = C.ImGuiDebugAllocEntry

pub struct C.ImGuiDebugAllocInfo {
pub:
	totalAllocCount int
	totalFreeCount  int
	lastEntriesIdx  ImS16
	lastEntriesBuf  [6]ImGuiDebugAllocEntry
}

pub type ImGuiDebugAllocInfo = C.ImGuiDebugAllocInfo

pub struct C.ImGuiMetricsConfig {
pub:
	showDebugLog                 bool
	showIDStackTool              bool
	showWindowsRects             bool
	showWindowsBeginOrder        bool
	showTablesRects              bool
	showDrawCmdMesh              bool
	showDrawCmdBoundingBoxes     bool
	showTextEncodingViewer       bool
	showAtlasTintedWithTextColor bool
	showDockingNodes             bool
	showWindowsRectsType         int
	showTablesRectsType          int
	highlightMonitorIdx          int
	highlightViewportID          ImGuiID
}

pub type ImGuiMetricsConfig = C.ImGuiMetricsConfig

pub struct C.ImGuiStackLevelInfo {
pub:
	iD              ImGuiID
	queryFrameCount ImS8
	querySuccess    bool
	dataType        ImGuiDataType
	desc            [57]i8
}

pub type ImGuiStackLevelInfo = C.ImGuiStackLevelInfo

pub struct C.ImVector_ImGuiStackLevelInfo {
pub:
	size     int
	capacity int
	data     &C.ImGuiStackLevelInfo
}

pub type ImVector_ImGuiStackLevelInfo = C.ImVector_ImGuiStackLevelInfo

pub struct C.ImGuiIDStackTool {
pub:
	lastActiveFrame         int
	stackLevel              int
	queryId                 ImGuiID
	results                 C.ImVector_ImGuiStackLevelInfo
	copyToClipboardOnCtrlC  bool
	copyToClipboardLastTime f32
}

pub type ImGuiIDStackTool = C.ImGuiIDStackTool

// typedef void (*ImGuiContextHookCallback)(ImGuiContext *ctx, C.ImGuiContextHook *hook);
pub type ImGuiContextHookCallback = fn (&C.ImGuiContext, &C.ImGuiContextHook)

pub enum ImGuiContextHookType {
	im_gui_context_hook_type_new_frame_pre
	im_gui_context_hook_type_new_frame_post
	im_gui_context_hook_type_end_frame_pre
	im_gui_context_hook_type_end_frame_post
	im_gui_context_hook_type_render_pre
	im_gui_context_hook_type_render_post
	im_gui_context_hook_type_shutdown
	im_gui_context_hook_type_pending_removal_
}

pub struct C.ImGuiContextHook {
pub:
	hookId   ImGuiID
	type     ImGuiContextHookType
	owner    ImGuiID
	callback ImGuiContextHookCallback
	userData voidptr
}

pub type ImGuiContextHook = C.ImGuiContextHook

pub struct C.ImVector_ImGuiInputEvent {
pub:
	size     int
	capacity int
	data     &C.ImGuiInputEvent
}

pub type ImVector_ImGuiInputEvent = C.ImVector_ImGuiInputEvent

pub struct C.ImVector_ImGuiWindowStackData {
pub:
	size     int
	capacity int
	data     &C.ImGuiWindowStackData
}

pub type ImVector_ImGuiWindowStackData = C.ImVector_ImGuiWindowStackData

pub struct C.ImVector_ImGuiColorMod {
pub:
	size     int
	capacity int
	data     &C.ImGuiColorMod
}

pub type ImVector_ImGuiColorMod = C.ImVector_ImGuiColorMod

pub struct C.ImVector_ImGuiStyleMod {
pub:
	size     int
	capacity int
	data     &C.ImGuiStyleMod
}

pub type ImVector_ImGuiStyleMod = C.ImVector_ImGuiStyleMod

pub struct C.ImVector_ImGuiFocusScopeData {
pub:
	size     int
	capacity int
	data     &C.ImGuiFocusScopeData
}

pub type ImVector_ImGuiFocusScopeData = C.ImVector_ImGuiFocusScopeData

pub struct C.ImVector_ImGuiItemFlags {
pub:
	size     int
	capacity int
	data     &ImGuiItemFlags
}

pub type ImVector_ImGuiItemFlags = C.ImVector_ImGuiItemFlags

pub struct C.ImVector_ImGuiGroupData {
pub:
	size     int
	capacity int
	data     &C.ImGuiGroupData
}

pub type ImVector_ImGuiGroupData = C.ImVector_ImGuiGroupData

pub struct C.ImVector_ImGuiPopupData {
pub:
	size     int
	capacity int
	data     &C.ImGuiPopupData
}

pub type ImVector_ImGuiPopupData = C.ImVector_ImGuiPopupData

pub struct C.ImVector_ImGuiTreeNodeStackData {
pub:
	size     int
	capacity int
	data     &C.ImGuiTreeNodeStackData
}

pub type ImVector_ImGuiTreeNodeStackData = C.ImVector_ImGuiTreeNodeStackData

pub struct C.ImVector_ImGuiViewportPPtr {
pub:
	size     int
	capacity int
	data     &&C.ImGuiViewportP
}

pub type ImVector_ImGuiViewportPPtr = C.ImVector_ImGuiViewportPPtr

pub struct C.ImVector_unsigned_char {
pub:
	size     int
	capacity int
	data     &u8
}

pub type ImVector_unsigned_char = C.ImVector_unsigned_char

pub struct C.ImVector_ImGuiListClipperData {
pub:
	size     int
	capacity int
	data     &C.ImGuiListClipperData
}

pub type ImVector_ImGuiListClipperData = C.ImVector_ImGuiListClipperData

pub struct C.ImVector_ImGuiTableTempData {
pub:
	size     int
	capacity int
	data     &C.ImGuiTableTempData
}

pub type ImVector_ImGuiTableTempData = C.ImVector_ImGuiTableTempData

pub struct C.ImVector_ImGuiTable {
pub:
	size     int
	capacity int
	data     &C.ImGuiTable
}

pub type ImVector_ImGuiTable = C.ImVector_ImGuiTable

pub struct C.ImPool_ImGuiTable {
pub:
	buf        C.ImVector_ImGuiTable
	map        C.ImGuiStorage
	freeIdx    ImPoolIdx
	aliveCount ImPoolIdx
}

pub type ImPool_ImGuiTable = C.ImPool_ImGuiTable

pub struct C.ImVector_ImGuiTabBar {
pub:
	size     int
	capacity int
	data     &C.ImGuiTabBar
}

pub type ImVector_ImGuiTabBar = C.ImVector_ImGuiTabBar

pub struct C.ImPool_ImGuiTabBar {
pub:
	buf        C.ImVector_ImGuiTabBar
	map        C.ImGuiStorage
	freeIdx    ImPoolIdx
	aliveCount ImPoolIdx
}

pub type ImPool_ImGuiTabBar = C.ImPool_ImGuiTabBar

pub struct C.ImVector_ImGuiPtrOrIndex {
pub:
	size     int
	capacity int
	data     &C.ImGuiPtrOrIndex
}

pub type ImVector_ImGuiPtrOrIndex = C.ImVector_ImGuiPtrOrIndex

pub struct C.ImVector_ImGuiShrinkWidthItem {
pub:
	size     int
	capacity int
	data     &C.ImGuiShrinkWidthItem
}

pub type ImVector_ImGuiShrinkWidthItem = C.ImVector_ImGuiShrinkWidthItem

pub struct C.ImVector_ImGuiMultiSelectTempData {
pub:
	size     int
	capacity int
	data     &C.ImGuiMultiSelectTempData
}

pub type ImVector_ImGuiMultiSelectTempData = C.ImVector_ImGuiMultiSelectTempData

pub struct C.ImVector_ImGuiMultiSelectState {
pub:
	size     int
	capacity int
	data     &C.ImGuiMultiSelectState
}

pub type ImVector_ImGuiMultiSelectState = C.ImVector_ImGuiMultiSelectState

pub struct C.ImPool_ImGuiMultiSelectState {
pub:
	buf        C.ImVector_ImGuiMultiSelectState
	map        C.ImGuiStorage
	freeIdx    ImPoolIdx
	aliveCount ImPoolIdx
}

pub type ImPool_ImGuiMultiSelectState = C.ImPool_ImGuiMultiSelectState

pub struct C.ImVector_ImGuiID {
pub:
	size     int
	capacity int
	data     &ImGuiID
}

pub type ImVector_ImGuiID = C.ImVector_ImGuiID

pub struct C.ImVector_ImGuiSettingsHandler {
pub:
	size     int
	capacity int
	data     &C.ImGuiSettingsHandler
}

pub type ImVector_ImGuiSettingsHandler = C.ImVector_ImGuiSettingsHandler

pub struct C.ImChunkStream_ImGuiWindowSettings {
pub:
	buf C.ImVector_char
}

pub type ImChunkStream_ImGuiWindowSettings = C.ImChunkStream_ImGuiWindowSettings

pub struct C.ImChunkStream_ImGuiTableSettings {
pub:
	buf C.ImVector_char
}

pub type ImChunkStream_ImGuiTableSettings = C.ImChunkStream_ImGuiTableSettings

pub struct C.ImVector_ImGuiContextHook {
pub:
	size     int
	capacity int
	data     &C.ImGuiContextHook
}

pub type ImVector_ImGuiContextHook = C.ImVector_ImGuiContextHook

pub struct C.ImGuiContext {
pub:
	initialized                              bool
	fontAtlasOwnedByContext                  bool
	iO                                       C.ImGuiIO
	platformIO                               C.ImGuiPlatformIO
	style                                    C.ImGuiStyle
	configFlagsCurrFrame                     ImGuiConfigFlags
	configFlagsLastFrame                     ImGuiConfigFlags
	font                                     &C.ImFont
	fontSize                                 f32
	fontBaseSize                             f32
	fontScale                                f32
	currentDpiScale                          f32
	drawListSharedData                       C.ImDrawListSharedData
	time                                     f64
	frameCount                               int
	frameCountEnded                          int
	frameCountPlatformEnded                  int
	frameCountRendered                       int
	withinFrameScope                         bool
	withinFrameScopeWithImplicitWindow       bool
	withinEndChild                           bool
	gcCompactAll                             bool
	testEngineHookItems                      bool
	testEngine                               voidptr
	contextName                              [16]i8
	inputEventsQueue                         C.ImVector_ImGuiInputEvent
	inputEventsTrail                         C.ImVector_ImGuiInputEvent
	inputEventsNextMouseSource               ImGuiMouseSource
	inputEventsNextEventId                   ImU32
	windows                                  C.ImVector_ImGuiWindowPtr
	windowsFocusOrder                        C.ImVector_ImGuiWindowPtr
	windowsTempSortBuffer                    C.ImVector_ImGuiWindowPtr
	currentWindowStack                       C.ImVector_ImGuiWindowStackData
	windowsById                              C.ImGuiStorage
	windowsActiveCount                       int
	windowsHoverPadding                      C.ImVec2
	debugBreakInWindow                       ImGuiID
	currentWindow                            &C.ImGuiWindow
	hoveredWindow                            &C.ImGuiWindow
	hoveredWindowUnderMovingWindow           &C.ImGuiWindow
	hoveredWindowBeforeClear                 &C.ImGuiWindow
	movingWindow                             &C.ImGuiWindow
	wheelingWindow                           &C.ImGuiWindow
	wheelingWindowRefMousePos                C.ImVec2
	wheelingWindowStartFrame                 int
	wheelingWindowScrolledFrame              int
	wheelingWindowReleaseTimer               f32
	wheelingWindowWheelRemainder             C.ImVec2
	wheelingAxisAvg                          C.ImVec2
	debugHookIdInfo                          ImGuiID
	hoveredId                                ImGuiID
	hoveredIdPreviousFrame                   ImGuiID
	hoveredIdTimer                           f32
	hoveredIdNotActiveTimer                  f32
	hoveredIdAllowOverlap                    bool
	hoveredIdIsDisabled                      bool
	itemUnclipByLog                          bool
	activeId                                 ImGuiID
	activeIdIsAlive                          ImGuiID
	activeIdTimer                            f32
	activeIdIsJustActivated                  bool
	activeIdAllowOverlap                     bool
	activeIdNoClearOnFocusLoss               bool
	activeIdHasBeenPressedBefore             bool
	activeIdHasBeenEditedBefore              bool
	activeIdHasBeenEditedThisFrame           bool
	activeIdFromShortcut                     bool
	activeIdMouseButton                      int
	activeIdClickOffset                      C.ImVec2
	activeIdWindow                           &C.ImGuiWindow
	activeIdSource                           ImGuiInputSource
	activeIdPreviousFrame                    ImGuiID
	activeIdPreviousFrameIsAlive             bool
	activeIdPreviousFrameHasBeenEditedBefore bool
	activeIdPreviousFrameWindow              &C.ImGuiWindow
	lastActiveId                             ImGuiID
	lastActiveIdTimer                        f32
	lastKeyModsChangeTime                    f64
	lastKeyModsChangeFromNoneTime            f64
	lastKeyboardKeyPressTime                 f64
	keysMayBeCharInput                       ImBitArrayForNamedKeys
	keysOwnerData                            [154]ImGuiKeyOwnerData
	keysRoutingTable                         C.ImGuiKeyRoutingTable
	activeIdUsingNavDirMask                  ImU32
	activeIdUsingAllKeyboardKeys             bool
	debugBreakInShortcutRouting              ImGuiKeyChord
	currentFocusScopeId                      ImGuiID
	currentItemFlags                         ImGuiItemFlags
	debugLocateId                            ImGuiID
	nextItemData                             C.ImGuiNextItemData
	lastItemData                             C.ImGuiLastItemData
	nextWindowData                           C.ImGuiNextWindowData
	debugShowGroupRects                      bool
	debugFlashStyleColorIdx                  ImGuiCol
	colorStack                               C.ImVector_ImGuiColorMod
	styleVarStack                            C.ImVector_ImGuiStyleMod
	fontStack                                C.ImVector_ImFontPtr
	focusScopeStack                          C.ImVector_ImGuiFocusScopeData
	itemFlagsStack                           C.ImVector_ImGuiItemFlags
	groupStack                               C.ImVector_ImGuiGroupData
	openPopupStack                           C.ImVector_ImGuiPopupData
	beginPopupStack                          C.ImVector_ImGuiPopupData
	treeNodeStack                            C.ImVector_ImGuiTreeNodeStackData
	viewports                                C.ImVector_ImGuiViewportPPtr
	currentViewport                          &C.ImGuiViewportP
	mouseViewport                            &C.ImGuiViewportP
	mouseLastHoveredViewport                 &C.ImGuiViewportP
	platformLastFocusedViewportId            ImGuiID
	fallbackMonitor                          C.ImGuiPlatformMonitor
	platformMonitorsFullWorkRect             C.ImRect
	viewportCreatedCount                     int
	platformWindowsCreatedCount              int
	viewportFocusedStampCount                int
	navWindow                                &C.ImGuiWindow
	navId                                    ImGuiID
	navFocusScopeId                          ImGuiID
	navLayer                                 ImGuiNavLayer
	navActivateId                            ImGuiID
	navActivateDownId                        ImGuiID
	navActivatePressedId                     ImGuiID
	navActivateFlags                         ImGuiActivateFlags
	navFocusRoute                            C.ImVector_ImGuiFocusScopeData
	navHighlightActivatedId                  ImGuiID
	navHighlightActivatedTimer               f32
	navNextActivateId                        ImGuiID
	navNextActivateFlags                     ImGuiActivateFlags
	navInputSource                           ImGuiInputSource
	navLastValidSelectionUserData            ImGuiSelectionUserData
	navIdIsAlive                             bool
	navMousePosDirty                         bool
	navDisableHighlight                      bool
	navDisableMouseHover                     bool
	navAnyRequest                            bool
	navInitRequest                           bool
	navInitRequestFromMove                   bool
	navInitResult                            C.ImGuiNavItemData
	navMoveSubmitted                         bool
	navMoveScoringItems                      bool
	navMoveForwardToNextFrame                bool
	navMoveFlags                             ImGuiNavMoveFlags
	navMoveScrollFlags                       ImGuiScrollFlags
	navMoveKeyMods                           ImGuiKeyChord
	navMoveDir                               ImGuiDir
	navMoveDirForDebug                       ImGuiDir
	navMoveClipDir                           ImGuiDir
	navScoringRect                           C.ImRect
	navScoringNoClipRect                     C.ImRect
	navScoringDebugCount                     int
	navTabbingDir                            int
	navTabbingCounter                        int
	navMoveResultLocal                       C.ImGuiNavItemData
	navMoveResultLocalVisible                C.ImGuiNavItemData
	navMoveResultOther                       C.ImGuiNavItemData
	navTabbingResultFirst                    C.ImGuiNavItemData
	navJustMovedFromFocusScopeId             ImGuiID
	navJustMovedToId                         ImGuiID
	navJustMovedToFocusScopeId               ImGuiID
	navJustMovedToKeyMods                    ImGuiKeyChord
	navJustMovedToIsTabbing                  bool
	navJustMovedToHasSelectionData           bool
	configNavWindowingKeyNext                ImGuiKeyChord
	configNavWindowingKeyPrev                ImGuiKeyChord
	navWindowingTarget                       &C.ImGuiWindow
	navWindowingTargetAnim                   &C.ImGuiWindow
	navWindowingListWindow                   &C.ImGuiWindow
	navWindowingTimer                        f32
	navWindowingHighlightAlpha               f32
	navWindowingToggleLayer                  bool
	navWindowingToggleKey                    ImGuiKey
	navWindowingAccumDeltaPos                C.ImVec2
	navWindowingAccumDeltaSize               C.ImVec2
	dimBgRatio                               f32
	dragDropActive                           bool
	dragDropWithinSource                     bool
	dragDropWithinTarget                     bool
	dragDropSourceFlags                      ImGuiDragDropFlags
	dragDropSourceFrameCount                 int
	dragDropMouseButton                      int
	dragDropPayload                          C.ImGuiPayload
	dragDropTargetRect                       C.ImRect
	dragDropTargetClipRect                   C.ImRect
	dragDropTargetId                         ImGuiID
	dragDropAcceptFlags                      ImGuiDragDropFlags
	dragDropAcceptIdCurrRectSurface          f32
	dragDropAcceptIdCurr                     ImGuiID
	dragDropAcceptIdPrev                     ImGuiID
	dragDropAcceptFrameCount                 int
	dragDropHoldJustPressedId                ImGuiID
	dragDropPayloadBufHeap                   C.ImVector_unsigned_char
	dragDropPayloadBufLocal                  [16]u8
	clipperTempDataStacked                   int
	clipperTempData                          C.ImVector_ImGuiListClipperData
	currentTable                             &C.ImGuiTable
	debugBreakInTable                        ImGuiID
	tablesTempDataStacked                    int
	tablesTempData                           C.ImVector_ImGuiTableTempData
	tables                                   C.ImPool_ImGuiTable
	tablesLastTimeActive                     C.ImVector_float
	drawChannelsTempMergeBuffer              C.ImVector_ImDrawChannel
	currentTabBar                            &C.ImGuiTabBar
	tabBars                                  C.ImPool_ImGuiTabBar
	currentTabBarStack                       C.ImVector_ImGuiPtrOrIndex
	shrinkWidthBuffer                        C.ImVector_ImGuiShrinkWidthItem
	boxSelectState                           C.ImGuiBoxSelectState
	currentMultiSelect                       &C.ImGuiMultiSelectTempData
	multiSelectTempDataStacked               int
	multiSelectTempData                      C.ImVector_ImGuiMultiSelectTempData
	multiSelectStorage                       C.ImPool_ImGuiMultiSelectState
	hoverItemDelayId                         ImGuiID
	hoverItemDelayIdPreviousFrame            ImGuiID
	hoverItemDelayTimer                      f32
	hoverItemDelayClearTimer                 f32
	hoverItemUnlockedStationaryId            ImGuiID
	hoverWindowUnlockedStationaryId          ImGuiID
	mouseCursor                              ImGuiMouseCursor
	mouseStationaryTimer                     f32
	mouseLastValidPos                        C.ImVec2
	inputTextState                           C.ImGuiInputTextState
	inputTextDeactivatedState                C.ImGuiInputTextDeactivatedState
	inputTextPasswordFont                    C.ImFont
	tempInputId                              ImGuiID
	dataTypeZeroValue                        C.ImGuiDataTypeStorage
	beginMenuDepth                           int
	beginComboDepth                          int
	colorEditOptions                         ImGuiColorEditFlags
	colorEditCurrentID                       ImGuiID
	colorEditSavedID                         ImGuiID
	colorEditSavedHue                        f32
	colorEditSavedSat                        f32
	colorEditSavedColor                      ImU32
	colorPickerRef                           C.ImVec4
	comboPreviewData                         C.ImGuiComboPreviewData
	windowResizeBorderExpectedRect           C.ImRect
	windowResizeRelativeMode                 bool
	scrollbarSeekMode                        i16
	scrollbarClickDeltaToGrabCenter          f32
	sliderGrabClickOffset                    f32
	sliderCurrentAccum                       f32
	sliderCurrentAccumDirty                  bool
	dragCurrentAccumDirty                    bool
	dragCurrentAccum                         f32
	dragSpeedDefaultRatio                    f32
	disabledAlphaBackup                      f32
	disabledStackSize                        i16
	lockMarkEdited                           i16
	tooltipOverrideCount                     i16
	clipboardHandlerData                     C.ImVector_char
	menusIdSubmittedThisFrame                C.ImVector_ImGuiID
	typingSelectState                        C.ImGuiTypingSelectState
	platformImeData                          C.ImGuiPlatformImeData
	platformImeDataPrev                      C.ImGuiPlatformImeData
	platformImeViewport                      ImGuiID
	dockContext                              C.ImGuiDockContext
	dockNodeWindowMenuHandler                fn (&C.ImGuiContext, &C.ImGuiDockNode, &C.ImGuiTabBar)
	settingsLoaded                           bool
	settingsDirtyTimer                       f32
	settingsIniData                          C.ImGuiTextBuffer
	settingsHandlers                         C.ImVector_ImGuiSettingsHandler
	settingsWindows                          C.ImChunkStream_ImGuiWindowSettings
	settingsTables                           C.ImChunkStream_ImGuiTableSettings
	hooks                                    C.ImVector_ImGuiContextHook
	hookIdNext                               ImGuiID
	localizationTable                        [12]&i8
	logEnabled                               bool
	logType                                  ImGuiLogType
	logFile                                  C.ImFileHandle
	logBuffer                                C.ImGuiTextBuffer
	logNextPrefix                            &i8
	logNextSuffix                            &i8
	logLinePosY                              f32
	logLineFirstItem                         bool
	logDepthRef                              int
	logDepthToExpand                         int
	logDepthToExpandDefault                  int
	debugLogFlags                            ImGuiDebugLogFlags
	debugLogBuf                              C.ImGuiTextBuffer
	debugLogIndex                            C.ImGuiTextIndex
	debugLogAutoDisableFlags                 ImGuiDebugLogFlags
	debugLogAutoDisableFrames                ImU8
	debugLocateFrames                        ImU8
	debugBreakInLocateId                     bool
	debugBreakKeyChord                       ImGuiKeyChord
	debugBeginReturnValueCullDepth           ImS8
	debugItemPickerActive                    bool
	debugItemPickerMouseButton               ImU8
	debugItemPickerBreakId                   ImGuiID
	debugFlashStyleColorTime                 f32
	debugFlashStyleColorBackup               C.ImVec4
	debugMetricsConfig                       C.ImGuiMetricsConfig
	debugIDStackTool                         C.ImGuiIDStackTool
	debugAllocInfo                           C.ImGuiDebugAllocInfo
	debugHoveredDockNode                     &C.ImGuiDockNode
	framerateSecPerFrame                     [60]f32
	framerateSecPerFrameIdx                  int
	framerateSecPerFrameCount                int
	framerateSecPerFrameAccum                f32
	wantCaptureMouseNextFrame                int
	wantCaptureKeyboardNextFrame             int
	wantTextInputNextFrame                   int
	tempBuffer                               C.ImVector_char
	tempKeychordName                         [64]i8
}

pub type ImGuiContext = C.ImGuiContext

pub struct C.ImGuiWindowTempData {
pub:
	cursorPos                 C.ImVec2
	cursorPosPrevLine         C.ImVec2
	cursorStartPos            C.ImVec2
	cursorMaxPos              C.ImVec2
	idealMaxPos               C.ImVec2
	currLineSize              C.ImVec2
	prevLineSize              C.ImVec2
	currLineTextBaseOffset    f32
	prevLineTextBaseOffset    f32
	isSameLine                bool
	isSetPos                  bool
	indent                    C.ImVec1
	columnsOffset             C.ImVec1
	groupOffset               C.ImVec1
	cursorStartPosLossyness   C.ImVec2
	navLayerCurrent           ImGuiNavLayer
	navLayersActiveMask       i16
	navLayersActiveMaskNext   i16
	navIsScrollPushableX      bool
	navHideHighlightOneFrame  bool
	navWindowHasScrollY       bool
	menuBarAppending          bool
	menuBarOffset             C.ImVec2
	menuColumns               C.ImGuiMenuColumns
	treeDepth                 int
	treeHasStackDataDepthMask ImU32
	childWindows              C.ImVector_ImGuiWindowPtr
	stateStorage              &C.ImGuiStorage
	currentColumns            &C.ImGuiOldColumns
	currentTableIdx           int
	layoutType                ImGuiLayoutType
	parentLayoutType          ImGuiLayoutType
	modalDimBgColor           ImU32
	itemWidth                 f32
	textWrapPos               f32
	itemWidthStack            C.ImVector_float
	textWrapPosStack          C.ImVector_float
}

pub type ImGuiWindowTempData = C.ImGuiWindowTempData

pub struct C.ImVector_ImGuiOldColumns {
pub:
	size     int
	capacity int
	data     &C.ImGuiOldColumns
}

pub type ImVector_ImGuiOldColumns = C.ImVector_ImGuiOldColumns

pub struct C.ImGuiWindow {
pub:
	ctx                                &C.ImGuiContext
	name                               &i8
	iD                                 ImGuiID
	flags                              ImGuiWindowFlags
	flagsPreviousFrame                 ImGuiWindowFlags
	childFlags                         ImGuiChildFlags
	windowClass                        C.ImGuiWindowClass
	viewport                           &C.ImGuiViewportP
	viewportId                         ImGuiID
	viewportPos                        C.ImVec2
	viewportAllowPlatformMonitorExtend int
	Pos                                C.ImVec2 @[c: 'Pos']
	Size                               C.ImVec2 @[c: 'Size']
	sizeFull                           C.ImVec2
	contentSize                        C.ImVec2
	contentSizeIdeal                   C.ImVec2
	contentSizeExplicit                C.ImVec2
	windowPadding                      C.ImVec2
	windowRounding                     f32
	windowBorderSize                   f32
	titleBarHeight                     f32
	menuBarHeight                      f32
	decoOuterSizeX1                    f32
	decoOuterSizeY1                    f32
	decoOuterSizeX2                    f32
	decoOuterSizeY2                    f32
	decoInnerSizeX1                    f32
	decoInnerSizeY1                    f32
	nameBufLen                         int
	moveId                             ImGuiID
	tabId                              ImGuiID
	childId                            ImGuiID
	popupId                            ImGuiID
	scroll                             C.ImVec2
	scrollMax                          C.ImVec2
	scrollTarget                       C.ImVec2
	scrollTargetCenterRatio            C.ImVec2
	scrollTargetEdgeSnapDist           C.ImVec2
	scrollbarSizes                     C.ImVec2
	scrollbarX                         bool
	scrollbarY                         bool
	viewportOwned                      bool
	active                             bool
	wasActive                          bool
	writeAccessed                      bool
	collapsed                          bool
	wantCollapseToggle                 bool
	skipItems                          bool
	skipRefresh                        bool
	appearing                          bool
	hidden                             bool
	isFallbackWindow                   bool
	isExplicitChild                    bool
	hasCloseButton                     bool
	resizeBorderHovered                i8
	resizeBorderHeld                   i8
	beginCount                         i16
	beginCountPreviousFrame            i16
	beginOrderWithinParent             i16
	beginOrderWithinContext            i16
	focusOrder                         i16
	autoFitFramesX                     ImS8
	autoFitFramesY                     ImS8
	autoFitOnlyGrows                   bool
	autoPosLastDirection               ImGuiDir
	hiddenFramesCanSkipItems           ImS8
	hiddenFramesCannotSkipItems        ImS8
	hiddenFramesForRenderOnly          ImS8
	disableInputsFrames                ImS8
	setWindowPosAllowFlags             ImGuiCond
	setWindowSizeAllowFlags            ImGuiCond
	setWindowCollapsedAllowFlags       ImGuiCond
	setWindowDockAllowFlags            ImGuiCond
	setWindowPosVal                    C.ImVec2
	setWindowPosPivot                  C.ImVec2
	iDStack                            C.ImVector_ImGuiID
	dC                                 C.ImGuiWindowTempData
	outerRectClipped                   C.ImRect
	innerRect                          C.ImRect
	innerClipRect                      C.ImRect
	workRect                           C.ImRect
	parentWorkRect                     C.ImRect
	clipRect                           C.ImRect
	contentRegionRect                  C.ImRect
	hitTestHoleSize                    C.ImVec2ih
	hitTestHoleOffset                  C.ImVec2ih
	lastFrameActive                    int
	lastFrameJustFocused               int
	lastTimeActive                     f32
	itemWidthDefault                   f32
	stateStorage                       C.ImGuiStorage
	columnsStorage                     C.ImVector_ImGuiOldColumns
	fontWindowScale                    f32
	fontDpiScale                       f32
	settingsOffset                     int
	drawList                           &C.ImDrawList
	drawListInst                       C.ImDrawList
	parentWindow                       &C.ImGuiWindow
	parentWindowInBeginStack           &C.ImGuiWindow
	rootWindow                         &C.ImGuiWindow
	rootWindowPopupTree                &C.ImGuiWindow
	rootWindowDockTree                 &C.ImGuiWindow
	rootWindowForTitleBarHighlight     &C.ImGuiWindow
	rootWindowForNav                   &C.ImGuiWindow
	parentWindowForFocusRoute          &C.ImGuiWindow
	navLastChildNavWindow              &C.ImGuiWindow
	navLastIds                         [2]ImGuiID
	navRectRel                         [2]ImRect
	navPreferredScoringPosRel          [2]ImVec2
	navRootFocusScopeId                ImGuiID
	memoryDrawListIdxCapacity          int
	memoryDrawListVtxCapacity          int
	memoryCompacted                    bool
	dockIsActive                       bool
	dockNodeIsVisible                  bool
	dockTabIsVisible                   bool
	dockTabWantClose                   bool
	dockOrder                          i16
	dockStyle                          C.ImGuiWindowDockStyle
	dockNode                           &C.ImGuiDockNode
	dockNodeAsHost                     &C.ImGuiDockNode
	dockId                             ImGuiID
	dockTabItemStatusFlags             ImGuiItemStatusFlags
	dockTabItemRect                    C.ImRect
}

pub type ImGuiWindow = C.ImGuiWindow

pub enum ImGuiTabBarFlagsPrivate_ {
	im_gui_tab_bar_flags_dock_node     = 1 << 20
	im_gui_tab_bar_flags_is_focused    = 1 << 21
	im_gui_tab_bar_flags_save_settings = 1 << 22
}

pub enum ImGuiTabItemFlagsPrivate_ {
	// im_gui_tab_item_flags_section_mask_   = .im_gui_tab_item_flags_leading | .im_gui_tab_item_flags_trailing
	im_gui_tab_item_flags_no_close_button = 1 << 20
	im_gui_tab_item_flags_button          = 1 << 21
	im_gui_tab_item_flags_unsorted        = 1 << 22
}

pub struct C.ImGuiTabItem {
pub:
	iD                ImGuiID
	flags             ImGuiTabItemFlags
	window            &C.ImGuiWindow
	lastFrameVisible  int
	lastFrameSelected int
	offset            f32
	width             f32
	contentWidth      f32
	requestedWidth    f32
	nameOffset        ImS32
	beginOrder        ImS16
	indexDuringLayout ImS16
	wantClose         bool
}

pub type ImGuiTabItem = C.ImGuiTabItem

pub struct C.ImVector_ImGuiTabItem {
pub:
	size     int
	capacity int
	data     &C.ImGuiTabItem
}

pub type ImVector_ImGuiTabItem = C.ImVector_ImGuiTabItem

pub struct C.ImGuiTabBar {
pub:
	tabs                            C.ImVector_ImGuiTabItem
	flags                           ImGuiTabBarFlags
	iD                              ImGuiID
	selectedTabId                   ImGuiID
	nextSelectedTabId               ImGuiID
	visibleTabId                    ImGuiID
	currFrameVisible                int
	prevFrameVisible                int
	barRect                         C.ImRect
	currTabsContentsHeight          f32
	prevTabsContentsHeight          f32
	widthAllTabs                    f32
	widthAllTabsIdeal               f32
	scrollingAnim                   f32
	scrollingTarget                 f32
	scrollingTargetDistToVisibility f32
	scrollingSpeed                  f32
	scrollingRectMinX               f32
	scrollingRectMaxX               f32
	separatorMinX                   f32
	separatorMaxX                   f32
	reorderRequestTabId             ImGuiID
	reorderRequestOffset            ImS16
	beginCount                      ImS8
	wantLayout                      bool
	visibleTabWasSubmitted          bool
	tabsAddedNew                    bool
	tabsActiveCount                 ImS16
	lastTabItemIdx                  ImS16
	itemSpacingY                    f32
	framePadding                    C.ImVec2
	backupCursorPos                 C.ImVec2
	tabsNames                       C.ImGuiTextBuffer
}

pub type ImGuiTabBar = C.ImGuiTabBar

pub type ImGuiTableColumnIdx = i16
pub type ImGuiTableDrawChannelIdx = u16

pub struct C.ImGuiTableColumn {
pub:
	flags                    ImGuiTableColumnFlags
	widthGiven               f32
	minX                     f32
	maxX                     f32
	widthRequest             f32
	widthAuto                f32
	widthMax                 f32
	stretchWeight            f32
	initStretchWeightOrWidth f32
	clipRect                 C.ImRect
	userID                   ImGuiID
	workMinX                 f32
	workMaxX                 f32
	itemWidth                f32
	contentMaxXFrozen        f32
	contentMaxXUnfrozen      f32
	contentMaxXHeadersUsed   f32
	contentMaxXHeadersIdeal  f32
	nameOffset               ImS16
	displayOrder             ImGuiTableColumnIdx
	indexWithinEnabledSet    ImGuiTableColumnIdx
	prevEnabledColumn        ImGuiTableColumnIdx
	nextEnabledColumn        ImGuiTableColumnIdx
	sortOrder                ImGuiTableColumnIdx
	drawChannelCurrent       ImGuiTableDrawChannelIdx
	drawChannelFrozen        ImGuiTableDrawChannelIdx
	drawChannelUnfrozen      ImGuiTableDrawChannelIdx
	isEnabled                bool
	isUserEnabled            bool
	isUserEnabledNextFrame   bool
	isVisibleX               bool
	isVisibleY               bool
	isRequestOutput          bool
	isSkipItems              bool
	isPreserveWidthAuto      bool
	navLayerCurrent          ImS8
	autoFitQueue             ImU8
	cannotSkipItemsQueue     ImU8
	sortDirection            ImU8
	sortDirectionsAvailCount ImU8
	sortDirectionsAvailMask  ImU8
	sortDirectionsAvailList  ImU8
}

pub type ImGuiTableColumn = C.ImGuiTableColumn

pub struct C.ImGuiTableCellData {
pub:
	bgColor ImU32
	column  ImGuiTableColumnIdx
}

pub type ImGuiTableCellData = C.ImGuiTableCellData

pub struct C.ImGuiTableHeaderData {
pub:
	index     ImGuiTableColumnIdx
	textColor ImU32
	bgColor0  ImU32
	bgColor1  ImU32
}

pub type ImGuiTableHeaderData = C.ImGuiTableHeaderData

pub struct C.ImGuiTableInstanceData {
pub:
	tableInstanceID         ImGuiID
	lastOuterHeight         f32
	lastTopHeadersRowHeight f32
	lastFrozenHeight        f32
	hoveredRowLast          int
	hoveredRowNext          int
}

pub type ImGuiTableInstanceData = C.ImGuiTableInstanceData

pub struct C.ImSpan_ImGuiTableColumn {
pub:
	data    &C.ImGuiTableColumn
	dataEnd &C.ImGuiTableColumn
}

pub type ImSpan_ImGuiTableColumn = C.ImSpan_ImGuiTableColumn

pub struct C.ImSpan_ImGuiTableColumnIdx {
pub:
	data    &ImGuiTableColumnIdx
	dataEnd &ImGuiTableColumnIdx
}

pub type ImSpan_ImGuiTableColumnIdx = C.ImSpan_ImGuiTableColumnIdx

pub struct C.ImSpan_ImGuiTableCellData {
pub:
	data    &C.ImGuiTableCellData
	dataEnd &C.ImGuiTableCellData
}

pub type ImSpan_ImGuiTableCellData = C.ImSpan_ImGuiTableCellData

pub struct C.ImVector_ImGuiTableInstanceData {
pub:
	size     int
	capacity int
	data     &C.ImGuiTableInstanceData
}

pub type ImVector_ImGuiTableInstanceData = C.ImVector_ImGuiTableInstanceData

pub struct C.ImVector_ImGuiTableColumnSortSpecs {
pub:
	size     int
	capacity int
	data     &C.ImGuiTableColumnSortSpecs
}

pub type ImVector_ImGuiTableColumnSortSpecs = C.ImVector_ImGuiTableColumnSortSpecs

pub struct C.ImGuiTable {
pub:
	iD                         ImGuiID
	flags                      ImGuiTableFlags
	rawData                    voidptr
	tempData                   &C.ImGuiTableTempData
	columns                    C.ImSpan_ImGuiTableColumn
	displayOrderToIndex        C.ImSpan_ImGuiTableColumnIdx
	rowCellData                C.ImSpan_ImGuiTableCellData
	enabledMaskByDisplayOrder  ImBitArrayPtr
	enabledMaskByIndex         ImBitArrayPtr
	visibleMaskByIndex         ImBitArrayPtr
	settingsLoadedFlags        ImGuiTableFlags
	settingsOffset             int
	lastFrameActive            int
	columnsCount               int
	currentRow                 int
	currentColumn              int
	instanceCurrent            ImS16
	instanceInteracted         ImS16
	rowPosY1                   f32
	rowPosY2                   f32
	rowMinHeight               f32
	rowCellPaddingY            f32
	rowTextBaseline            f32
	rowIndentOffsetX           f32
	rowFlags                   ImGuiTableRowFlags
	lastRowFlags               ImGuiTableRowFlags
	rowBgColorCounter          int
	rowBgColor                 [2]ImU32
	borderColorStrong          ImU32
	borderColorLight           ImU32
	borderX1                   f32
	borderX2                   f32
	hostIndentX                f32
	minColumnWidth             f32
	outerPaddingX              f32
	cellPaddingX               f32
	cellSpacingX1              f32
	cellSpacingX2              f32
	innerWidth                 f32
	columnsGivenWidth          f32
	columnsAutoFitWidth        f32
	columnsStretchSumWeights   f32
	resizedColumnNextWidth     f32
	resizeLockMinContentsX2    f32
	refScale                   f32
	angledHeadersHeight        f32
	angledHeadersSlope         f32
	outerRect                  C.ImRect
	innerRect                  C.ImRect
	workRect                   C.ImRect
	innerClipRect              C.ImRect
	bgClipRect                 C.ImRect
	bg0ClipRectForDrawCmd      C.ImRect
	bg2ClipRectForDrawCmd      C.ImRect
	hostClipRect               C.ImRect
	hostBackupInnerClipRect    C.ImRect
	outerWindow                &C.ImGuiWindow
	innerWindow                &C.ImGuiWindow
	columnsNames               C.ImGuiTextBuffer
	drawSplitter               &C.ImDrawListSplitter
	instanceDataFirst          C.ImGuiTableInstanceData
	instanceDataExtra          C.ImVector_ImGuiTableInstanceData
	sortSpecsSingle            C.ImGuiTableColumnSortSpecs
	sortSpecsMulti             C.ImVector_ImGuiTableColumnSortSpecs
	sortSpecs                  C.ImGuiTableSortSpecs
	sortSpecsCount             ImGuiTableColumnIdx
	columnsEnabledCount        ImGuiTableColumnIdx
	columnsEnabledFixedCount   ImGuiTableColumnIdx
	declColumnsCount           ImGuiTableColumnIdx
	angledHeadersCount         ImGuiTableColumnIdx
	hoveredColumnBody          ImGuiTableColumnIdx
	hoveredColumnBorder        ImGuiTableColumnIdx
	highlightColumnHeader      ImGuiTableColumnIdx
	autoFitSingleColumn        ImGuiTableColumnIdx
	resizedColumn              ImGuiTableColumnIdx
	lastResizedColumn          ImGuiTableColumnIdx
	heldHeaderColumn           ImGuiTableColumnIdx
	reorderColumn              ImGuiTableColumnIdx
	reorderColumnDir           ImGuiTableColumnIdx
	leftMostEnabledColumn      ImGuiTableColumnIdx
	rightMostEnabledColumn     ImGuiTableColumnIdx
	leftMostStretchedColumn    ImGuiTableColumnIdx
	rightMostStretchedColumn   ImGuiTableColumnIdx
	contextPopupColumn         ImGuiTableColumnIdx
	freezeRowsRequest          ImGuiTableColumnIdx
	freezeRowsCount            ImGuiTableColumnIdx
	freezeColumnsRequest       ImGuiTableColumnIdx
	freezeColumnsCount         ImGuiTableColumnIdx
	rowCellDataCurrent         ImGuiTableColumnIdx
	dummyDrawChannel           ImGuiTableDrawChannelIdx
	bg2DrawChannelCurrent      ImGuiTableDrawChannelIdx
	bg2DrawChannelUnfrozen     ImGuiTableDrawChannelIdx
	isLayoutLocked             bool
	isInsideRow                bool
	isInitializing             bool
	isSortSpecsDirty           bool
	isUsingHeaders             bool
	isContextPopupOpen         bool
	disableDefaultContextMenu  bool
	isSettingsRequestLoad      bool
	isSettingsDirty            bool
	isDefaultDisplayOrder      bool
	isResetAllRequest          bool
	isResetDisplayOrderRequest bool
	isUnfrozenRows             bool
	isDefaultSizingPolicy      bool
	isActiveIdAliveBeforeTable bool
	isActiveIdInTable          bool
	hasScrollbarYCurr          bool
	hasScrollbarYPrev          bool
	memoryCompacted            bool
	hostSkipItems              bool
}

pub type ImGuiTable = C.ImGuiTable

pub struct C.ImVector_ImGuiTableHeaderData {
pub:
	size     int
	capacity int
	data     &C.ImGuiTableHeaderData
}

pub type ImVector_ImGuiTableHeaderData = C.ImVector_ImGuiTableHeaderData

pub struct C.ImGuiTableTempData {
pub:
	tableIndex                   int
	lastTimeActive               f32
	angledHeadersExtraWidth      f32
	angledHeadersRequests        C.ImVector_ImGuiTableHeaderData
	userOuterSize                C.ImVec2
	drawSplitter                 C.ImDrawListSplitter
	hostBackupWorkRect           C.ImRect
	hostBackupParentWorkRect     C.ImRect
	hostBackupPrevLineSize       C.ImVec2
	hostBackupCurrLineSize       C.ImVec2
	hostBackupCursorMaxPos       C.ImVec2
	hostBackupColumnsOffset      C.ImVec1
	hostBackupItemWidth          f32
	hostBackupItemWidthStackSize int
}

pub type ImGuiTableTempData = C.ImGuiTableTempData

pub struct C.ImGuiTableColumnSettings {
pub:
	widthOrWeight f32
	userID        ImGuiID
	index         ImGuiTableColumnIdx
	displayOrder  ImGuiTableColumnIdx
	sortOrder     ImGuiTableColumnIdx
	sortDirection ImU8
	isEnabled     ImU8
	isStretch     ImU8
}

pub type ImGuiTableColumnSettings = C.ImGuiTableColumnSettings

pub struct C.ImGuiTableSettings {
pub:
	iD              ImGuiID
	saveFlags       ImGuiTableFlags
	refScale        f32
	columnsCount    ImGuiTableColumnIdx
	columnsCountMax ImGuiTableColumnIdx
	wantApply       bool
}

pub type ImGuiTableSettings = C.ImGuiTableSettings

pub struct C.ImFontBuilderIO {
pub:
	fontBuilder_Build fn (&C.ImFontAtlas) bool
}

pub type ImFontBuilderIO = C.ImFontBuilderIO

// CIMGUI_DEFINE_ENUMS_AND_STRUCTS
// CIMGUI_DEFINE_ENUMS_AND_STRUCTS
fn C.ImVec2_ImVec2_Nil() &C.ImVec2

pub fn im_vec2_im_vec2_nil() &C.ImVec2 {
	return C.ImVec2_ImVec2_Nil()
}

fn C.ImVec2_destroy(self &C.ImVec2)

pub fn im_vec2_destroy(self &C.ImVec2) {
	C.ImVec2_destroy(self)
}

fn C.ImVec2_ImVec2_Float(_x f32, _y f32) &C.ImVec2

pub fn im_vec2_im_vec2_float(_x f32, _y f32) &C.ImVec2 {
	return C.ImVec2_ImVec2_Float(_x, _y)
}

fn C.ImVec4_ImVec4_Nil() &C.ImVec4

pub fn im_vec4_im_vec4_nil() &C.ImVec4 {
	return C.ImVec4_ImVec4_Nil()
}

fn C.ImVec4_destroy(self &C.ImVec4)

pub fn im_vec4_destroy(self &C.ImVec4) {
	C.ImVec4_destroy(self)
}

fn C.ImVec4_ImVec4_Float(_x f32, _y f32, _z f32, _w f32) &C.ImVec4

pub fn im_vec4_im_vec4_float(_x f32, _y f32, _z f32, _w f32) &C.ImVec4 {
	return C.ImVec4_ImVec4_Float(_x, _y, _z, _w)
}

fn C.igCreateContext(shared_font_atlas &C.ImFontAtlas) &C.ImGuiContext

pub fn ig_create_context(shared_font_atlas &C.ImFontAtlas) &C.ImGuiContext {
	return C.igCreateContext(shared_font_atlas)
}

fn C.igDestroyContext(ctx &C.ImGuiContext)

pub fn ig_destroy_context(ctx &C.ImGuiContext) {
	C.igDestroyContext(ctx)
}

fn C.igGetCurrentContext() &C.ImGuiContext

pub fn ig_get_current_context() &C.ImGuiContext {
	return C.igGetCurrentContext()
}

fn C.igSetCurrentContext(ctx &C.ImGuiContext)

pub fn ig_set_current_context(ctx &C.ImGuiContext) {
	C.igSetCurrentContext(ctx)
}

fn C.igGetIO() &C.ImGuiIO

pub fn ig_get_io() &C.ImGuiIO {
	return C.igGetIO()
}

fn C.igGetPlatformIO() &C.ImGuiPlatformIO

pub fn ig_get_platform_io() &C.ImGuiPlatformIO {
	return C.igGetPlatformIO()
}

fn C.igGetStyle() &C.ImGuiStyle

pub fn ig_get_style() &C.ImGuiStyle {
	return C.igGetStyle()
}

fn C.igNewFrame()

pub fn ig_new_frame() {
	C.igNewFrame()
}

fn C.igEndFrame()

pub fn ig_end_frame() {
	C.igEndFrame()
}

fn C.igRender()

pub fn ig_render() {
	C.igRender()
}

fn C.igGetDrawData() &C.ImDrawData

pub fn ig_get_draw_data() &C.ImDrawData {
	return C.igGetDrawData()
}

fn C.igShowDemoWindow(p_open &bool)

pub fn ig_show_demo_window(p_open &bool) {
	C.igShowDemoWindow(p_open)
}

fn C.igShowMetricsWindow(p_open &bool)

pub fn ig_show_metrics_window(p_open &bool) {
	C.igShowMetricsWindow(p_open)
}

fn C.igShowDebugLogWindow(p_open &bool)

pub fn ig_show_debug_log_window(p_open &bool) {
	C.igShowDebugLogWindow(p_open)
}

fn C.igShowIDStackToolWindow(p_open &bool)

pub fn ig_show_ids_tack_tool_window(p_open &bool) {
	C.igShowIDStackToolWindow(p_open)
}

fn C.igShowAboutWindow(p_open &bool)

pub fn ig_show_about_window(p_open &bool) {
	C.igShowAboutWindow(p_open)
}

fn C.igShowStyleEditor(ref &C.ImGuiStyle)

pub fn ig_show_style_editor(ref &C.ImGuiStyle) {
	C.igShowStyleEditor(ref)
}

fn C.igShowStyleSelector(label &i8) bool

pub fn ig_show_style_selector(label &i8) bool {
	return C.igShowStyleSelector(label)
}

fn C.igShowFontSelector(label &i8)

pub fn ig_show_font_selector(label &i8) {
	C.igShowFontSelector(label)
}

fn C.igShowUserGuide()

pub fn ig_show_user_guide() {
	C.igShowUserGuide()
}

fn C.igGetVersion() &i8

pub fn ig_get_version() &i8 {
	return C.igGetVersion()
}

fn C.igStyleColorsDark(dst &C.ImGuiStyle)

pub fn ig_style_colors_dark(dst &C.ImGuiStyle) {
	C.igStyleColorsDark(dst)
}

fn C.igStyleColorsLight(dst &C.ImGuiStyle)

pub fn ig_style_colors_light(dst &C.ImGuiStyle) {
	C.igStyleColorsLight(dst)
}

fn C.igStyleColorsClassic(dst &C.ImGuiStyle)

pub fn ig_style_colors_classic(dst &C.ImGuiStyle) {
	C.igStyleColorsClassic(dst)
}

fn C.igBegin(name &i8, p_open &bool, flags ImGuiWindowFlags) bool

pub fn ig_begin(name &i8, p_open &bool, flags ImGuiWindowFlags) bool {
	return C.igBegin(name, p_open, flags)
}

fn C.igEnd()

pub fn ig_end() {
	C.igEnd()
}

fn C.igBeginChild_Str(str_id &i8, size C.ImVec2, child_flags ImGuiChildFlags, window_flags ImGuiWindowFlags) bool

pub fn ig_begin_child_str(str_id &i8, size C.ImVec2, child_flags ImGuiChildFlags, window_flags ImGuiWindowFlags) bool {
	return C.igBeginChild_Str(str_id, size, child_flags, window_flags)
}

fn C.igBeginChild_ID(id ImGuiID, size C.ImVec2, child_flags ImGuiChildFlags, window_flags ImGuiWindowFlags) bool

pub fn ig_begin_child_id(id ImGuiID, size C.ImVec2, child_flags ImGuiChildFlags, window_flags ImGuiWindowFlags) bool {
	return C.igBeginChild_ID(id, size, child_flags, window_flags)
}

fn C.igEndChild()

pub fn ig_end_child() {
	C.igEndChild()
}

fn C.igIsWindowAppearing() bool

pub fn ig_is_window_appearing() bool {
	return C.igIsWindowAppearing()
}

fn C.igIsWindowCollapsed() bool

pub fn ig_is_window_collapsed() bool {
	return C.igIsWindowCollapsed()
}

fn C.igIsWindowFocused(flags ImGuiFocusedFlags) bool

pub fn ig_is_window_focused(flags ImGuiFocusedFlags) bool {
	return C.igIsWindowFocused(flags)
}

fn C.igIsWindowHovered(flags ImGuiHoveredFlags) bool

pub fn ig_is_window_hovered(flags ImGuiHoveredFlags) bool {
	return C.igIsWindowHovered(flags)
}

fn C.igGetWindowDrawList() &C.ImDrawList

pub fn ig_get_window_draw_list() &C.ImDrawList {
	return C.igGetWindowDrawList()
}

fn C.igGetWindowDpiScale() f32

pub fn ig_get_window_dpi_scale() f32 {
	return C.igGetWindowDpiScale()
}

fn C.igGetWindowPos(p_out &C.ImVec2)

pub fn ig_get_window_pos(p_out &C.ImVec2) {
	C.igGetWindowPos(p_out)
}

fn C.igGetWindowSize(p_out &C.ImVec2)

pub fn ig_get_window_size(p_out &C.ImVec2) {
	C.igGetWindowSize(p_out)
}

fn C.igGetWindowWidth() f32

pub fn ig_get_window_width() f32 {
	return C.igGetWindowWidth()
}

fn C.igGetWindowHeight() f32

pub fn ig_get_window_height() f32 {
	return C.igGetWindowHeight()
}

fn C.igGetWindowViewport() &C.ImGuiViewport

pub fn ig_get_window_viewport() &C.ImGuiViewport {
	return C.igGetWindowViewport()
}

fn C.igSetNextWindowPos(pos C.ImVec2, cond ImGuiCond, pivot C.ImVec2)

pub fn ig_set_next_window_pos(pos C.ImVec2, cond ImGuiCond, pivot C.ImVec2) {
	C.igSetNextWindowPos(pos, cond, pivot)
}

fn C.igSetNextWindowSize(size C.ImVec2, cond ImGuiCond)

pub fn ig_set_next_window_size(size C.ImVec2, cond ImGuiCond) {
	C.igSetNextWindowSize(size, cond)
}

fn C.igSetNextWindowSizeConstraints(size_min C.ImVec2, size_max C.ImVec2, custom_callback ImGuiSizeCallback, custom_callback_data voidptr)

pub fn ig_set_next_window_size_constraints(size_min C.ImVec2, size_max C.ImVec2, custom_callback ImGuiSizeCallback, custom_callback_data voidptr) {
	C.igSetNextWindowSizeConstraints(size_min, size_max, custom_callback, custom_callback_data)
}

fn C.igSetNextWindowContentSize(size C.ImVec2)

pub fn ig_set_next_window_content_size(size C.ImVec2) {
	C.igSetNextWindowContentSize(size)
}

fn C.igSetNextWindowCollapsed(collapsed bool, cond ImGuiCond)

pub fn ig_set_next_window_collapsed(collapsed bool, cond ImGuiCond) {
	C.igSetNextWindowCollapsed(collapsed, cond)
}

fn C.igSetNextWindowFocus()

pub fn ig_set_next_window_focus() {
	C.igSetNextWindowFocus()
}

fn C.igSetNextWindowScroll(scroll C.ImVec2)

pub fn ig_set_next_window_scroll(scroll C.ImVec2) {
	C.igSetNextWindowScroll(scroll)
}

fn C.igSetNextWindowBgAlpha(alpha f32)

pub fn ig_set_next_window_bg_alpha(alpha f32) {
	C.igSetNextWindowBgAlpha(alpha)
}

fn C.igSetNextWindowViewport(viewport_id ImGuiID)

pub fn ig_set_next_window_viewport(viewport_id ImGuiID) {
	C.igSetNextWindowViewport(viewport_id)
}

fn C.igSetWindowPos_Vec2(pos C.ImVec2, cond ImGuiCond)

pub fn ig_set_window_pos_vec2(pos C.ImVec2, cond ImGuiCond) {
	C.igSetWindowPos_Vec2(pos, cond)
}

fn C.igSetWindowSize_Vec2(size C.ImVec2, cond ImGuiCond)

pub fn ig_set_window_size_vec2(size C.ImVec2, cond ImGuiCond) {
	C.igSetWindowSize_Vec2(size, cond)
}

fn C.igSetWindowCollapsed_Bool(collapsed bool, cond ImGuiCond)

pub fn ig_set_window_collapsed_bool(collapsed bool, cond ImGuiCond) {
	C.igSetWindowCollapsed_Bool(collapsed, cond)
}

fn C.igSetWindowFocus_Nil()

pub fn ig_set_window_focus_nil() {
	C.igSetWindowFocus_Nil()
}

fn C.igSetWindowFontScale(scale f32)

pub fn ig_set_window_font_scale(scale f32) {
	C.igSetWindowFontScale(scale)
}

fn C.igSetWindowPos_Str(name &i8, pos C.ImVec2, cond ImGuiCond)

pub fn ig_set_window_pos_str(name &i8, pos C.ImVec2, cond ImGuiCond) {
	C.igSetWindowPos_Str(name, pos, cond)
}

fn C.igSetWindowSize_Str(name &i8, size C.ImVec2, cond ImGuiCond)

pub fn ig_set_window_size_str(name &i8, size C.ImVec2, cond ImGuiCond) {
	C.igSetWindowSize_Str(name, size, cond)
}

fn C.igSetWindowCollapsed_Str(name &i8, collapsed bool, cond ImGuiCond)

pub fn ig_set_window_collapsed_str(name &i8, collapsed bool, cond ImGuiCond) {
	C.igSetWindowCollapsed_Str(name, collapsed, cond)
}

fn C.igSetWindowFocus_Str(name &i8)

pub fn ig_set_window_focus_str(name &i8) {
	C.igSetWindowFocus_Str(name)
}

fn C.igGetScrollX() f32

pub fn ig_get_scroll_x() f32 {
	return C.igGetScrollX()
}

fn C.igGetScrollY() f32

pub fn ig_get_scroll_y() f32 {
	return C.igGetScrollY()
}

fn C.igSetScrollX_Float(scroll_x f32)

pub fn ig_set_scroll_x_float(scroll_x f32) {
	C.igSetScrollX_Float(scroll_x)
}

fn C.igSetScrollY_Float(scroll_y f32)

pub fn ig_set_scroll_y_float(scroll_y f32) {
	C.igSetScrollY_Float(scroll_y)
}

fn C.igGetScrollMaxX() f32

pub fn ig_get_scroll_max_x() f32 {
	return C.igGetScrollMaxX()
}

fn C.igGetScrollMaxY() f32

pub fn ig_get_scroll_max_y() f32 {
	return C.igGetScrollMaxY()
}

fn C.igSetScrollHereX(center_x_ratio f32)

pub fn ig_set_scroll_here_x(center_x_ratio f32) {
	C.igSetScrollHereX(center_x_ratio)
}

fn C.igSetScrollHereY(center_y_ratio f32)

pub fn ig_set_scroll_here_y(center_y_ratio f32) {
	C.igSetScrollHereY(center_y_ratio)
}

fn C.igSetScrollFromPosX_Float(local_x f32, center_x_ratio f32)

pub fn ig_set_scroll_from_pos_x_float(local_x f32, center_x_ratio f32) {
	C.igSetScrollFromPosX_Float(local_x, center_x_ratio)
}

fn C.igSetScrollFromPosY_Float(local_y f32, center_y_ratio f32)

pub fn ig_set_scroll_from_pos_y_float(local_y f32, center_y_ratio f32) {
	C.igSetScrollFromPosY_Float(local_y, center_y_ratio)
}

fn C.igPushFont(font &C.ImFont)

pub fn ig_push_font(font &C.ImFont) {
	C.igPushFont(font)
}

fn C.igPopFont()

pub fn ig_pop_font() {
	C.igPopFont()
}

fn C.igPushStyleColor_U32(idx ImGuiCol, col ImU32)

pub fn ig_push_style_color_u32(idx ImGuiCol, col ImU32) {
	C.igPushStyleColor_U32(idx, col)
}

fn C.igPushStyleColor_Vec4(idx ImGuiCol, col C.ImVec4)

pub fn ig_push_style_color_vec4(idx ImGuiCol, col C.ImVec4) {
	C.igPushStyleColor_Vec4(idx, col)
}

fn C.igPopStyleColor(count int)

pub fn ig_pop_style_color(count int) {
	C.igPopStyleColor(count)
}

fn C.igPushStyleVar_Float(idx ImGuiStyleVar, val f32)

pub fn ig_push_style_var_float(idx ImGuiStyleVar, val f32) {
	C.igPushStyleVar_Float(idx, val)
}

fn C.igPushStyleVar_Vec2(idx ImGuiStyleVar, val C.ImVec2)

pub fn ig_push_style_var_vec2(idx ImGuiStyleVar, val C.ImVec2) {
	C.igPushStyleVar_Vec2(idx, val)
}

fn C.igPushStyleVarX(idx ImGuiStyleVar, val_x f32)

pub fn ig_push_style_var_x(idx ImGuiStyleVar, val_x f32) {
	C.igPushStyleVarX(idx, val_x)
}

fn C.igPushStyleVarY(idx ImGuiStyleVar, val_y f32)

pub fn ig_push_style_var_y(idx ImGuiStyleVar, val_y f32) {
	C.igPushStyleVarY(idx, val_y)
}

fn C.igPopStyleVar(count int)

pub fn ig_pop_style_var(count int) {
	C.igPopStyleVar(count)
}

fn C.igPushItemFlag(option ImGuiItemFlags, enabled bool)

pub fn ig_push_item_flag(option ImGuiItemFlags, enabled bool) {
	C.igPushItemFlag(option, enabled)
}

fn C.igPopItemFlag()

pub fn ig_pop_item_flag() {
	C.igPopItemFlag()
}

fn C.igPushItemWidth(item_width f32)

pub fn ig_push_item_width(item_width f32) {
	C.igPushItemWidth(item_width)
}

fn C.igPopItemWidth()

pub fn ig_pop_item_width() {
	C.igPopItemWidth()
}

fn C.igSetNextItemWidth(item_width f32)

pub fn ig_set_next_item_width(item_width f32) {
	C.igSetNextItemWidth(item_width)
}

fn C.igCalcItemWidth() f32

pub fn ig_calc_item_width() f32 {
	return C.igCalcItemWidth()
}

fn C.igPushTextWrapPos(wrap_local_pos_x f32)

pub fn ig_push_text_wrap_pos(wrap_local_pos_x f32) {
	C.igPushTextWrapPos(wrap_local_pos_x)
}

fn C.igPopTextWrapPos()

pub fn ig_pop_text_wrap_pos() {
	C.igPopTextWrapPos()
}

fn C.igGetFont() &C.ImFont

pub fn ig_get_font() &C.ImFont {
	return C.igGetFont()
}

fn C.igGetFontSize() f32

pub fn ig_get_font_size() f32 {
	return C.igGetFontSize()
}

fn C.igGetFontTexUvWhitePixel(p_out &C.ImVec2)

pub fn ig_get_font_tex_uv_white_pixel(p_out &C.ImVec2) {
	C.igGetFontTexUvWhitePixel(p_out)
}

fn C.igGetColorU32_Col(idx ImGuiCol, alpha_mul f32) ImU32

pub fn ig_get_color_u32_col(idx ImGuiCol, alpha_mul f32) ImU32 {
	return C.igGetColorU32_Col(idx, alpha_mul)
}

fn C.igGetColorU32_Vec4(col C.ImVec4) ImU32

pub fn ig_get_color_u32_vec4(col C.ImVec4) ImU32 {
	return C.igGetColorU32_Vec4(col)
}

fn C.igGetColorU32_U32(col ImU32, alpha_mul f32) ImU32

pub fn ig_get_color_u32_u32(col ImU32, alpha_mul f32) ImU32 {
	return C.igGetColorU32_U32(col, alpha_mul)
}

fn C.igGetStyleColorVec4(idx ImGuiCol) &C.ImVec4

pub fn ig_get_style_color_vec4(idx ImGuiCol) &C.ImVec4 {
	return C.igGetStyleColorVec4(idx)
}

fn C.igGetCursorScreenPos(p_out &C.ImVec2)

pub fn ig_get_cursor_screen_pos(p_out &C.ImVec2) {
	C.igGetCursorScreenPos(p_out)
}

fn C.igSetCursorScreenPos(pos C.ImVec2)

pub fn ig_set_cursor_screen_pos(pos C.ImVec2) {
	C.igSetCursorScreenPos(pos)
}

fn C.igGetContentRegionAvail(p_out &C.ImVec2)

pub fn ig_get_content_region_avail(p_out &C.ImVec2) {
	C.igGetContentRegionAvail(p_out)
}

fn C.igGetCursorPos(p_out &C.ImVec2)

pub fn ig_get_cursor_pos(p_out &C.ImVec2) {
	C.igGetCursorPos(p_out)
}

fn C.igGetCursorPosX() f32

pub fn ig_get_cursor_pos_x() f32 {
	return C.igGetCursorPosX()
}

fn C.igGetCursorPosY() f32

pub fn ig_get_cursor_pos_y() f32 {
	return C.igGetCursorPosY()
}

fn C.igSetCursorPos(local_pos C.ImVec2)

pub fn ig_set_cursor_pos(local_pos C.ImVec2) {
	C.igSetCursorPos(local_pos)
}

fn C.igSetCursorPosX(local_x f32)

pub fn ig_set_cursor_pos_x(local_x f32) {
	C.igSetCursorPosX(local_x)
}

fn C.igSetCursorPosY(local_y f32)

pub fn ig_set_cursor_pos_y(local_y f32) {
	C.igSetCursorPosY(local_y)
}

fn C.igGetCursorStartPos(p_out &C.ImVec2)

pub fn ig_get_cursor_start_pos(p_out &C.ImVec2) {
	C.igGetCursorStartPos(p_out)
}

fn C.igSeparator()

pub fn ig_separator() {
	C.igSeparator()
}

fn C.igSameLine(offset_from_start_x f32, spacing f32)

pub fn ig_same_line(offset_from_start_x f32, spacing f32) {
	C.igSameLine(offset_from_start_x, spacing)
}

fn C.igNewLine()

pub fn ig_new_line() {
	C.igNewLine()
}

fn C.igSpacing()

pub fn ig_spacing() {
	C.igSpacing()
}

fn C.igDummy(size C.ImVec2)

pub fn ig_dummy(size C.ImVec2) {
	C.igDummy(size)
}

fn C.igIndent(indent_w f32)

pub fn ig_indent(indent_w f32) {
	C.igIndent(indent_w)
}

fn C.igUnindent(indent_w f32)

pub fn ig_unindent(indent_w f32) {
	C.igUnindent(indent_w)
}

fn C.igBeginGroup()

pub fn ig_begin_group() {
	C.igBeginGroup()
}

fn C.igEndGroup()

pub fn ig_end_group() {
	C.igEndGroup()
}

fn C.igAlignTextToFramePadding()

pub fn ig_align_text_to_frame_padding() {
	C.igAlignTextToFramePadding()
}

fn C.igGetTextLineHeight() f32

pub fn ig_get_text_line_height() f32 {
	return C.igGetTextLineHeight()
}

fn C.igGetTextLineHeightWithSpacing() f32

pub fn ig_get_text_line_height_with_spacing() f32 {
	return C.igGetTextLineHeightWithSpacing()
}

fn C.igGetFrameHeight() f32

pub fn ig_get_frame_height() f32 {
	return C.igGetFrameHeight()
}

fn C.igGetFrameHeightWithSpacing() f32

pub fn ig_get_frame_height_with_spacing() f32 {
	return C.igGetFrameHeightWithSpacing()
}

fn C.igPushID_Str(str_id &i8)

pub fn ig_push_id_str(str_id &i8) {
	C.igPushID_Str(str_id)
}

fn C.igPushID_StrStr(str_id_begin &i8, str_id_end &i8)

pub fn ig_push_id_str_str(str_id_begin &i8, str_id_end &i8) {
	C.igPushID_StrStr(str_id_begin, str_id_end)
}

fn C.igPushID_Ptr(ptr_id voidptr)

pub fn ig_push_id_ptr(ptr_id voidptr) {
	C.igPushID_Ptr(ptr_id)
}

fn C.igPushID_Int(int_id int)

pub fn ig_push_id_int(int_id int) {
	C.igPushID_Int(int_id)
}

fn C.igPopID()

pub fn ig_pop_id() {
	C.igPopID()
}

fn C.igGetID_Str(str_id &i8) ImGuiID

pub fn ig_get_id_str(str_id &i8) ImGuiID {
	return C.igGetID_Str(str_id)
}

fn C.igGetID_StrStr(str_id_begin &i8, str_id_end &i8) ImGuiID

pub fn ig_get_id_str_str(str_id_begin &i8, str_id_end &i8) ImGuiID {
	return C.igGetID_StrStr(str_id_begin, str_id_end)
}

fn C.igGetID_Ptr(ptr_id voidptr) ImGuiID

pub fn ig_get_id_ptr(ptr_id voidptr) ImGuiID {
	return C.igGetID_Ptr(ptr_id)
}

fn C.igGetID_Int(int_id int) ImGuiID

pub fn ig_get_id_int(int_id int) ImGuiID {
	return C.igGetID_Int(int_id)
}

fn C.igTextUnformatted(text &i8, text_end &i8)

pub fn ig_text_unformatted(text &i8, text_end &i8) {
	C.igTextUnformatted(text, text_end)
}

@[c2v_variadic]
fn C.igText(fmt ...&i8)

pub fn ig_text(fmt &i8) {
	C.igText(fmt)
}

fn C.igTextV(fmt &i8, args C.va_list)

pub fn ig_text_v(fmt &i8, args C.va_list) {
	C.igTextV(fmt, args)
}

@[c2v_variadic]
fn C.igTextColored(col C.ImVec4, fmt ...&i8)

pub fn ig_text_colored(col C.ImVec4, fmt &i8) {
	C.igTextColored(col, fmt)
}

fn C.igTextColoredV(col C.ImVec4, fmt &i8, args C.va_list)

pub fn ig_text_colored_v(col C.ImVec4, fmt &i8, args C.va_list) {
	C.igTextColoredV(col, fmt, args)
}

@[c2v_variadic]
fn C.igTextDisabled(fmt ...&i8)

pub fn ig_text_disabled(fmt &i8) {
	C.igTextDisabled(fmt)
}

fn C.igTextDisabledV(fmt &i8, args C.va_list)

pub fn ig_text_disabled_v(fmt &i8, args C.va_list) {
	C.igTextDisabledV(fmt, args)
}

@[c2v_variadic]
fn C.igTextWrapped(fmt ...&i8)

pub fn ig_text_wrapped(fmt &i8) {
	C.igTextWrapped(fmt)
}

fn C.igTextWrappedV(fmt &i8, args C.va_list)

pub fn ig_text_wrapped_v(fmt &i8, args C.va_list) {
	C.igTextWrappedV(fmt, args)
}

@[c2v_variadic]
fn C.igLabelText(label &i8, fmt ...&i8)

pub fn ig_label_text(label &i8, fmt &i8) {
	C.igLabelText(label, fmt)
}

fn C.igLabelTextV(label &i8, fmt &i8, args C.va_list)

pub fn ig_label_text_v(label &i8, fmt &i8, args C.va_list) {
	C.igLabelTextV(label, fmt, args)
}

@[c2v_variadic]
fn C.igBulletText(fmt ...&i8)

pub fn ig_bullet_text(fmt &i8) {
	C.igBulletText(fmt)
}

fn C.igBulletTextV(fmt &i8, args C.va_list)

pub fn ig_bullet_text_v(fmt &i8, args C.va_list) {
	C.igBulletTextV(fmt, args)
}

fn C.igSeparatorText(label &i8)

pub fn ig_separator_text(label &i8) {
	C.igSeparatorText(label)
}

fn C.igButton(label &i8, size C.ImVec2) bool

pub fn ig_button(label &i8, size C.ImVec2) bool {
	return C.igButton(label, size)
}

fn C.igSmallButton(label &i8) bool

pub fn ig_small_button(label &i8) bool {
	return C.igSmallButton(label)
}

fn C.igInvisibleButton(str_id &i8, size C.ImVec2, flags ImGuiButtonFlags) bool

pub fn ig_invisible_button(str_id &i8, size C.ImVec2, flags ImGuiButtonFlags) bool {
	return C.igInvisibleButton(str_id, size, flags)
}

fn C.igArrowButton(str_id &i8, dir ImGuiDir) bool

pub fn ig_arrow_button(str_id &i8, dir ImGuiDir) bool {
	return C.igArrowButton(str_id, dir)
}

fn C.igCheckbox(label &i8, v &bool) bool

pub fn ig_checkbox(label &i8, v &bool) bool {
	return C.igCheckbox(label, v)
}

fn C.igCheckboxFlags_IntPtr(label &i8, flags &int, flags_value int) bool

pub fn ig_checkbox_flags_int_ptr(label &i8, flags &int, flags_value int) bool {
	return C.igCheckboxFlags_IntPtr(label, flags, flags_value)
}

fn C.igCheckboxFlags_UintPtr(label &i8, flags &u32, flags_value u32) bool

pub fn ig_checkbox_flags_uint_ptr(label &i8, flags &u32, flags_value u32) bool {
	return C.igCheckboxFlags_UintPtr(label, flags, flags_value)
}

fn C.igRadioButton_Bool(label &i8, active bool) bool

pub fn ig_radio_button_bool(label &i8, active bool) bool {
	return C.igRadioButton_Bool(label, active)
}

fn C.igRadioButton_IntPtr(label &i8, v &int, v_button int) bool

pub fn ig_radio_button_int_ptr(label &i8, v &int, v_button int) bool {
	return C.igRadioButton_IntPtr(label, v, v_button)
}

fn C.igProgressBar(fraction f32, size_arg C.ImVec2, overlay &i8)

pub fn ig_progress_bar(fraction f32, size_arg C.ImVec2, overlay &i8) {
	C.igProgressBar(fraction, size_arg, overlay)
}

fn C.igBullet()

pub fn ig_bullet() {
	C.igBullet()
}

fn C.igTextLink(label &i8) bool

pub fn ig_text_link(label &i8) bool {
	return C.igTextLink(label)
}

fn C.igTextLinkOpenURL(label &i8, url &i8)

pub fn ig_text_link_open_url(label &i8, url &i8) {
	C.igTextLinkOpenURL(label, url)
}

fn C.igImage(user_texture_id ImTextureID, image_size C.ImVec2, uv0 C.ImVec2, uv1 C.ImVec2, tint_col C.ImVec4, border_col C.ImVec4)

pub fn ig_image(user_texture_id ImTextureID, image_size C.ImVec2, uv0 C.ImVec2, uv1 C.ImVec2, tint_col C.ImVec4, border_col C.ImVec4) {
	C.igImage(user_texture_id, image_size, uv0, uv1, tint_col, border_col)
}

fn C.igImageButton(str_id &i8, user_texture_id ImTextureID, image_size C.ImVec2, uv0 C.ImVec2, uv1 C.ImVec2, bg_col C.ImVec4, tint_col C.ImVec4) bool

pub fn ig_image_button(str_id &i8, user_texture_id ImTextureID, image_size C.ImVec2, uv0 C.ImVec2, uv1 C.ImVec2, bg_col C.ImVec4, tint_col C.ImVec4) bool {
	return C.igImageButton(str_id, user_texture_id, image_size, uv0, uv1, bg_col, tint_col)
}

fn C.igBeginCombo(label &i8, preview_value &i8, flags ImGuiComboFlags) bool

pub fn ig_begin_combo(label &i8, preview_value &i8, flags ImGuiComboFlags) bool {
	return C.igBeginCombo(label, preview_value, flags)
}

fn C.igEndCombo()

pub fn ig_end_combo() {
	C.igEndCombo()
}

fn C.igCombo_Str_arr(label &i8, current_item &int, items &&u8, items_count int, popup_max_height_in_items int) bool

pub fn ig_combo_str_arr(label &i8, current_item &int, items &&u8, items_count int, popup_max_height_in_items int) bool {
	return C.igCombo_Str_arr(label, current_item, items, items_count, popup_max_height_in_items)
}

fn C.igCombo_Str(label &i8, current_item &int, items_separated_by_zeros &i8, popup_max_height_in_items int) bool

pub fn ig_combo_str(label &i8, current_item &int, items_separated_by_zeros &i8, popup_max_height_in_items int) bool {
	return C.igCombo_Str(label, current_item, items_separated_by_zeros, popup_max_height_in_items)
}

fn C.igCombo_FnStrPtr(label &i8, current_item &int, getter fn (voidptr, int) &i8, user_data voidptr, items_count int, popup_max_height_in_items int) bool

pub fn ig_combo_fn_str_ptr(label &i8, current_item &int, getter fn (voidptr, int) &i8, user_data voidptr, items_count int, popup_max_height_in_items int) bool {
	return C.igCombo_FnStrPtr(label, current_item, getter, user_data, items_count, popup_max_height_in_items)
}

fn C.igDragFloat(label &i8, v &f32, v_speed f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_float(label &i8, v &f32, v_speed f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragFloat(label, v, v_speed, v_min, v_max, format, flags)
}

fn C.igDragFloat2(label &i8, v &f32, v_speed f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_float2(label &i8, v &f32, v_speed f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragFloat2(label, v, v_speed, v_min, v_max, format, flags)
}

fn C.igDragFloat3(label &i8, v &f32, v_speed f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_float3(label &i8, v &f32, v_speed f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragFloat3(label, v, v_speed, v_min, v_max, format, flags)
}

fn C.igDragFloat4(label &i8, v &f32, v_speed f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_float4(label &i8, v &f32, v_speed f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragFloat4(label, v, v_speed, v_min, v_max, format, flags)
}

fn C.igDragFloatRange2(label &i8, v_current_min &f32, v_current_max &f32, v_speed f32, v_min f32, v_max f32, format &i8, format_max &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_float_range2(label &i8, v_current_min &f32, v_current_max &f32, v_speed f32, v_min f32, v_max f32, format &i8, format_max &i8, flags ImGuiSliderFlags) bool {
	return C.igDragFloatRange2(label, v_current_min, v_current_max, v_speed, v_min, v_max,
		format, format_max, flags)
}

fn C.igDragInt(label &i8, v &int, v_speed f32, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_int(label &i8, v &int, v_speed f32, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragInt(label, v, v_speed, v_min, v_max, format, flags)
}

fn C.igDragInt2(label &i8, v &int, v_speed f32, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_int2(label &i8, v &int, v_speed f32, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragInt2(label, v, v_speed, v_min, v_max, format, flags)
}

fn C.igDragInt3(label &i8, v &int, v_speed f32, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_int3(label &i8, v &int, v_speed f32, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragInt3(label, v, v_speed, v_min, v_max, format, flags)
}

fn C.igDragInt4(label &i8, v &int, v_speed f32, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_int4(label &i8, v &int, v_speed f32, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragInt4(label, v, v_speed, v_min, v_max, format, flags)
}

fn C.igDragIntRange2(label &i8, v_current_min &int, v_current_max &int, v_speed f32, v_min int, v_max int, format &i8, format_max &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_int_range2(label &i8, v_current_min &int, v_current_max &int, v_speed f32, v_min int, v_max int, format &i8, format_max &i8, flags ImGuiSliderFlags) bool {
	return C.igDragIntRange2(label, v_current_min, v_current_max, v_speed, v_min, v_max,
		format, format_max, flags)
}

fn C.igDragScalar(label &i8, data_type ImGuiDataType, p_data voidptr, v_speed f32, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_scalar(label &i8, data_type ImGuiDataType, p_data voidptr, v_speed f32, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragScalar(label, data_type, p_data, v_speed, p_min, p_max, format, flags)
}

fn C.igDragScalarN(label &i8, data_type ImGuiDataType, p_data voidptr, components int, v_speed f32, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_scalar_n(label &i8, data_type ImGuiDataType, p_data voidptr, components int, v_speed f32, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragScalarN(label, data_type, p_data, components, v_speed, p_min, p_max,
		format, flags)
}

fn C.igSliderFloat(label &i8, v &f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_float(label &i8, v &f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderFloat(label, v, v_min, v_max, format, flags)
}

fn C.igSliderFloat2(label &i8, v &f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_float2(label &i8, v &f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderFloat2(label, v, v_min, v_max, format, flags)
}

fn C.igSliderFloat3(label &i8, v &f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_float3(label &i8, v &f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderFloat3(label, v, v_min, v_max, format, flags)
}

fn C.igSliderFloat4(label &i8, v &f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_float4(label &i8, v &f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderFloat4(label, v, v_min, v_max, format, flags)
}

fn C.igSliderAngle(label &i8, v_rad &f32, v_degrees_min f32, v_degrees_max f32, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_angle(label &i8, v_rad &f32, v_degrees_min f32, v_degrees_max f32, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderAngle(label, v_rad, v_degrees_min, v_degrees_max, format, flags)
}

fn C.igSliderInt(label &i8, v &int, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_int(label &i8, v &int, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderInt(label, v, v_min, v_max, format, flags)
}

fn C.igSliderInt2(label &i8, v &int, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_int2(label &i8, v &int, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderInt2(label, v, v_min, v_max, format, flags)
}

fn C.igSliderInt3(label &i8, v &int, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_int3(label &i8, v &int, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderInt3(label, v, v_min, v_max, format, flags)
}

fn C.igSliderInt4(label &i8, v &int, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_int4(label &i8, v &int, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderInt4(label, v, v_min, v_max, format, flags)
}

fn C.igSliderScalar(label &i8, data_type ImGuiDataType, p_data voidptr, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_scalar(label &i8, data_type ImGuiDataType, p_data voidptr, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderScalar(label, data_type, p_data, p_min, p_max, format, flags)
}

fn C.igSliderScalarN(label &i8, data_type ImGuiDataType, p_data voidptr, components int, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_slider_scalar_n(label &i8, data_type ImGuiDataType, p_data voidptr, components int, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool {
	return C.igSliderScalarN(label, data_type, p_data, components, p_min, p_max, format,
		flags)
}

fn C.igVSliderFloat(label &i8, size C.ImVec2, v &f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_vs_lider_float(label &i8, size C.ImVec2, v &f32, v_min f32, v_max f32, format &i8, flags ImGuiSliderFlags) bool {
	return C.igVSliderFloat(label, size, v, v_min, v_max, format, flags)
}

fn C.igVSliderInt(label &i8, size C.ImVec2, v &int, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_vs_lider_int(label &i8, size C.ImVec2, v &int, v_min int, v_max int, format &i8, flags ImGuiSliderFlags) bool {
	return C.igVSliderInt(label, size, v, v_min, v_max, format, flags)
}

fn C.igVSliderScalar(label &i8, size C.ImVec2, data_type ImGuiDataType, p_data voidptr, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_vs_lider_scalar(label &i8, size C.ImVec2, data_type ImGuiDataType, p_data voidptr, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool {
	return C.igVSliderScalar(label, size, data_type, p_data, p_min, p_max, format, flags)
}

fn C.igInputText(label &i8, buf &i8, buf_size usize, flags ImGuiInputTextFlags, callback ImGuiInputTextCallback, user_data voidptr) bool

pub fn ig_input_text(label &i8, buf &i8, buf_size usize, flags ImGuiInputTextFlags, callback ImGuiInputTextCallback, user_data voidptr) bool {
	return C.igInputText(label, buf, buf_size, flags, callback, user_data)
}

fn C.igInputTextMultiline(label &i8, buf &i8, buf_size usize, size C.ImVec2, flags ImGuiInputTextFlags, callback ImGuiInputTextCallback, user_data voidptr) bool

pub fn ig_input_text_multiline(label &i8, buf &i8, buf_size usize, size C.ImVec2, flags ImGuiInputTextFlags, callback ImGuiInputTextCallback, user_data voidptr) bool {
	return C.igInputTextMultiline(label, buf, buf_size, size, flags, callback, user_data)
}

fn C.igInputTextWithHint(label &i8, hint &i8, buf &i8, buf_size usize, flags ImGuiInputTextFlags, callback ImGuiInputTextCallback, user_data voidptr) bool

pub fn ig_input_text_with_hint(label &i8, hint &i8, buf &i8, buf_size usize, flags ImGuiInputTextFlags, callback ImGuiInputTextCallback, user_data voidptr) bool {
	return C.igInputTextWithHint(label, hint, buf, buf_size, flags, callback, user_data)
}

fn C.igInputFloat(label &i8, v &f32, step f32, step_fast f32, format &i8, flags ImGuiInputTextFlags) bool

pub fn ig_input_float(label &i8, v &f32, step f32, step_fast f32, format &i8, flags ImGuiInputTextFlags) bool {
	return C.igInputFloat(label, v, step, step_fast, format, flags)
}

fn C.igInputFloat2(label &i8, v &f32, format &i8, flags ImGuiInputTextFlags) bool

pub fn ig_input_float2(label &i8, v &f32, format &i8, flags ImGuiInputTextFlags) bool {
	return C.igInputFloat2(label, v, format, flags)
}

fn C.igInputFloat3(label &i8, v &f32, format &i8, flags ImGuiInputTextFlags) bool

pub fn ig_input_float3(label &i8, v &f32, format &i8, flags ImGuiInputTextFlags) bool {
	return C.igInputFloat3(label, v, format, flags)
}

fn C.igInputFloat4(label &i8, v &f32, format &i8, flags ImGuiInputTextFlags) bool

pub fn ig_input_float4(label &i8, v &f32, format &i8, flags ImGuiInputTextFlags) bool {
	return C.igInputFloat4(label, v, format, flags)
}

fn C.igInputInt(label &i8, v &int, step int, step_fast int, flags ImGuiInputTextFlags) bool

pub fn ig_input_int(label &i8, v &int, step int, step_fast int, flags ImGuiInputTextFlags) bool {
	return C.igInputInt(label, v, step, step_fast, flags)
}

fn C.igInputInt2(label &i8, v &int, flags ImGuiInputTextFlags) bool

pub fn ig_input_int2(label &i8, v &int, flags ImGuiInputTextFlags) bool {
	return C.igInputInt2(label, v, flags)
}

fn C.igInputInt3(label &i8, v &int, flags ImGuiInputTextFlags) bool

pub fn ig_input_int3(label &i8, v &int, flags ImGuiInputTextFlags) bool {
	return C.igInputInt3(label, v, flags)
}

fn C.igInputInt4(label &i8, v &int, flags ImGuiInputTextFlags) bool

pub fn ig_input_int4(label &i8, v &int, flags ImGuiInputTextFlags) bool {
	return C.igInputInt4(label, v, flags)
}

fn C.igInputDouble(label &i8, v &f64, step f64, step_fast f64, format &i8, flags ImGuiInputTextFlags) bool

pub fn ig_input_double(label &i8, v &f64, step f64, step_fast f64, format &i8, flags ImGuiInputTextFlags) bool {
	return C.igInputDouble(label, v, step, step_fast, format, flags)
}

fn C.igInputScalar(label &i8, data_type ImGuiDataType, p_data voidptr, p_step voidptr, p_step_fast voidptr, format &i8, flags ImGuiInputTextFlags) bool

pub fn ig_input_scalar(label &i8, data_type ImGuiDataType, p_data voidptr, p_step voidptr, p_step_fast voidptr, format &i8, flags ImGuiInputTextFlags) bool {
	return C.igInputScalar(label, data_type, p_data, p_step, p_step_fast, format, flags)
}

fn C.igInputScalarN(label &i8, data_type ImGuiDataType, p_data voidptr, components int, p_step voidptr, p_step_fast voidptr, format &i8, flags ImGuiInputTextFlags) bool

pub fn ig_input_scalar_n(label &i8, data_type ImGuiDataType, p_data voidptr, components int, p_step voidptr, p_step_fast voidptr, format &i8, flags ImGuiInputTextFlags) bool {
	return C.igInputScalarN(label, data_type, p_data, components, p_step, p_step_fast,
		format, flags)
}

fn C.igColorEdit3(label &i8, col &f32, flags ImGuiColorEditFlags) bool

pub fn ig_color_edit3(label &i8, col &f32, flags ImGuiColorEditFlags) bool {
	return C.igColorEdit3(label, col, flags)
}

fn C.igColorEdit4(label &i8, col &f32, flags ImGuiColorEditFlags) bool

pub fn ig_color_edit4(label &i8, col &f32, flags ImGuiColorEditFlags) bool {
	return C.igColorEdit4(label, col, flags)
}

fn C.igColorPicker3(label &i8, col &f32, flags ImGuiColorEditFlags) bool

pub fn ig_color_picker3(label &i8, col &f32, flags ImGuiColorEditFlags) bool {
	return C.igColorPicker3(label, col, flags)
}

fn C.igColorPicker4(label &i8, col &f32, flags ImGuiColorEditFlags, ref_col &f32) bool

pub fn ig_color_picker4(label &i8, col &f32, flags ImGuiColorEditFlags, ref_col &f32) bool {
	return C.igColorPicker4(label, col, flags, ref_col)
}

fn C.igColorButton(desc_id &i8, col C.ImVec4, flags ImGuiColorEditFlags, size C.ImVec2) bool

pub fn ig_color_button(desc_id &i8, col C.ImVec4, flags ImGuiColorEditFlags, size C.ImVec2) bool {
	return C.igColorButton(desc_id, col, flags, size)
}

fn C.igSetColorEditOptions(flags ImGuiColorEditFlags)

pub fn ig_set_color_edit_options(flags ImGuiColorEditFlags) {
	C.igSetColorEditOptions(flags)
}

fn C.igTreeNode_Str(label &i8) bool

pub fn ig_tree_node_str(label &i8) bool {
	return C.igTreeNode_Str(label)
}

@[c2v_variadic]
fn C.igTreeNode_StrStr(str_id &i8, fmt ...&i8) bool

pub fn ig_tree_node_str_str(str_id &i8, fmt &i8) bool {
	return C.igTreeNode_StrStr(str_id, fmt)
}

@[c2v_variadic]
fn C.igTreeNode_Ptr(ptr_id voidptr, fmt ...&i8) bool

pub fn ig_tree_node_ptr(ptr_id voidptr, fmt &i8) bool {
	return C.igTreeNode_Ptr(ptr_id, fmt)
}

fn C.igTreeNodeV_Str(str_id &i8, fmt &i8, args C.va_list) bool

pub fn ig_tree_node_v_str(str_id &i8, fmt &i8, args C.va_list) bool {
	return C.igTreeNodeV_Str(str_id, fmt, args)
}

fn C.igTreeNodeV_Ptr(ptr_id voidptr, fmt &i8, args C.va_list) bool

pub fn ig_tree_node_v_ptr(ptr_id voidptr, fmt &i8, args C.va_list) bool {
	return C.igTreeNodeV_Ptr(ptr_id, fmt, args)
}

fn C.igTreeNodeEx_Str(label &i8, flags ImGuiTreeNodeFlags) bool

pub fn ig_tree_node_ex_str(label &i8, flags ImGuiTreeNodeFlags) bool {
	return C.igTreeNodeEx_Str(label, flags)
}

@[c2v_variadic]
fn C.igTreeNodeEx_StrStr(str_id &i8, flags ImGuiTreeNodeFlags, fmt ...&i8) bool

pub fn ig_tree_node_ex_str_str(str_id &i8, flags ImGuiTreeNodeFlags, fmt &i8) bool {
	return C.igTreeNodeEx_StrStr(str_id, flags, fmt)
}

@[c2v_variadic]
fn C.igTreeNodeEx_Ptr(ptr_id voidptr, flags ImGuiTreeNodeFlags, fmt ...&i8) bool

pub fn ig_tree_node_ex_ptr(ptr_id voidptr, flags ImGuiTreeNodeFlags, fmt &i8) bool {
	return C.igTreeNodeEx_Ptr(ptr_id, flags, fmt)
}

fn C.igTreeNodeExV_Str(str_id &i8, flags ImGuiTreeNodeFlags, fmt &i8, args C.va_list) bool

pub fn ig_tree_node_ex_v_str(str_id &i8, flags ImGuiTreeNodeFlags, fmt &i8, args C.va_list) bool {
	return C.igTreeNodeExV_Str(str_id, flags, fmt, args)
}

fn C.igTreeNodeExV_Ptr(ptr_id voidptr, flags ImGuiTreeNodeFlags, fmt &i8, args C.va_list) bool

pub fn ig_tree_node_ex_v_ptr(ptr_id voidptr, flags ImGuiTreeNodeFlags, fmt &i8, args C.va_list) bool {
	return C.igTreeNodeExV_Ptr(ptr_id, flags, fmt, args)
}

fn C.igTreePush_Str(str_id &i8)

pub fn ig_tree_push_str(str_id &i8) {
	C.igTreePush_Str(str_id)
}

fn C.igTreePush_Ptr(ptr_id voidptr)

pub fn ig_tree_push_ptr(ptr_id voidptr) {
	C.igTreePush_Ptr(ptr_id)
}

fn C.igTreePop()

pub fn ig_tree_pop() {
	C.igTreePop()
}

fn C.igGetTreeNodeToLabelSpacing() f32

pub fn ig_get_tree_node_to_label_spacing() f32 {
	return C.igGetTreeNodeToLabelSpacing()
}

fn C.igCollapsingHeader_TreeNodeFlags(label &i8, flags ImGuiTreeNodeFlags) bool

pub fn ig_collapsing_header_tree_node_flags(label &i8, flags ImGuiTreeNodeFlags) bool {
	return C.igCollapsingHeader_TreeNodeFlags(label, flags)
}

fn C.igCollapsingHeader_BoolPtr(label &i8, p_visible &bool, flags ImGuiTreeNodeFlags) bool

pub fn ig_collapsing_header_bool_ptr(label &i8, p_visible &bool, flags ImGuiTreeNodeFlags) bool {
	return C.igCollapsingHeader_BoolPtr(label, p_visible, flags)
}

fn C.igSetNextItemOpen(is_open bool, cond ImGuiCond)

pub fn ig_set_next_item_open(is_open bool, cond ImGuiCond) {
	C.igSetNextItemOpen(is_open, cond)
}

fn C.igSetNextItemStorageID(storage_id ImGuiID)

pub fn ig_set_next_item_storage_id(storage_id ImGuiID) {
	C.igSetNextItemStorageID(storage_id)
}

fn C.igSelectable_Bool(label &i8, selected bool, flags ImGuiSelectableFlags, size C.ImVec2) bool

pub fn ig_selectable_bool(label &i8, selected bool, flags ImGuiSelectableFlags, size C.ImVec2) bool {
	return C.igSelectable_Bool(label, selected, flags, size)
}

fn C.igSelectable_BoolPtr(label &i8, p_selected &bool, flags ImGuiSelectableFlags, size C.ImVec2) bool

pub fn ig_selectable_bool_ptr(label &i8, p_selected &bool, flags ImGuiSelectableFlags, size C.ImVec2) bool {
	return C.igSelectable_BoolPtr(label, p_selected, flags, size)
}

fn C.igBeginMultiSelect(flags ImGuiMultiSelectFlags, selection_size int, items_count int) &C.ImGuiMultiSelectIO

pub fn ig_begin_multi_select(flags ImGuiMultiSelectFlags, selection_size int, items_count int) &C.ImGuiMultiSelectIO {
	return C.igBeginMultiSelect(flags, selection_size, items_count)
}

fn C.igEndMultiSelect() &C.ImGuiMultiSelectIO

pub fn ig_end_multi_select() &C.ImGuiMultiSelectIO {
	return C.igEndMultiSelect()
}

fn C.igSetNextItemSelectionUserData(selection_user_data ImGuiSelectionUserData)

pub fn ig_set_next_item_selection_user_data(selection_user_data ImGuiSelectionUserData) {
	C.igSetNextItemSelectionUserData(selection_user_data)
}

fn C.igIsItemToggledSelection() bool

pub fn ig_is_item_toggled_selection() bool {
	return C.igIsItemToggledSelection()
}

fn C.igBeginListBox(label &i8, size C.ImVec2) bool

pub fn ig_begin_list_box(label &i8, size C.ImVec2) bool {
	return C.igBeginListBox(label, size)
}

fn C.igEndListBox()

pub fn ig_end_list_box() {
	C.igEndListBox()
}

fn C.igListBox_Str_arr(label &i8, current_item &int, items &&u8, items_count int, height_in_items int) bool

pub fn ig_list_box_str_arr(label &i8, current_item &int, items &&u8, items_count int, height_in_items int) bool {
	return C.igListBox_Str_arr(label, current_item, items, items_count, height_in_items)
}

fn C.igListBox_FnStrPtr(label &i8, current_item &int, getter fn (voidptr, int) &i8, user_data voidptr, items_count int, height_in_items int) bool

pub fn ig_list_box_fn_str_ptr(label &i8, current_item &int, getter fn (voidptr, int) &i8, user_data voidptr, items_count int, height_in_items int) bool {
	return C.igListBox_FnStrPtr(label, current_item, getter, user_data, items_count, height_in_items)
}

fn C.igPlotLines_FloatPtr(label &i8, values &f32, values_count int, values_offset int, overlay_text &i8, scale_min f32, scale_max f32, graph_size C.ImVec2, stride int)

pub fn ig_plot_lines_float_ptr(label &i8, values &f32, values_count int, values_offset int, overlay_text &i8, scale_min f32, scale_max f32, graph_size C.ImVec2, stride int) {
	C.igPlotLines_FloatPtr(label, values, values_count, values_offset, overlay_text, scale_min,
		scale_max, graph_size, stride)
}

fn C.igPlotLines_FnFloatPtr(label &i8, values_getter fn (voidptr, int) f32, data voidptr, values_count int, values_offset int, overlay_text &i8, scale_min f32, scale_max f32, graph_size C.ImVec2)

pub fn ig_plot_lines_fn_float_ptr(label &i8, values_getter fn (voidptr, int) f32, data voidptr, values_count int, values_offset int, overlay_text &i8, scale_min f32, scale_max f32, graph_size C.ImVec2) {
	C.igPlotLines_FnFloatPtr(label, values_getter, data, values_count, values_offset,
		overlay_text, scale_min, scale_max, graph_size)
}

fn C.igPlotHistogram_FloatPtr(label &i8, values &f32, values_count int, values_offset int, overlay_text &i8, scale_min f32, scale_max f32, graph_size C.ImVec2, stride int)

pub fn ig_plot_histogram_float_ptr(label &i8, values &f32, values_count int, values_offset int, overlay_text &i8, scale_min f32, scale_max f32, graph_size C.ImVec2, stride int) {
	C.igPlotHistogram_FloatPtr(label, values, values_count, values_offset, overlay_text,
		scale_min, scale_max, graph_size, stride)
}

fn C.igPlotHistogram_FnFloatPtr(label &i8, values_getter fn (voidptr, int) f32, data voidptr, values_count int, values_offset int, overlay_text &i8, scale_min f32, scale_max f32, graph_size C.ImVec2)

pub fn ig_plot_histogram_fn_float_ptr(label &i8, values_getter fn (voidptr, int) f32, data voidptr, values_count int, values_offset int, overlay_text &i8, scale_min f32, scale_max f32, graph_size C.ImVec2) {
	C.igPlotHistogram_FnFloatPtr(label, values_getter, data, values_count, values_offset,
		overlay_text, scale_min, scale_max, graph_size)
}

fn C.igValue_Bool(prefix &i8, b bool)

pub fn ig_value_bool(prefix &i8, b bool) {
	C.igValue_Bool(prefix, b)
}

fn C.igValue_Int(prefix &i8, v int)

pub fn ig_value_int(prefix &i8, v int) {
	C.igValue_Int(prefix, v)
}

fn C.igValue_Uint(prefix &i8, v u32)

pub fn ig_value_uint(prefix &i8, v u32) {
	C.igValue_Uint(prefix, v)
}

fn C.igValue_Float(prefix &i8, v f32, float_format &i8)

pub fn ig_value_float(prefix &i8, v f32, float_format &i8) {
	C.igValue_Float(prefix, v, float_format)
}

fn C.igBeginMenuBar() bool

pub fn ig_begin_menu_bar() bool {
	return C.igBeginMenuBar()
}

fn C.igEndMenuBar()

pub fn ig_end_menu_bar() {
	C.igEndMenuBar()
}

fn C.igBeginMainMenuBar() bool

pub fn ig_begin_main_menu_bar() bool {
	return C.igBeginMainMenuBar()
}

fn C.igEndMainMenuBar()

pub fn ig_end_main_menu_bar() {
	C.igEndMainMenuBar()
}

fn C.igBeginMenu(label &i8, enabled bool) bool

pub fn ig_begin_menu(label &i8, enabled bool) bool {
	return C.igBeginMenu(label, enabled)
}

fn C.igEndMenu()

pub fn ig_end_menu() {
	C.igEndMenu()
}

fn C.igMenuItem_Bool(label &i8, shortcut &i8, selected bool, enabled bool) bool

pub fn ig_menu_item_bool(label &i8, shortcut &i8, selected bool, enabled bool) bool {
	return C.igMenuItem_Bool(label, shortcut, selected, enabled)
}

fn C.igMenuItem_BoolPtr(label &i8, shortcut &i8, p_selected &bool, enabled bool) bool

pub fn ig_menu_item_bool_ptr(label &i8, shortcut &i8, p_selected &bool, enabled bool) bool {
	return C.igMenuItem_BoolPtr(label, shortcut, p_selected, enabled)
}

fn C.igBeginTooltip() bool

pub fn ig_begin_tooltip() bool {
	return C.igBeginTooltip()
}

fn C.igEndTooltip()

pub fn ig_end_tooltip() {
	C.igEndTooltip()
}

@[c2v_variadic]
fn C.igSetTooltip(fmt ...&i8)

pub fn ig_set_tooltip(fmt &i8) {
	C.igSetTooltip(fmt)
}

fn C.igSetTooltipV(fmt &i8, args C.va_list)

pub fn ig_set_tooltip_v(fmt &i8, args C.va_list) {
	C.igSetTooltipV(fmt, args)
}

fn C.igBeginItemTooltip() bool

pub fn ig_begin_item_tooltip() bool {
	return C.igBeginItemTooltip()
}

@[c2v_variadic]
fn C.igSetItemTooltip(fmt ...&i8)

pub fn ig_set_item_tooltip(fmt &i8) {
	C.igSetItemTooltip(fmt)
}

fn C.igSetItemTooltipV(fmt &i8, args C.va_list)

pub fn ig_set_item_tooltip_v(fmt &i8, args C.va_list) {
	C.igSetItemTooltipV(fmt, args)
}

fn C.igBeginPopup(str_id &i8, flags ImGuiWindowFlags) bool

pub fn ig_begin_popup(str_id &i8, flags ImGuiWindowFlags) bool {
	return C.igBeginPopup(str_id, flags)
}

fn C.igBeginPopupModal(name &i8, p_open &bool, flags ImGuiWindowFlags) bool

pub fn ig_begin_popup_modal(name &i8, p_open &bool, flags ImGuiWindowFlags) bool {
	return C.igBeginPopupModal(name, p_open, flags)
}

fn C.igEndPopup()

pub fn ig_end_popup() {
	C.igEndPopup()
}

fn C.igOpenPopup_Str(str_id &i8, popup_flags ImGuiPopupFlags)

pub fn ig_open_popup_str(str_id &i8, popup_flags ImGuiPopupFlags) {
	C.igOpenPopup_Str(str_id, popup_flags)
}

fn C.igOpenPopup_ID(id ImGuiID, popup_flags ImGuiPopupFlags)

pub fn ig_open_popup_id(id ImGuiID, popup_flags ImGuiPopupFlags) {
	C.igOpenPopup_ID(id, popup_flags)
}

fn C.igOpenPopupOnItemClick(str_id &i8, popup_flags ImGuiPopupFlags)

pub fn ig_open_popup_on_item_click(str_id &i8, popup_flags ImGuiPopupFlags) {
	C.igOpenPopupOnItemClick(str_id, popup_flags)
}

fn C.igCloseCurrentPopup()

pub fn ig_close_current_popup() {
	C.igCloseCurrentPopup()
}

fn C.igBeginPopupContextItem(str_id &i8, popup_flags ImGuiPopupFlags) bool

pub fn ig_begin_popup_context_item(str_id &i8, popup_flags ImGuiPopupFlags) bool {
	return C.igBeginPopupContextItem(str_id, popup_flags)
}

fn C.igBeginPopupContextWindow(str_id &i8, popup_flags ImGuiPopupFlags) bool

pub fn ig_begin_popup_context_window(str_id &i8, popup_flags ImGuiPopupFlags) bool {
	return C.igBeginPopupContextWindow(str_id, popup_flags)
}

fn C.igBeginPopupContextVoid(str_id &i8, popup_flags ImGuiPopupFlags) bool

pub fn ig_begin_popup_context_void(str_id &i8, popup_flags ImGuiPopupFlags) bool {
	return C.igBeginPopupContextVoid(str_id, popup_flags)
}

fn C.igIsPopupOpen_Str(str_id &i8, flags ImGuiPopupFlags) bool

pub fn ig_is_popup_open_str(str_id &i8, flags ImGuiPopupFlags) bool {
	return C.igIsPopupOpen_Str(str_id, flags)
}

fn C.igBeginTable(str_id &i8, columns int, flags ImGuiTableFlags, outer_size C.ImVec2, inner_width f32) bool

pub fn ig_begin_table(str_id &i8, columns int, flags ImGuiTableFlags, outer_size C.ImVec2, inner_width f32) bool {
	return C.igBeginTable(str_id, columns, flags, outer_size, inner_width)
}

fn C.igEndTable()

pub fn ig_end_table() {
	C.igEndTable()
}

fn C.igTableNextRow(row_flags ImGuiTableRowFlags, min_row_height f32)

pub fn ig_table_next_row(row_flags ImGuiTableRowFlags, min_row_height f32) {
	C.igTableNextRow(row_flags, min_row_height)
}

fn C.igTableNextColumn() bool

pub fn ig_table_next_column() bool {
	return C.igTableNextColumn()
}

fn C.igTableSetColumnIndex(column_n int) bool

pub fn ig_table_set_column_index(column_n int) bool {
	return C.igTableSetColumnIndex(column_n)
}

fn C.igTableSetupColumn(label &i8, flags ImGuiTableColumnFlags, init_width_or_weight f32, user_id ImGuiID)

pub fn ig_table_setup_column(label &i8, flags ImGuiTableColumnFlags, init_width_or_weight f32, user_id ImGuiID) {
	C.igTableSetupColumn(label, flags, init_width_or_weight, user_id)
}

fn C.igTableSetupScrollFreeze(cols int, rows int)

pub fn ig_table_setup_scroll_freeze(cols int, rows int) {
	C.igTableSetupScrollFreeze(cols, rows)
}

fn C.igTableHeader(label &i8)

pub fn ig_table_header(label &i8) {
	C.igTableHeader(label)
}

fn C.igTableHeadersRow()

pub fn ig_table_headers_row() {
	C.igTableHeadersRow()
}

fn C.igTableAngledHeadersRow()

pub fn ig_table_angled_headers_row() {
	C.igTableAngledHeadersRow()
}

fn C.igTableGetSortSpecs() &C.ImGuiTableSortSpecs

pub fn ig_table_get_sort_specs() &C.ImGuiTableSortSpecs {
	return C.igTableGetSortSpecs()
}

fn C.igTableGetColumnCount() int

pub fn ig_table_get_column_count() int {
	return C.igTableGetColumnCount()
}

fn C.igTableGetColumnIndex() int

pub fn ig_table_get_column_index() int {
	return C.igTableGetColumnIndex()
}

fn C.igTableGetRowIndex() int

pub fn ig_table_get_row_index() int {
	return C.igTableGetRowIndex()
}

fn C.igTableGetColumnName_Int(column_n int) &i8

pub fn ig_table_get_column_name_int(column_n int) &i8 {
	return C.igTableGetColumnName_Int(column_n)
}

fn C.igTableGetColumnFlags(column_n int) ImGuiTableColumnFlags

pub fn ig_table_get_column_flags(column_n int) ImGuiTableColumnFlags {
	return C.igTableGetColumnFlags(column_n)
}

fn C.igTableSetColumnEnabled(column_n int, v bool)

pub fn ig_table_set_column_enabled(column_n int, v bool) {
	C.igTableSetColumnEnabled(column_n, v)
}

fn C.igTableGetHoveredColumn() int

pub fn ig_table_get_hovered_column() int {
	return C.igTableGetHoveredColumn()
}

fn C.igTableSetBgColor(target ImGuiTableBgTarget, color ImU32, column_n int)

pub fn ig_table_set_bg_color(target ImGuiTableBgTarget, color ImU32, column_n int) {
	C.igTableSetBgColor(target, color, column_n)
}

fn C.igColumns(count int, id &i8, borders bool)

pub fn ig_columns(count int, id &i8, borders bool) {
	C.igColumns(count, id, borders)
}

fn C.igNextColumn()

pub fn ig_next_column() {
	C.igNextColumn()
}

fn C.igGetColumnIndex() int

pub fn ig_get_column_index() int {
	return C.igGetColumnIndex()
}

fn C.igGetColumnWidth(column_index int) f32

pub fn ig_get_column_width(column_index int) f32 {
	return C.igGetColumnWidth(column_index)
}

fn C.igSetColumnWidth(column_index int, width f32)

pub fn ig_set_column_width(column_index int, width f32) {
	C.igSetColumnWidth(column_index, width)
}

fn C.igGetColumnOffset(column_index int) f32

pub fn ig_get_column_offset(column_index int) f32 {
	return C.igGetColumnOffset(column_index)
}

fn C.igSetColumnOffset(column_index int, offset_x f32)

pub fn ig_set_column_offset(column_index int, offset_x f32) {
	C.igSetColumnOffset(column_index, offset_x)
}

fn C.igGetColumnsCount() int

pub fn ig_get_columns_count() int {
	return C.igGetColumnsCount()
}

fn C.igBeginTabBar(str_id &i8, flags ImGuiTabBarFlags) bool

pub fn ig_begin_tab_bar(str_id &i8, flags ImGuiTabBarFlags) bool {
	return C.igBeginTabBar(str_id, flags)
}

fn C.igEndTabBar()

pub fn ig_end_tab_bar() {
	C.igEndTabBar()
}

fn C.igBeginTabItem(label &i8, p_open &bool, flags ImGuiTabItemFlags) bool

pub fn ig_begin_tab_item(label &i8, p_open &bool, flags ImGuiTabItemFlags) bool {
	return C.igBeginTabItem(label, p_open, flags)
}

fn C.igEndTabItem()

pub fn ig_end_tab_item() {
	C.igEndTabItem()
}

fn C.igTabItemButton(label &i8, flags ImGuiTabItemFlags) bool

pub fn ig_tab_item_button(label &i8, flags ImGuiTabItemFlags) bool {
	return C.igTabItemButton(label, flags)
}

fn C.igSetTabItemClosed(tab_or_docked_window_label &i8)

pub fn ig_set_tab_item_closed(tab_or_docked_window_label &i8) {
	C.igSetTabItemClosed(tab_or_docked_window_label)
}

fn C.igDockSpace(dockspace_id ImGuiID, size C.ImVec2, flags ImGuiDockNodeFlags, window_class &C.ImGuiWindowClass) ImGuiID

pub fn ig_dock_space(dockspace_id ImGuiID, size C.ImVec2, flags ImGuiDockNodeFlags, window_class &C.ImGuiWindowClass) ImGuiID {
	return C.igDockSpace(dockspace_id, size, flags, window_class)
}

fn C.igDockSpaceOverViewport(dockspace_id ImGuiID, viewport &C.ImGuiViewport, flags ImGuiDockNodeFlags, window_class &C.ImGuiWindowClass) ImGuiID

pub fn ig_dock_space_over_viewport(dockspace_id ImGuiID, viewport &C.ImGuiViewport, flags ImGuiDockNodeFlags, window_class &C.ImGuiWindowClass) ImGuiID {
	return C.igDockSpaceOverViewport(dockspace_id, viewport, flags, window_class)
}

fn C.igSetNextWindowDockID(dock_id ImGuiID, cond ImGuiCond)

pub fn ig_set_next_window_dock_id(dock_id ImGuiID, cond ImGuiCond) {
	C.igSetNextWindowDockID(dock_id, cond)
}

fn C.igSetNextWindowClass(window_class &C.ImGuiWindowClass)

pub fn ig_set_next_window_class(window_class &C.ImGuiWindowClass) {
	C.igSetNextWindowClass(window_class)
}

fn C.igGetWindowDockID() ImGuiID

pub fn ig_get_window_dock_id() ImGuiID {
	return C.igGetWindowDockID()
}

fn C.igIsWindowDocked() bool

pub fn ig_is_window_docked() bool {
	return C.igIsWindowDocked()
}

fn C.igLogToTTY(auto_open_depth int)

pub fn ig_log_to_tty(auto_open_depth int) {
	C.igLogToTTY(auto_open_depth)
}

fn C.igLogToFile(auto_open_depth int, filename &i8)

pub fn ig_log_to_file(auto_open_depth int, filename &i8) {
	C.igLogToFile(auto_open_depth, filename)
}

fn C.igLogToClipboard(auto_open_depth int)

pub fn ig_log_to_clipboard(auto_open_depth int) {
	C.igLogToClipboard(auto_open_depth)
}

fn C.igLogFinish()

pub fn ig_log_finish() {
	C.igLogFinish()
}

fn C.igLogButtons()

pub fn ig_log_buttons() {
	C.igLogButtons()
}

fn C.igLogTextV(fmt &i8, args C.va_list)

pub fn ig_log_text_v(fmt &i8, args C.va_list) {
	C.igLogTextV(fmt, args)
}

fn C.igBeginDragDropSource(flags ImGuiDragDropFlags) bool

pub fn ig_begin_drag_drop_source(flags ImGuiDragDropFlags) bool {
	return C.igBeginDragDropSource(flags)
}

fn C.igSetDragDropPayload(type_ &i8, data voidptr, sz usize, cond ImGuiCond) bool

pub fn ig_set_drag_drop_payload(type_ &i8, data voidptr, sz usize, cond ImGuiCond) bool {
	return C.igSetDragDropPayload(type_, data, sz, cond)
}

fn C.igEndDragDropSource()

pub fn ig_end_drag_drop_source() {
	C.igEndDragDropSource()
}

fn C.igBeginDragDropTarget() bool

pub fn ig_begin_drag_drop_target() bool {
	return C.igBeginDragDropTarget()
}

fn C.igAcceptDragDropPayload(type_ &i8, flags ImGuiDragDropFlags) &C.ImGuiPayload

pub fn ig_accept_drag_drop_payload(type_ &i8, flags ImGuiDragDropFlags) &C.ImGuiPayload {
	return C.igAcceptDragDropPayload(type_, flags)
}

fn C.igEndDragDropTarget()

pub fn ig_end_drag_drop_target() {
	C.igEndDragDropTarget()
}

fn C.igGetDragDropPayload() &C.ImGuiPayload

pub fn ig_get_drag_drop_payload() &C.ImGuiPayload {
	return C.igGetDragDropPayload()
}

fn C.igBeginDisabled(disabled bool)

pub fn ig_begin_disabled(disabled bool) {
	C.igBeginDisabled(disabled)
}

fn C.igEndDisabled()

pub fn ig_end_disabled() {
	C.igEndDisabled()
}

fn C.igPushClipRect(clip_rect_min C.ImVec2, clip_rect_max C.ImVec2, intersect_with_current_clip_rect bool)

pub fn ig_push_clip_rect(clip_rect_min C.ImVec2, clip_rect_max C.ImVec2, intersect_with_current_clip_rect bool) {
	C.igPushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect)
}

fn C.igPopClipRect()

pub fn ig_pop_clip_rect() {
	C.igPopClipRect()
}

fn C.igSetItemDefaultFocus()

pub fn ig_set_item_default_focus() {
	C.igSetItemDefaultFocus()
}

fn C.igSetKeyboardFocusHere(offset int)

pub fn ig_set_keyboard_focus_here(offset int) {
	C.igSetKeyboardFocusHere(offset)
}

fn C.igSetNextItemAllowOverlap()

pub fn ig_set_next_item_allow_overlap() {
	C.igSetNextItemAllowOverlap()
}

fn C.igIsItemHovered(flags ImGuiHoveredFlags) bool

pub fn ig_is_item_hovered(flags ImGuiHoveredFlags) bool {
	return C.igIsItemHovered(flags)
}

fn C.igIsItemActive() bool

pub fn ig_is_item_active() bool {
	return C.igIsItemActive()
}

fn C.igIsItemFocused() bool

pub fn ig_is_item_focused() bool {
	return C.igIsItemFocused()
}

fn C.igIsItemClicked(mouse_button ImGuiMouseButton) bool

pub fn ig_is_item_clicked(mouse_button ImGuiMouseButton) bool {
	return C.igIsItemClicked(mouse_button)
}

fn C.igIsItemVisible() bool

pub fn ig_is_item_visible() bool {
	return C.igIsItemVisible()
}

fn C.igIsItemEdited() bool

pub fn ig_is_item_edited() bool {
	return C.igIsItemEdited()
}

fn C.igIsItemActivated() bool

pub fn ig_is_item_activated() bool {
	return C.igIsItemActivated()
}

fn C.igIsItemDeactivated() bool

pub fn ig_is_item_deactivated() bool {
	return C.igIsItemDeactivated()
}

fn C.igIsItemDeactivatedAfterEdit() bool

pub fn ig_is_item_deactivated_after_edit() bool {
	return C.igIsItemDeactivatedAfterEdit()
}

fn C.igIsItemToggledOpen() bool

pub fn ig_is_item_toggled_open() bool {
	return C.igIsItemToggledOpen()
}

fn C.igIsAnyItemHovered() bool

pub fn ig_is_any_item_hovered() bool {
	return C.igIsAnyItemHovered()
}

fn C.igIsAnyItemActive() bool

pub fn ig_is_any_item_active() bool {
	return C.igIsAnyItemActive()
}

fn C.igIsAnyItemFocused() bool

pub fn ig_is_any_item_focused() bool {
	return C.igIsAnyItemFocused()
}

fn C.igGetItemID() ImGuiID

pub fn ig_get_item_id() ImGuiID {
	return C.igGetItemID()
}

fn C.igGetItemRectMin(p_out &C.ImVec2)

pub fn ig_get_item_rect_min(p_out &C.ImVec2) {
	C.igGetItemRectMin(p_out)
}

fn C.igGetItemRectMax(p_out &C.ImVec2)

pub fn ig_get_item_rect_max(p_out &C.ImVec2) {
	C.igGetItemRectMax(p_out)
}

fn C.igGetItemRectSize(p_out &C.ImVec2)

pub fn ig_get_item_rect_size(p_out &C.ImVec2) {
	C.igGetItemRectSize(p_out)
}

fn C.igGetMainViewport() &C.ImGuiViewport

pub fn ig_get_main_viewport() &C.ImGuiViewport {
	return C.igGetMainViewport()
}

fn C.igGetBackgroundDrawList(viewport &C.ImGuiViewport) &C.ImDrawList

pub fn ig_get_background_draw_list(viewport &C.ImGuiViewport) &C.ImDrawList {
	return C.igGetBackgroundDrawList(viewport)
}

fn C.igGetForegroundDrawList_ViewportPtr(viewport &C.ImGuiViewport) &C.ImDrawList

pub fn ig_get_foreground_draw_list_viewport_ptr(viewport &C.ImGuiViewport) &C.ImDrawList {
	return C.igGetForegroundDrawList_ViewportPtr(viewport)
}

fn C.igIsRectVisible_Nil(size C.ImVec2) bool

pub fn ig_is_rect_visible_nil(size C.ImVec2) bool {
	return C.igIsRectVisible_Nil(size)
}

fn C.igIsRectVisible_Vec2(rect_min C.ImVec2, rect_max C.ImVec2) bool

pub fn ig_is_rect_visible_vec2(rect_min C.ImVec2, rect_max C.ImVec2) bool {
	return C.igIsRectVisible_Vec2(rect_min, rect_max)
}

fn C.igGetTime() f64

pub fn ig_get_time() f64 {
	return C.igGetTime()
}

fn C.igGetFrameCount() int

pub fn ig_get_frame_count() int {
	return C.igGetFrameCount()
}

fn C.igGetDrawListSharedData() &C.ImDrawListSharedData

pub fn ig_get_draw_list_shared_data() &C.ImDrawListSharedData {
	return C.igGetDrawListSharedData()
}

fn C.igGetStyleColorName(idx ImGuiCol) &i8

pub fn ig_get_style_color_name(idx ImGuiCol) &i8 {
	return C.igGetStyleColorName(idx)
}

fn C.igSetStateStorage(storage &C.ImGuiStorage)

pub fn ig_set_state_storage(storage &C.ImGuiStorage) {
	C.igSetStateStorage(storage)
}

fn C.igGetStateStorage() &C.ImGuiStorage

pub fn ig_get_state_storage() &C.ImGuiStorage {
	return C.igGetStateStorage()
}

fn C.igCalcTextSize(p_out &C.ImVec2, text &i8, text_end &i8, hide_text_after_double_hash bool, wrap_width f32)

pub fn ig_calc_text_size(p_out &C.ImVec2, text &i8, text_end &i8, hide_text_after_double_hash bool, wrap_width f32) {
	C.igCalcTextSize(p_out, text, text_end, hide_text_after_double_hash, wrap_width)
}

fn C.igColorConvertU32ToFloat4(p_out &C.ImVec4, in_ ImU32)

pub fn ig_color_convert_u32_to_float4(p_out &C.ImVec4, in_ ImU32) {
	C.igColorConvertU32ToFloat4(p_out, in_)
}

fn C.igColorConvertFloat4ToU32(in_ ImVec4) ImU32

pub fn ig_color_convert_float4_to_u32(in_ ImVec4) ImU32 {
	return C.igColorConvertFloat4ToU32(in_)
}

fn C.igColorConvertRGBtoHSV(r f32, g f32, b f32, out_h &f32, out_s &f32, out_v &f32)

pub fn ig_color_convert_rgb_to_hsv(r f32, g f32, b f32, out_h &f32, out_s &f32, out_v &f32) {
	C.igColorConvertRGBtoHSV(r, g, b, out_h, out_s, out_v)
}

fn C.igColorConvertHSVtoRGB(h f32, s f32, v f32, out_r &f32, out_g &f32, out_b &f32)

pub fn ig_color_convert_hsv_to_rgb(h f32, s f32, v f32, out_r &f32, out_g &f32, out_b &f32) {
	C.igColorConvertHSVtoRGB(h, s, v, out_r, out_g, out_b)
}

fn C.igIsKeyDown_Nil(key ImGuiKey) bool

pub fn ig_is_key_down_nil(key ImGuiKey) bool {
	return C.igIsKeyDown_Nil(key)
}

fn C.igIsKeyPressed_Bool(key ImGuiKey, repeat bool) bool

pub fn ig_is_key_pressed_bool(key ImGuiKey, repeat bool) bool {
	return C.igIsKeyPressed_Bool(key, repeat)
}

fn C.igIsKeyReleased_Nil(key ImGuiKey) bool

pub fn ig_is_key_released_nil(key ImGuiKey) bool {
	return C.igIsKeyReleased_Nil(key)
}

fn C.igIsKeyChordPressed_Nil(key_chord ImGuiKeyChord) bool

pub fn ig_is_key_chord_pressed_nil(key_chord ImGuiKeyChord) bool {
	return C.igIsKeyChordPressed_Nil(key_chord)
}

fn C.igGetKeyPressedAmount(key ImGuiKey, repeat_delay f32, rate f32) int

pub fn ig_get_key_pressed_amount(key ImGuiKey, repeat_delay f32, rate f32) int {
	return C.igGetKeyPressedAmount(key, repeat_delay, rate)
}

fn C.igGetKeyName(key ImGuiKey) &i8

pub fn ig_get_key_name(key ImGuiKey) &i8 {
	return C.igGetKeyName(key)
}

fn C.igSetNextFrameWantCaptureKeyboard(want_capture_keyboard bool)

pub fn ig_set_next_frame_want_capture_keyboard(want_capture_keyboard bool) {
	C.igSetNextFrameWantCaptureKeyboard(want_capture_keyboard)
}

fn C.igShortcut_Nil(key_chord ImGuiKeyChord, flags ImGuiInputFlags) bool

pub fn ig_shortcut_nil(key_chord ImGuiKeyChord, flags ImGuiInputFlags) bool {
	return C.igShortcut_Nil(key_chord, flags)
}

fn C.igSetNextItemShortcut(key_chord ImGuiKeyChord, flags ImGuiInputFlags)

pub fn ig_set_next_item_shortcut(key_chord ImGuiKeyChord, flags ImGuiInputFlags) {
	C.igSetNextItemShortcut(key_chord, flags)
}

fn C.igSetItemKeyOwner_Nil(key ImGuiKey)

pub fn ig_set_item_key_owner_nil(key ImGuiKey) {
	C.igSetItemKeyOwner_Nil(key)
}

fn C.igIsMouseDown_Nil(button ImGuiMouseButton) bool

pub fn ig_is_mouse_down_nil(button ImGuiMouseButton) bool {
	return C.igIsMouseDown_Nil(button)
}

fn C.igIsMouseClicked_Bool(button ImGuiMouseButton, repeat bool) bool

pub fn ig_is_mouse_clicked_bool(button ImGuiMouseButton, repeat bool) bool {
	return C.igIsMouseClicked_Bool(button, repeat)
}

fn C.igIsMouseReleased_Nil(button ImGuiMouseButton) bool

pub fn ig_is_mouse_released_nil(button ImGuiMouseButton) bool {
	return C.igIsMouseReleased_Nil(button)
}

fn C.igIsMouseDoubleClicked_Nil(button ImGuiMouseButton) bool

pub fn ig_is_mouse_double_clicked_nil(button ImGuiMouseButton) bool {
	return C.igIsMouseDoubleClicked_Nil(button)
}

fn C.igGetMouseClickedCount(button ImGuiMouseButton) int

pub fn ig_get_mouse_clicked_count(button ImGuiMouseButton) int {
	return C.igGetMouseClickedCount(button)
}

fn C.igIsMouseHoveringRect(r_min C.ImVec2, r_max C.ImVec2, clip bool) bool

pub fn ig_is_mouse_hovering_rect(r_min C.ImVec2, r_max C.ImVec2, clip bool) bool {
	return C.igIsMouseHoveringRect(r_min, r_max, clip)
}

fn C.igIsMousePosValid(mouse_pos &C.ImVec2) bool

pub fn ig_is_mouse_pos_valid(mouse_pos &C.ImVec2) bool {
	return C.igIsMousePosValid(mouse_pos)
}

fn C.igIsAnyMouseDown() bool

pub fn ig_is_any_mouse_down() bool {
	return C.igIsAnyMouseDown()
}

fn C.igGetMousePos(p_out &C.ImVec2)

pub fn ig_get_mouse_pos(p_out &C.ImVec2) {
	C.igGetMousePos(p_out)
}

fn C.igGetMousePosOnOpeningCurrentPopup(p_out &C.ImVec2)

pub fn ig_get_mouse_pos_on_opening_current_popup(p_out &C.ImVec2) {
	C.igGetMousePosOnOpeningCurrentPopup(p_out)
}

fn C.igIsMouseDragging(button ImGuiMouseButton, lock_threshold f32) bool

pub fn ig_is_mouse_dragging(button ImGuiMouseButton, lock_threshold f32) bool {
	return C.igIsMouseDragging(button, lock_threshold)
}

fn C.igGetMouseDragDelta(p_out &C.ImVec2, button ImGuiMouseButton, lock_threshold f32)

pub fn ig_get_mouse_drag_delta(p_out &C.ImVec2, button ImGuiMouseButton, lock_threshold f32) {
	C.igGetMouseDragDelta(p_out, button, lock_threshold)
}

fn C.igResetMouseDragDelta(button ImGuiMouseButton)

pub fn ig_reset_mouse_drag_delta(button ImGuiMouseButton) {
	C.igResetMouseDragDelta(button)
}

fn C.igGetMouseCursor() ImGuiMouseCursor

pub fn ig_get_mouse_cursor() ImGuiMouseCursor {
	return C.igGetMouseCursor()
}

fn C.igSetMouseCursor(cursor_type ImGuiMouseCursor)

pub fn ig_set_mouse_cursor(cursor_type ImGuiMouseCursor) {
	C.igSetMouseCursor(cursor_type)
}

fn C.igSetNextFrameWantCaptureMouse(want_capture_mouse bool)

pub fn ig_set_next_frame_want_capture_mouse(want_capture_mouse bool) {
	C.igSetNextFrameWantCaptureMouse(want_capture_mouse)
}

fn C.igGetClipboardText() &i8

pub fn ig_get_clipboard_text() &i8 {
	return C.igGetClipboardText()
}

fn C.igSetClipboardText(text &i8)

pub fn ig_set_clipboard_text(text &i8) {
	C.igSetClipboardText(text)
}

fn C.igLoadIniSettingsFromDisk(ini_filename &i8)

pub fn ig_load_ini_settings_from_disk(ini_filename &i8) {
	C.igLoadIniSettingsFromDisk(ini_filename)
}

fn C.igLoadIniSettingsFromMemory(ini_data &i8, ini_size usize)

pub fn ig_load_ini_settings_from_memory(ini_data &i8, ini_size usize) {
	C.igLoadIniSettingsFromMemory(ini_data, ini_size)
}

fn C.igSaveIniSettingsToDisk(ini_filename &i8)

pub fn ig_save_ini_settings_to_disk(ini_filename &i8) {
	C.igSaveIniSettingsToDisk(ini_filename)
}

fn C.igSaveIniSettingsToMemory(out_ini_size &usize) &i8

pub fn ig_save_ini_settings_to_memory(out_ini_size &usize) &i8 {
	return C.igSaveIniSettingsToMemory(out_ini_size)
}

fn C.igDebugTextEncoding(text &i8)

pub fn ig_debug_text_encoding(text &i8) {
	C.igDebugTextEncoding(text)
}

fn C.igDebugFlashStyleColor(idx ImGuiCol)

pub fn ig_debug_flash_style_color(idx ImGuiCol) {
	C.igDebugFlashStyleColor(idx)
}

fn C.igDebugStartItemPicker()

pub fn ig_debug_start_item_picker() {
	C.igDebugStartItemPicker()
}

fn C.igDebugCheckVersionAndDataLayout(version_str &i8, sz_io usize, sz_style usize, sz_vec2 usize, sz_vec4 usize, sz_drawvert usize, sz_drawidx usize) bool

pub fn ig_debug_check_version_and_data_layout(version_str &i8, sz_io usize, sz_style usize, sz_vec2 usize, sz_vec4 usize, sz_drawvert usize, sz_drawidx usize) bool {
	return C.igDebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4,
		sz_drawvert, sz_drawidx)
}

@[c2v_variadic]
fn C.igDebugLog(fmt ...&i8)

pub fn ig_debug_log(fmt &i8) {
	C.igDebugLog(fmt)
}

fn C.igDebugLogV(fmt &i8, args C.va_list)

pub fn ig_debug_log_v(fmt &i8, args C.va_list) {
	C.igDebugLogV(fmt, args)
}

fn C.igSetAllocatorFunctions(alloc_func ImGuiMemAllocFunc, free_func ImGuiMemFreeFunc, user_data voidptr)

pub fn ig_set_allocator_functions(alloc_func ImGuiMemAllocFunc, free_func ImGuiMemFreeFunc, user_data voidptr) {
	C.igSetAllocatorFunctions(alloc_func, free_func, user_data)
}

fn C.igGetAllocatorFunctions(p_alloc_func &ImGuiMemAllocFunc, p_free_func &ImGuiMemFreeFunc, p_user_data &voidptr)

pub fn ig_get_allocator_functions(p_alloc_func &ImGuiMemAllocFunc, p_free_func &ImGuiMemFreeFunc, p_user_data &voidptr) {
	C.igGetAllocatorFunctions(p_alloc_func, p_free_func, p_user_data)
}

fn C.igMemAlloc(size usize) voidptr

pub fn ig_mem_alloc(size usize) voidptr {
	return C.igMemAlloc(size)
}

fn C.igMemFree(ptr voidptr)

pub fn ig_mem_free(ptr voidptr) {
	C.igMemFree(ptr)
}

fn C.igUpdatePlatformWindows()

pub fn ig_update_platform_windows() {
	C.igUpdatePlatformWindows()
}

fn C.igRenderPlatformWindowsDefault(platform_render_arg voidptr, renderer_render_arg voidptr)

pub fn ig_render_platform_windows_default(platform_render_arg voidptr, renderer_render_arg voidptr) {
	C.igRenderPlatformWindowsDefault(platform_render_arg, renderer_render_arg)
}

fn C.igDestroyPlatformWindows()

pub fn ig_destroy_platform_windows() {
	C.igDestroyPlatformWindows()
}

fn C.igFindViewportByID(id ImGuiID) &C.ImGuiViewport

pub fn ig_find_viewport_by_id(id ImGuiID) &C.ImGuiViewport {
	return C.igFindViewportByID(id)
}

fn C.igFindViewportByPlatformHandle(platform_handle voidptr) &C.ImGuiViewport

pub fn ig_find_viewport_by_platform_handle(platform_handle voidptr) &C.ImGuiViewport {
	return C.igFindViewportByPlatformHandle(platform_handle)
}

fn C.ImGuiTableSortSpecs_ImGuiTableSortSpecs() &C.ImGuiTableSortSpecs

pub fn im_gui_table_sort_specs_im_gui_table_sort_specs() &C.ImGuiTableSortSpecs {
	return C.ImGuiTableSortSpecs_ImGuiTableSortSpecs()
}

fn C.ImGuiTableSortSpecs_destroy(self &C.ImGuiTableSortSpecs)

pub fn im_gui_table_sort_specs_destroy(self &C.ImGuiTableSortSpecs) {
	C.ImGuiTableSortSpecs_destroy(self)
}

fn C.ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs() &C.ImGuiTableColumnSortSpecs

pub fn im_gui_table_column_sort_specs_im_gui_table_column_sort_specs() &C.ImGuiTableColumnSortSpecs {
	return C.ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs()
}

fn C.ImGuiTableColumnSortSpecs_destroy(self &C.ImGuiTableColumnSortSpecs)

pub fn im_gui_table_column_sort_specs_destroy(self &C.ImGuiTableColumnSortSpecs) {
	C.ImGuiTableColumnSortSpecs_destroy(self)
}

fn C.ImGuiStyle_ImGuiStyle() &C.ImGuiStyle

pub fn im_gui_style_im_gui_style() &C.ImGuiStyle {
	return C.ImGuiStyle_ImGuiStyle()
}

fn C.ImGuiStyle_destroy(self &C.ImGuiStyle)

pub fn im_gui_style_destroy(self &C.ImGuiStyle) {
	C.ImGuiStyle_destroy(self)
}

fn C.ImGuiStyle_ScaleAllSizes(self &C.ImGuiStyle, scale_factor f32)

pub fn im_gui_style_scale_all_sizes(self &C.ImGuiStyle, scale_factor f32) {
	C.ImGuiStyle_ScaleAllSizes(self, scale_factor)
}

fn C.ImGuiIO_AddKeyEvent(self &C.ImGuiIO, key ImGuiKey, down bool)

pub fn im_gui_io_add_key_event(self &C.ImGuiIO, key ImGuiKey, down bool) {
	C.ImGuiIO_AddKeyEvent(self, key, down)
}

fn C.ImGuiIO_AddKeyAnalogEvent(self &C.ImGuiIO, key ImGuiKey, down bool, v f32)

pub fn im_gui_io_add_key_analog_event(self &C.ImGuiIO, key ImGuiKey, down bool, v f32) {
	C.ImGuiIO_AddKeyAnalogEvent(self, key, down, v)
}

fn C.ImGuiIO_AddMousePosEvent(self &C.ImGuiIO, x f32, y f32)

pub fn im_gui_io_add_mouse_pos_event(self &C.ImGuiIO, x f32, y f32) {
	C.ImGuiIO_AddMousePosEvent(self, x, y)
}

fn C.ImGuiIO_AddMouseButtonEvent(self &C.ImGuiIO, button int, down bool)

pub fn im_gui_io_add_mouse_button_event(self &C.ImGuiIO, button int, down bool) {
	C.ImGuiIO_AddMouseButtonEvent(self, button, down)
}

fn C.ImGuiIO_AddMouseWheelEvent(self &C.ImGuiIO, wheel_x f32, wheel_y f32)

pub fn im_gui_io_add_mouse_wheel_event(self &C.ImGuiIO, wheel_x f32, wheel_y f32) {
	C.ImGuiIO_AddMouseWheelEvent(self, wheel_x, wheel_y)
}

fn C.ImGuiIO_AddMouseSourceEvent(self &C.ImGuiIO, source ImGuiMouseSource)

pub fn im_gui_io_add_mouse_source_event(self &C.ImGuiIO, source ImGuiMouseSource) {
	C.ImGuiIO_AddMouseSourceEvent(self, source)
}

fn C.ImGuiIO_AddMouseViewportEvent(self &C.ImGuiIO, id ImGuiID)

pub fn im_gui_io_add_mouse_viewport_event(self &C.ImGuiIO, id ImGuiID) {
	C.ImGuiIO_AddMouseViewportEvent(self, id)
}

fn C.ImGuiIO_AddFocusEvent(self &C.ImGuiIO, focused bool)

pub fn im_gui_io_add_focus_event(self &C.ImGuiIO, focused bool) {
	C.ImGuiIO_AddFocusEvent(self, focused)
}

fn C.ImGuiIO_AddInputCharacter(self &C.ImGuiIO, c u32)

pub fn im_gui_io_add_input_character(self &C.ImGuiIO, c u32) {
	C.ImGuiIO_AddInputCharacter(self, c)
}

fn C.ImGuiIO_AddInputCharacterUTF16(self &C.ImGuiIO, c ImWchar16)

pub fn im_gui_io_add_input_character_utf_16(self &C.ImGuiIO, c ImWchar16) {
	C.ImGuiIO_AddInputCharacterUTF16(self, c)
}

fn C.ImGuiIO_AddInputCharactersUTF8(self &C.ImGuiIO, str &i8)

pub fn im_gui_io_add_input_characters_utf_8(self &C.ImGuiIO, str &i8) {
	C.ImGuiIO_AddInputCharactersUTF8(self, str)
}

fn C.ImGuiIO_SetKeyEventNativeData(self &C.ImGuiIO, key ImGuiKey, native_keycode int, native_scancode int, native_legacy_index int)

pub fn im_gui_io_set_key_event_native_data(self &C.ImGuiIO, key ImGuiKey, native_keycode int, native_scancode int, native_legacy_index int) {
	C.ImGuiIO_SetKeyEventNativeData(self, key, native_keycode, native_scancode, native_legacy_index)
}

fn C.ImGuiIO_SetAppAcceptingEvents(self &C.ImGuiIO, accepting_events bool)

pub fn im_gui_io_set_app_accepting_events(self &C.ImGuiIO, accepting_events bool) {
	C.ImGuiIO_SetAppAcceptingEvents(self, accepting_events)
}

fn C.ImGuiIO_ClearEventsQueue(self &C.ImGuiIO)

pub fn im_gui_io_clear_events_queue(self &C.ImGuiIO) {
	C.ImGuiIO_ClearEventsQueue(self)
}

fn C.ImGuiIO_ClearInputKeys(self &C.ImGuiIO)

pub fn im_gui_io_clear_input_keys(self &C.ImGuiIO) {
	C.ImGuiIO_ClearInputKeys(self)
}

fn C.ImGuiIO_ClearInputMouse(self &C.ImGuiIO)

pub fn im_gui_io_clear_input_mouse(self &C.ImGuiIO) {
	C.ImGuiIO_ClearInputMouse(self)
}

fn C.ImGuiIO_ImGuiIO() &C.ImGuiIO

pub fn im_gui_io_im_gui_io() &C.ImGuiIO {
	return C.ImGuiIO_ImGuiIO()
}

fn C.ImGuiIO_destroy(self &C.ImGuiIO)

pub fn im_gui_io_destroy(self &C.ImGuiIO) {
	C.ImGuiIO_destroy(self)
}

fn C.ImGuiInputTextCallbackData_ImGuiInputTextCallbackData() &C.ImGuiInputTextCallbackData

pub fn im_gui_input_text_callback_data_im_gui_input_text_callback_data() &C.ImGuiInputTextCallbackData {
	return C.ImGuiInputTextCallbackData_ImGuiInputTextCallbackData()
}

fn C.ImGuiInputTextCallbackData_destroy(self &C.ImGuiInputTextCallbackData)

pub fn im_gui_input_text_callback_data_destroy(self &C.ImGuiInputTextCallbackData) {
	C.ImGuiInputTextCallbackData_destroy(self)
}

fn C.ImGuiInputTextCallbackData_DeleteChars(self &C.ImGuiInputTextCallbackData, pos int, bytes_count int)

pub fn im_gui_input_text_callback_data_delete_chars(self &C.ImGuiInputTextCallbackData, pos int, bytes_count int) {
	C.ImGuiInputTextCallbackData_DeleteChars(self, pos, bytes_count)
}

fn C.ImGuiInputTextCallbackData_InsertChars(self &C.ImGuiInputTextCallbackData, pos int, text &i8, text_end &i8)

pub fn im_gui_input_text_callback_data_insert_chars(self &C.ImGuiInputTextCallbackData, pos int, text &i8, text_end &i8) {
	C.ImGuiInputTextCallbackData_InsertChars(self, pos, text, text_end)
}

fn C.ImGuiInputTextCallbackData_SelectAll(self &C.ImGuiInputTextCallbackData)

pub fn im_gui_input_text_callback_data_select_all(self &C.ImGuiInputTextCallbackData) {
	C.ImGuiInputTextCallbackData_SelectAll(self)
}

fn C.ImGuiInputTextCallbackData_ClearSelection(self &C.ImGuiInputTextCallbackData)

pub fn im_gui_input_text_callback_data_clear_selection(self &C.ImGuiInputTextCallbackData) {
	C.ImGuiInputTextCallbackData_ClearSelection(self)
}

fn C.ImGuiInputTextCallbackData_HasSelection(self &C.ImGuiInputTextCallbackData) bool

pub fn im_gui_input_text_callback_data_has_selection(self &C.ImGuiInputTextCallbackData) bool {
	return C.ImGuiInputTextCallbackData_HasSelection(self)
}

fn C.ImGuiWindowClass_ImGuiWindowClass() &C.ImGuiWindowClass

pub fn im_gui_window_class_im_gui_window_class() &C.ImGuiWindowClass {
	return C.ImGuiWindowClass_ImGuiWindowClass()
}

fn C.ImGuiWindowClass_destroy(self &C.ImGuiWindowClass)

pub fn im_gui_window_class_destroy(self &C.ImGuiWindowClass) {
	C.ImGuiWindowClass_destroy(self)
}

fn C.ImGuiPayload_ImGuiPayload() &C.ImGuiPayload

pub fn im_gui_payload_im_gui_payload() &C.ImGuiPayload {
	return C.ImGuiPayload_ImGuiPayload()
}

fn C.ImGuiPayload_destroy(self &C.ImGuiPayload)

pub fn im_gui_payload_destroy(self &C.ImGuiPayload) {
	C.ImGuiPayload_destroy(self)
}

fn C.ImGuiPayload_Clear(self &C.ImGuiPayload)

pub fn im_gui_payload_clear(self &C.ImGuiPayload) {
	C.ImGuiPayload_Clear(self)
}

fn C.ImGuiPayload_IsDataType(self &C.ImGuiPayload, type_ &i8) bool

pub fn im_gui_payload_is_data_type(self &C.ImGuiPayload, type_ &i8) bool {
	return C.ImGuiPayload_IsDataType(self, type_)
}

fn C.ImGuiPayload_IsPreview(self &C.ImGuiPayload) bool

pub fn im_gui_payload_is_preview(self &C.ImGuiPayload) bool {
	return C.ImGuiPayload_IsPreview(self)
}

fn C.ImGuiPayload_IsDelivery(self &C.ImGuiPayload) bool

pub fn im_gui_payload_is_delivery(self &C.ImGuiPayload) bool {
	return C.ImGuiPayload_IsDelivery(self)
}

fn C.ImGuiOnceUponAFrame_ImGuiOnceUponAFrame() &C.ImGuiOnceUponAFrame

pub fn im_gui_once_upon_af_rame_im_gui_once_upon_af_rame() &C.ImGuiOnceUponAFrame {
	return C.ImGuiOnceUponAFrame_ImGuiOnceUponAFrame()
}

fn C.ImGuiOnceUponAFrame_destroy(self &C.ImGuiOnceUponAFrame)

pub fn im_gui_once_upon_af_rame_destroy(self &C.ImGuiOnceUponAFrame) {
	C.ImGuiOnceUponAFrame_destroy(self)
}

fn C.ImGuiTextFilter_ImGuiTextFilter(default_filter &i8) &C.ImGuiTextFilter

pub fn im_gui_text_filter_im_gui_text_filter(default_filter &i8) &C.ImGuiTextFilter {
	return C.ImGuiTextFilter_ImGuiTextFilter(default_filter)
}

fn C.ImGuiTextFilter_destroy(self &C.ImGuiTextFilter)

pub fn im_gui_text_filter_destroy(self &C.ImGuiTextFilter) {
	C.ImGuiTextFilter_destroy(self)
}

fn C.ImGuiTextFilter_Draw(self &C.ImGuiTextFilter, label &i8, width f32) bool

pub fn im_gui_text_filter_draw(self &C.ImGuiTextFilter, label &i8, width f32) bool {
	return C.ImGuiTextFilter_Draw(self, label, width)
}

fn C.ImGuiTextFilter_PassFilter(self &C.ImGuiTextFilter, text &i8, text_end &i8) bool

pub fn im_gui_text_filter_pass_filter(self &C.ImGuiTextFilter, text &i8, text_end &i8) bool {
	return C.ImGuiTextFilter_PassFilter(self, text, text_end)
}

fn C.ImGuiTextFilter_Build(self &C.ImGuiTextFilter)

pub fn im_gui_text_filter_build(self &C.ImGuiTextFilter) {
	C.ImGuiTextFilter_Build(self)
}

fn C.ImGuiTextFilter_Clear(self &C.ImGuiTextFilter)

pub fn im_gui_text_filter_clear(self &C.ImGuiTextFilter) {
	C.ImGuiTextFilter_Clear(self)
}

fn C.ImGuiTextFilter_IsActive(self &C.ImGuiTextFilter) bool

pub fn im_gui_text_filter_is_active(self &C.ImGuiTextFilter) bool {
	return C.ImGuiTextFilter_IsActive(self)
}

fn C.ImGuiTextRange_ImGuiTextRange_Nil() &C.ImGuiTextRange

pub fn im_gui_text_range_im_gui_text_range_nil() &C.ImGuiTextRange {
	return C.ImGuiTextRange_ImGuiTextRange_Nil()
}

fn C.ImGuiTextRange_destroy(self &C.ImGuiTextRange)

pub fn im_gui_text_range_destroy(self &C.ImGuiTextRange) {
	C.ImGuiTextRange_destroy(self)
}

fn C.ImGuiTextRange_ImGuiTextRange_Str(_b &i8, _e &i8) &C.ImGuiTextRange

pub fn im_gui_text_range_im_gui_text_range_str(_b &i8, _e &i8) &C.ImGuiTextRange {
	return C.ImGuiTextRange_ImGuiTextRange_Str(_b, _e)
}

fn C.ImGuiTextRange_empty(self &C.ImGuiTextRange) bool

pub fn im_gui_text_range_empty(self &C.ImGuiTextRange) bool {
	return C.ImGuiTextRange_empty(self)
}

fn C.ImGuiTextRange_split(self &C.ImGuiTextRange, separator i8, out &C.ImVector_ImGuiTextRange)

pub fn im_gui_text_range_split(self &C.ImGuiTextRange, separator i8, out &C.ImVector_ImGuiTextRange) {
	C.ImGuiTextRange_split(self, separator, out)
}

fn C.ImGuiTextBuffer_ImGuiTextBuffer() &C.ImGuiTextBuffer

pub fn im_gui_text_buffer_im_gui_text_buffer() &C.ImGuiTextBuffer {
	return C.ImGuiTextBuffer_ImGuiTextBuffer()
}

fn C.ImGuiTextBuffer_destroy(self &C.ImGuiTextBuffer)

pub fn im_gui_text_buffer_destroy(self &C.ImGuiTextBuffer) {
	C.ImGuiTextBuffer_destroy(self)
}

fn C.ImGuiTextBuffer_begin(self &C.ImGuiTextBuffer) &i8

pub fn im_gui_text_buffer_begin(self &C.ImGuiTextBuffer) &i8 {
	return C.ImGuiTextBuffer_begin(self)
}

fn C.ImGuiTextBuffer_end(self &C.ImGuiTextBuffer) &i8

pub fn im_gui_text_buffer_end(self &C.ImGuiTextBuffer) &i8 {
	return C.ImGuiTextBuffer_end(self)
}

fn C.ImGuiTextBuffer_size(self &C.ImGuiTextBuffer) int

pub fn im_gui_text_buffer_size(self &C.ImGuiTextBuffer) int {
	return C.ImGuiTextBuffer_size(self)
}

fn C.ImGuiTextBuffer_empty(self &C.ImGuiTextBuffer) bool

pub fn im_gui_text_buffer_empty(self &C.ImGuiTextBuffer) bool {
	return C.ImGuiTextBuffer_empty(self)
}

fn C.ImGuiTextBuffer_clear(self &C.ImGuiTextBuffer)

pub fn im_gui_text_buffer_clear(self &C.ImGuiTextBuffer) {
	C.ImGuiTextBuffer_clear(self)
}

fn C.ImGuiTextBuffer_reserve(self &C.ImGuiTextBuffer, capacity int)

pub fn im_gui_text_buffer_reserve(self &C.ImGuiTextBuffer, capacity int) {
	C.ImGuiTextBuffer_reserve(self, capacity)
}

fn C.ImGuiTextBuffer_c_str(self &C.ImGuiTextBuffer) &i8

pub fn im_gui_text_buffer_c_str(self &C.ImGuiTextBuffer) &i8 {
	return C.ImGuiTextBuffer_c_str(self)
}

fn C.ImGuiTextBuffer_append(self &C.ImGuiTextBuffer, str &i8, str_end &i8)

pub fn im_gui_text_buffer_append(self &C.ImGuiTextBuffer, str &i8, str_end &i8) {
	C.ImGuiTextBuffer_append(self, str, str_end)
}

fn C.ImGuiTextBuffer_appendfv(self &C.ImGuiTextBuffer, fmt &i8, args C.va_list)

pub fn im_gui_text_buffer_appendfv(self &C.ImGuiTextBuffer, fmt &i8, args C.va_list) {
	C.ImGuiTextBuffer_appendfv(self, fmt, args)
}

fn C.ImGuiStoragePair_ImGuiStoragePair_Int(_key ImGuiID, _val int) &C.ImGuiStoragePair

pub fn im_gui_storage_pair_im_gui_storage_pair_int(_key ImGuiID, _val int) &C.ImGuiStoragePair {
	return C.ImGuiStoragePair_ImGuiStoragePair_Int(_key, _val)
}

fn C.ImGuiStoragePair_destroy(self &C.ImGuiStoragePair)

pub fn im_gui_storage_pair_destroy(self &C.ImGuiStoragePair) {
	C.ImGuiStoragePair_destroy(self)
}

fn C.ImGuiStoragePair_ImGuiStoragePair_Float(_key ImGuiID, _val f32) &C.ImGuiStoragePair

pub fn im_gui_storage_pair_im_gui_storage_pair_float(_key ImGuiID, _val f32) &C.ImGuiStoragePair {
	return C.ImGuiStoragePair_ImGuiStoragePair_Float(_key, _val)
}

fn C.ImGuiStoragePair_ImGuiStoragePair_Ptr(_key ImGuiID, _val voidptr) &C.ImGuiStoragePair

pub fn im_gui_storage_pair_im_gui_storage_pair_ptr(_key ImGuiID, _val voidptr) &C.ImGuiStoragePair {
	return C.ImGuiStoragePair_ImGuiStoragePair_Ptr(_key, _val)
}

fn C.ImGuiStorage_Clear(self &C.ImGuiStorage)

pub fn im_gui_storage_clear(self &C.ImGuiStorage) {
	C.ImGuiStorage_Clear(self)
}

fn C.ImGuiStorage_GetInt(self &C.ImGuiStorage, key ImGuiID, default_val int) int

pub fn im_gui_storage_get_int(self &C.ImGuiStorage, key ImGuiID, default_val int) int {
	return C.ImGuiStorage_GetInt(self, key, default_val)
}

fn C.ImGuiStorage_SetInt(self &C.ImGuiStorage, key ImGuiID, val int)

pub fn im_gui_storage_set_int(self &C.ImGuiStorage, key ImGuiID, val int) {
	C.ImGuiStorage_SetInt(self, key, val)
}

fn C.ImGuiStorage_GetBool(self &C.ImGuiStorage, key ImGuiID, default_val bool) bool

pub fn im_gui_storage_get_bool(self &C.ImGuiStorage, key ImGuiID, default_val bool) bool {
	return C.ImGuiStorage_GetBool(self, key, default_val)
}

fn C.ImGuiStorage_SetBool(self &C.ImGuiStorage, key ImGuiID, val bool)

pub fn im_gui_storage_set_bool(self &C.ImGuiStorage, key ImGuiID, val bool) {
	C.ImGuiStorage_SetBool(self, key, val)
}

fn C.ImGuiStorage_GetFloat(self &C.ImGuiStorage, key ImGuiID, default_val f32) f32

pub fn im_gui_storage_get_float(self &C.ImGuiStorage, key ImGuiID, default_val f32) f32 {
	return C.ImGuiStorage_GetFloat(self, key, default_val)
}

fn C.ImGuiStorage_SetFloat(self &C.ImGuiStorage, key ImGuiID, val f32)

pub fn im_gui_storage_set_float(self &C.ImGuiStorage, key ImGuiID, val f32) {
	C.ImGuiStorage_SetFloat(self, key, val)
}

fn C.ImGuiStorage_GetVoidPtr(self &C.ImGuiStorage, key ImGuiID) voidptr

pub fn im_gui_storage_get_void_ptr(self &C.ImGuiStorage, key ImGuiID) voidptr {
	return C.ImGuiStorage_GetVoidPtr(self, key)
}

fn C.ImGuiStorage_SetVoidPtr(self &C.ImGuiStorage, key ImGuiID, val voidptr)

pub fn im_gui_storage_set_void_ptr(self &C.ImGuiStorage, key ImGuiID, val voidptr) {
	C.ImGuiStorage_SetVoidPtr(self, key, val)
}

fn C.ImGuiStorage_GetIntRef(self &C.ImGuiStorage, key ImGuiID, default_val int) &int

pub fn im_gui_storage_get_int_ref(self &C.ImGuiStorage, key ImGuiID, default_val int) &int {
	return C.ImGuiStorage_GetIntRef(self, key, default_val)
}

fn C.ImGuiStorage_GetBoolRef(self &C.ImGuiStorage, key ImGuiID, default_val bool) &bool

pub fn im_gui_storage_get_bool_ref(self &C.ImGuiStorage, key ImGuiID, default_val bool) &bool {
	return C.ImGuiStorage_GetBoolRef(self, key, default_val)
}

fn C.ImGuiStorage_GetFloatRef(self &C.ImGuiStorage, key ImGuiID, default_val f32) &f32

pub fn im_gui_storage_get_float_ref(self &C.ImGuiStorage, key ImGuiID, default_val f32) &f32 {
	return C.ImGuiStorage_GetFloatRef(self, key, default_val)
}

fn C.ImGuiStorage_GetVoidPtrRef(self &C.ImGuiStorage, key ImGuiID, default_val voidptr) &voidptr

pub fn im_gui_storage_get_void_ptr_ref(self &C.ImGuiStorage, key ImGuiID, default_val voidptr) &voidptr {
	return C.ImGuiStorage_GetVoidPtrRef(self, key, default_val)
}

fn C.ImGuiStorage_BuildSortByKey(self &C.ImGuiStorage)

pub fn im_gui_storage_build_sort_by_key(self &C.ImGuiStorage) {
	C.ImGuiStorage_BuildSortByKey(self)
}

fn C.ImGuiStorage_SetAllInt(self &C.ImGuiStorage, val int)

pub fn im_gui_storage_set_all_int(self &C.ImGuiStorage, val int) {
	C.ImGuiStorage_SetAllInt(self, val)
}

fn C.ImGuiListClipper_ImGuiListClipper() &C.ImGuiListClipper

pub fn im_gui_list_clipper_im_gui_list_clipper() &C.ImGuiListClipper {
	return C.ImGuiListClipper_ImGuiListClipper()
}

fn C.ImGuiListClipper_destroy(self &C.ImGuiListClipper)

pub fn im_gui_list_clipper_destroy(self &C.ImGuiListClipper) {
	C.ImGuiListClipper_destroy(self)
}

fn C.ImGuiListClipper_Begin(self &C.ImGuiListClipper, items_count int, items_height f32)

pub fn im_gui_list_clipper_begin(self &C.ImGuiListClipper, items_count int, items_height f32) {
	C.ImGuiListClipper_Begin(self, items_count, items_height)
}

fn C.ImGuiListClipper_End(self &C.ImGuiListClipper)

pub fn im_gui_list_clipper_end(self &C.ImGuiListClipper) {
	C.ImGuiListClipper_End(self)
}

fn C.ImGuiListClipper_Step(self &C.ImGuiListClipper) bool

pub fn im_gui_list_clipper_step(self &C.ImGuiListClipper) bool {
	return C.ImGuiListClipper_Step(self)
}

fn C.ImGuiListClipper_IncludeItemByIndex(self &C.ImGuiListClipper, item_index int)

pub fn im_gui_list_clipper_include_item_by_index(self &C.ImGuiListClipper, item_index int) {
	C.ImGuiListClipper_IncludeItemByIndex(self, item_index)
}

fn C.ImGuiListClipper_IncludeItemsByIndex(self &C.ImGuiListClipper, item_begin int, item_end int)

pub fn im_gui_list_clipper_include_items_by_index(self &C.ImGuiListClipper, item_begin int, item_end int) {
	C.ImGuiListClipper_IncludeItemsByIndex(self, item_begin, item_end)
}

fn C.ImGuiListClipper_SeekCursorForItem(self &C.ImGuiListClipper, item_index int)

pub fn im_gui_list_clipper_seek_cursor_for_item(self &C.ImGuiListClipper, item_index int) {
	C.ImGuiListClipper_SeekCursorForItem(self, item_index)
}

fn C.ImColor_ImColor_Nil() &C.ImColor

pub fn im_color_im_color_nil() &C.ImColor {
	return C.ImColor_ImColor_Nil()
}

fn C.ImColor_destroy(self &C.ImColor)

pub fn im_color_destroy(self &C.ImColor) {
	C.ImColor_destroy(self)
}

fn C.ImColor_ImColor_Float(r f32, g f32, b f32, a f32) &C.ImColor

pub fn im_color_im_color_float(r f32, g f32, b f32, a f32) &C.ImColor {
	return C.ImColor_ImColor_Float(r, g, b, a)
}

fn C.ImColor_ImColor_Vec4(col C.ImVec4) &C.ImColor

pub fn im_color_im_color_vec4(col C.ImVec4) &C.ImColor {
	return C.ImColor_ImColor_Vec4(col)
}

fn C.ImColor_ImColor_Int(r int, g int, b int, a int) &C.ImColor

pub fn im_color_im_color_int(r int, g int, b int, a int) &C.ImColor {
	return C.ImColor_ImColor_Int(r, g, b, a)
}

fn C.ImColor_ImColor_U32(rgba ImU32) &C.ImColor

pub fn im_color_im_color_u32(rgba ImU32) &C.ImColor {
	return C.ImColor_ImColor_U32(rgba)
}

fn C.ImColor_SetHSV(self &C.ImColor, h f32, s f32, v f32, a f32)

pub fn im_color_set_hsv(self &C.ImColor, h f32, s f32, v f32, a f32) {
	C.ImColor_SetHSV(self, h, s, v, a)
}

fn C.ImColor_HSV(p_out &C.ImColor, h f32, s f32, v f32, a f32)

pub fn im_color_hsv(p_out &C.ImColor, h f32, s f32, v f32, a f32) {
	C.ImColor_HSV(p_out, h, s, v, a)
}

fn C.ImGuiSelectionBasicStorage_ImGuiSelectionBasicStorage() &C.ImGuiSelectionBasicStorage

pub fn im_gui_selection_basic_storage_im_gui_selection_basic_storage() &C.ImGuiSelectionBasicStorage {
	return C.ImGuiSelectionBasicStorage_ImGuiSelectionBasicStorage()
}

fn C.ImGuiSelectionBasicStorage_destroy(self &C.ImGuiSelectionBasicStorage)

pub fn im_gui_selection_basic_storage_destroy(self &C.ImGuiSelectionBasicStorage) {
	C.ImGuiSelectionBasicStorage_destroy(self)
}

fn C.ImGuiSelectionBasicStorage_ApplyRequests(self &C.ImGuiSelectionBasicStorage, ms_io &C.ImGuiMultiSelectIO)

pub fn im_gui_selection_basic_storage_apply_requests(self &C.ImGuiSelectionBasicStorage, ms_io &C.ImGuiMultiSelectIO) {
	C.ImGuiSelectionBasicStorage_ApplyRequests(self, ms_io)
}

fn C.ImGuiSelectionBasicStorage_Contains(self &C.ImGuiSelectionBasicStorage, id ImGuiID) bool

pub fn im_gui_selection_basic_storage_contains(self &C.ImGuiSelectionBasicStorage, id ImGuiID) bool {
	return C.ImGuiSelectionBasicStorage_Contains(self, id)
}

fn C.ImGuiSelectionBasicStorage_Clear(self &C.ImGuiSelectionBasicStorage)

pub fn im_gui_selection_basic_storage_clear(self &C.ImGuiSelectionBasicStorage) {
	C.ImGuiSelectionBasicStorage_Clear(self)
}

fn C.ImGuiSelectionBasicStorage_Swap(self &C.ImGuiSelectionBasicStorage, r &C.ImGuiSelectionBasicStorage)

pub fn im_gui_selection_basic_storage_swap(self &C.ImGuiSelectionBasicStorage, r &C.ImGuiSelectionBasicStorage) {
	C.ImGuiSelectionBasicStorage_Swap(self, r)
}

fn C.ImGuiSelectionBasicStorage_SetItemSelected(self &C.ImGuiSelectionBasicStorage, id ImGuiID, selected bool)

pub fn im_gui_selection_basic_storage_set_item_selected(self &C.ImGuiSelectionBasicStorage, id ImGuiID, selected bool) {
	C.ImGuiSelectionBasicStorage_SetItemSelected(self, id, selected)
}

fn C.ImGuiSelectionBasicStorage_GetNextSelectedItem(self &C.ImGuiSelectionBasicStorage, opaque_it &voidptr, out_id &ImGuiID) bool

pub fn im_gui_selection_basic_storage_get_next_selected_item(self &C.ImGuiSelectionBasicStorage, opaque_it &voidptr, out_id &ImGuiID) bool {
	return C.ImGuiSelectionBasicStorage_GetNextSelectedItem(self, opaque_it, out_id)
}

fn C.ImGuiSelectionBasicStorage_GetStorageIdFromIndex(self &C.ImGuiSelectionBasicStorage, idx int) ImGuiID

pub fn im_gui_selection_basic_storage_get_storage_id_from_index(self &C.ImGuiSelectionBasicStorage, idx int) ImGuiID {
	return C.ImGuiSelectionBasicStorage_GetStorageIdFromIndex(self, idx)
}

fn C.ImGuiSelectionExternalStorage_ImGuiSelectionExternalStorage() &C.ImGuiSelectionExternalStorage

pub fn im_gui_selection_external_storage_im_gui_selection_external_storage() &C.ImGuiSelectionExternalStorage {
	return C.ImGuiSelectionExternalStorage_ImGuiSelectionExternalStorage()
}

fn C.ImGuiSelectionExternalStorage_destroy(self &C.ImGuiSelectionExternalStorage)

pub fn im_gui_selection_external_storage_destroy(self &C.ImGuiSelectionExternalStorage) {
	C.ImGuiSelectionExternalStorage_destroy(self)
}

fn C.ImGuiSelectionExternalStorage_ApplyRequests(self &C.ImGuiSelectionExternalStorage, ms_io &C.ImGuiMultiSelectIO)

pub fn im_gui_selection_external_storage_apply_requests(self &C.ImGuiSelectionExternalStorage, ms_io &C.ImGuiMultiSelectIO) {
	C.ImGuiSelectionExternalStorage_ApplyRequests(self, ms_io)
}

fn C.ImDrawCmd_ImDrawCmd() &C.ImDrawCmd

pub fn im_draw_cmd_im_draw_cmd() &C.ImDrawCmd {
	return C.ImDrawCmd_ImDrawCmd()
}

fn C.ImDrawCmd_destroy(self &C.ImDrawCmd)

pub fn im_draw_cmd_destroy(self &C.ImDrawCmd) {
	C.ImDrawCmd_destroy(self)
}

fn C.ImDrawCmd_GetTexID(self &C.ImDrawCmd) ImTextureID

pub fn im_draw_cmd_get_tex_id(self &C.ImDrawCmd) ImTextureID {
	return C.ImDrawCmd_GetTexID(self)
}

fn C.ImDrawListSplitter_ImDrawListSplitter() &C.ImDrawListSplitter

pub fn im_draw_list_splitter_im_draw_list_splitter() &C.ImDrawListSplitter {
	return C.ImDrawListSplitter_ImDrawListSplitter()
}

fn C.ImDrawListSplitter_destroy(self &C.ImDrawListSplitter)

pub fn im_draw_list_splitter_destroy(self &C.ImDrawListSplitter) {
	C.ImDrawListSplitter_destroy(self)
}

fn C.ImDrawListSplitter_Clear(self &C.ImDrawListSplitter)

pub fn im_draw_list_splitter_clear(self &C.ImDrawListSplitter) {
	C.ImDrawListSplitter_Clear(self)
}

fn C.ImDrawListSplitter_ClearFreeMemory(self &C.ImDrawListSplitter)

pub fn im_draw_list_splitter_clear_free_memory(self &C.ImDrawListSplitter) {
	C.ImDrawListSplitter_ClearFreeMemory(self)
}

fn C.ImDrawListSplitter_Split(self &C.ImDrawListSplitter, draw_list &C.ImDrawList, count int)

pub fn im_draw_list_splitter_split(self &C.ImDrawListSplitter, draw_list &C.ImDrawList, count int) {
	C.ImDrawListSplitter_Split(self, draw_list, count)
}

fn C.ImDrawListSplitter_Merge(self &C.ImDrawListSplitter, draw_list &C.ImDrawList)

pub fn im_draw_list_splitter_merge(self &C.ImDrawListSplitter, draw_list &C.ImDrawList) {
	C.ImDrawListSplitter_Merge(self, draw_list)
}

fn C.ImDrawListSplitter_SetCurrentChannel(self &C.ImDrawListSplitter, draw_list &C.ImDrawList, channel_idx int)

pub fn im_draw_list_splitter_set_current_channel(self &C.ImDrawListSplitter, draw_list &C.ImDrawList, channel_idx int) {
	C.ImDrawListSplitter_SetCurrentChannel(self, draw_list, channel_idx)
}

fn C.ImDrawList_ImDrawList(shared_data &C.ImDrawListSharedData) &C.ImDrawList

pub fn im_draw_list_im_draw_list(shared_data &C.ImDrawListSharedData) &C.ImDrawList {
	return C.ImDrawList_ImDrawList(shared_data)
}

fn C.ImDrawList_destroy(self &C.ImDrawList)

pub fn im_draw_list_destroy(self &C.ImDrawList) {
	C.ImDrawList_destroy(self)
}

fn C.ImDrawList_PushClipRect(self &C.ImDrawList, clip_rect_min C.ImVec2, clip_rect_max C.ImVec2, intersect_with_current_clip_rect bool)

pub fn im_draw_list_push_clip_rect(self &C.ImDrawList, clip_rect_min C.ImVec2, clip_rect_max C.ImVec2, intersect_with_current_clip_rect bool) {
	C.ImDrawList_PushClipRect(self, clip_rect_min, clip_rect_max, intersect_with_current_clip_rect)
}

fn C.ImDrawList_PushClipRectFullScreen(self &C.ImDrawList)

pub fn im_draw_list_push_clip_rect_full_screen(self &C.ImDrawList) {
	C.ImDrawList_PushClipRectFullScreen(self)
}

fn C.ImDrawList_PopClipRect(self &C.ImDrawList)

pub fn im_draw_list_pop_clip_rect(self &C.ImDrawList) {
	C.ImDrawList_PopClipRect(self)
}

fn C.ImDrawList_PushTextureID(self &C.ImDrawList, texture_id ImTextureID)

pub fn im_draw_list_push_texture_id(self &C.ImDrawList, texture_id ImTextureID) {
	C.ImDrawList_PushTextureID(self, texture_id)
}

fn C.ImDrawList_PopTextureID(self &C.ImDrawList)

pub fn im_draw_list_pop_texture_id(self &C.ImDrawList) {
	C.ImDrawList_PopTextureID(self)
}

fn C.ImDrawList_GetClipRectMin(p_out &C.ImVec2, self &C.ImDrawList)

pub fn im_draw_list_get_clip_rect_min(p_out &C.ImVec2, self &C.ImDrawList) {
	C.ImDrawList_GetClipRectMin(p_out, self)
}

fn C.ImDrawList_GetClipRectMax(p_out &C.ImVec2, self &C.ImDrawList)

pub fn im_draw_list_get_clip_rect_max(p_out &C.ImVec2, self &C.ImDrawList) {
	C.ImDrawList_GetClipRectMax(p_out, self)
}

fn C.ImDrawList_AddLine(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, col ImU32, thickness f32)

pub fn im_draw_list_add_line(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, col ImU32, thickness f32) {
	C.ImDrawList_AddLine(self, p1, p2, col, thickness)
}

fn C.ImDrawList_AddRect(self &C.ImDrawList, p_min C.ImVec2, p_max C.ImVec2, col ImU32, rounding f32, flags ImDrawFlags, thickness f32)

pub fn im_draw_list_add_rect(self &C.ImDrawList, p_min C.ImVec2, p_max C.ImVec2, col ImU32, rounding f32, flags ImDrawFlags, thickness f32) {
	C.ImDrawList_AddRect(self, p_min, p_max, col, rounding, flags, thickness)
}

fn C.ImDrawList_AddRectFilled(self &C.ImDrawList, p_min C.ImVec2, p_max C.ImVec2, col ImU32, rounding f32, flags ImDrawFlags)

pub fn im_draw_list_add_rect_filled(self &C.ImDrawList, p_min C.ImVec2, p_max C.ImVec2, col ImU32, rounding f32, flags ImDrawFlags) {
	C.ImDrawList_AddRectFilled(self, p_min, p_max, col, rounding, flags)
}

fn C.ImDrawList_AddRectFilledMultiColor(self &C.ImDrawList, p_min C.ImVec2, p_max C.ImVec2, col_upr_left ImU32, col_upr_right ImU32, col_bot_right ImU32, col_bot_left ImU32)

pub fn im_draw_list_add_rect_filled_multi_color(self &C.ImDrawList, p_min C.ImVec2, p_max C.ImVec2, col_upr_left ImU32, col_upr_right ImU32, col_bot_right ImU32, col_bot_left ImU32) {
	C.ImDrawList_AddRectFilledMultiColor(self, p_min, p_max, col_upr_left, col_upr_right,
		col_bot_right, col_bot_left)
}

fn C.ImDrawList_AddQuad(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, col ImU32, thickness f32)

pub fn im_draw_list_add_quad(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, col ImU32, thickness f32) {
	C.ImDrawList_AddQuad(self, p1, p2, p3, p4, col, thickness)
}

fn C.ImDrawList_AddQuadFilled(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, col ImU32)

pub fn im_draw_list_add_quad_filled(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, col ImU32) {
	C.ImDrawList_AddQuadFilled(self, p1, p2, p3, p4, col)
}

fn C.ImDrawList_AddTriangle(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, col ImU32, thickness f32)

pub fn im_draw_list_add_triangle(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, col ImU32, thickness f32) {
	C.ImDrawList_AddTriangle(self, p1, p2, p3, col, thickness)
}

fn C.ImDrawList_AddTriangleFilled(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, col ImU32)

pub fn im_draw_list_add_triangle_filled(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, col ImU32) {
	C.ImDrawList_AddTriangleFilled(self, p1, p2, p3, col)
}

fn C.ImDrawList_AddCircle(self &C.ImDrawList, center C.ImVec2, radius f32, col ImU32, num_segments int, thickness f32)

pub fn im_draw_list_add_circle(self &C.ImDrawList, center C.ImVec2, radius f32, col ImU32, num_segments int, thickness f32) {
	C.ImDrawList_AddCircle(self, center, radius, col, num_segments, thickness)
}

fn C.ImDrawList_AddCircleFilled(self &C.ImDrawList, center C.ImVec2, radius f32, col ImU32, num_segments int)

pub fn im_draw_list_add_circle_filled(self &C.ImDrawList, center C.ImVec2, radius f32, col ImU32, num_segments int) {
	C.ImDrawList_AddCircleFilled(self, center, radius, col, num_segments)
}

fn C.ImDrawList_AddNgon(self &C.ImDrawList, center C.ImVec2, radius f32, col ImU32, num_segments int, thickness f32)

pub fn im_draw_list_add_ngon(self &C.ImDrawList, center C.ImVec2, radius f32, col ImU32, num_segments int, thickness f32) {
	C.ImDrawList_AddNgon(self, center, radius, col, num_segments, thickness)
}

fn C.ImDrawList_AddNgonFilled(self &C.ImDrawList, center C.ImVec2, radius f32, col ImU32, num_segments int)

pub fn im_draw_list_add_ngon_filled(self &C.ImDrawList, center C.ImVec2, radius f32, col ImU32, num_segments int) {
	C.ImDrawList_AddNgonFilled(self, center, radius, col, num_segments)
}

fn C.ImDrawList_AddEllipse(self &C.ImDrawList, center C.ImVec2, radius C.ImVec2, col ImU32, rot f32, num_segments int, thickness f32)

pub fn im_draw_list_add_ellipse(self &C.ImDrawList, center C.ImVec2, radius C.ImVec2, col ImU32, rot f32, num_segments int, thickness f32) {
	C.ImDrawList_AddEllipse(self, center, radius, col, rot, num_segments, thickness)
}

fn C.ImDrawList_AddEllipseFilled(self &C.ImDrawList, center C.ImVec2, radius C.ImVec2, col ImU32, rot f32, num_segments int)

pub fn im_draw_list_add_ellipse_filled(self &C.ImDrawList, center C.ImVec2, radius C.ImVec2, col ImU32, rot f32, num_segments int) {
	C.ImDrawList_AddEllipseFilled(self, center, radius, col, rot, num_segments)
}

fn C.ImDrawList_AddText_Vec2(self &C.ImDrawList, pos C.ImVec2, col ImU32, text_begin &i8, text_end &i8)

pub fn im_draw_list_add_text_vec2(self &C.ImDrawList, pos C.ImVec2, col ImU32, text_begin &i8, text_end &i8) {
	C.ImDrawList_AddText_Vec2(self, pos, col, text_begin, text_end)
}

fn C.ImDrawList_AddText_FontPtr(self &C.ImDrawList, font &C.ImFont, font_size f32, pos C.ImVec2, col ImU32, text_begin &i8, text_end &i8, wrap_width f32, cpu_fine_clip_rect &C.ImVec4)

pub fn im_draw_list_add_text_font_ptr(self &C.ImDrawList, font &C.ImFont, font_size f32, pos C.ImVec2, col ImU32, text_begin &i8, text_end &i8, wrap_width f32, cpu_fine_clip_rect &C.ImVec4) {
	C.ImDrawList_AddText_FontPtr(self, font, font_size, pos, col, text_begin, text_end,
		wrap_width, cpu_fine_clip_rect)
}

fn C.ImDrawList_AddBezierCubic(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, col ImU32, thickness f32, num_segments int)

pub fn im_draw_list_add_bezier_cubic(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, col ImU32, thickness f32, num_segments int) {
	C.ImDrawList_AddBezierCubic(self, p1, p2, p3, p4, col, thickness, num_segments)
}

fn C.ImDrawList_AddBezierQuadratic(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, col ImU32, thickness f32, num_segments int)

pub fn im_draw_list_add_bezier_quadratic(self &C.ImDrawList, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, col ImU32, thickness f32, num_segments int) {
	C.ImDrawList_AddBezierQuadratic(self, p1, p2, p3, col, thickness, num_segments)
}

fn C.ImDrawList_AddPolyline(self &C.ImDrawList, points &C.ImVec2, num_points int, col ImU32, flags ImDrawFlags, thickness f32)

pub fn im_draw_list_add_polyline(self &C.ImDrawList, points &C.ImVec2, num_points int, col ImU32, flags ImDrawFlags, thickness f32) {
	C.ImDrawList_AddPolyline(self, points, num_points, col, flags, thickness)
}

fn C.ImDrawList_AddConvexPolyFilled(self &C.ImDrawList, points &C.ImVec2, num_points int, col ImU32)

pub fn im_draw_list_add_convex_poly_filled(self &C.ImDrawList, points &C.ImVec2, num_points int, col ImU32) {
	C.ImDrawList_AddConvexPolyFilled(self, points, num_points, col)
}

fn C.ImDrawList_AddConcavePolyFilled(self &C.ImDrawList, points &C.ImVec2, num_points int, col ImU32)

pub fn im_draw_list_add_concave_poly_filled(self &C.ImDrawList, points &C.ImVec2, num_points int, col ImU32) {
	C.ImDrawList_AddConcavePolyFilled(self, points, num_points, col)
}

fn C.ImDrawList_AddImage(self &C.ImDrawList, user_texture_id ImTextureID, p_min C.ImVec2, p_max C.ImVec2, uv_min C.ImVec2, uv_max C.ImVec2, col ImU32)

pub fn im_draw_list_add_image(self &C.ImDrawList, user_texture_id ImTextureID, p_min C.ImVec2, p_max C.ImVec2, uv_min C.ImVec2, uv_max C.ImVec2, col ImU32) {
	C.ImDrawList_AddImage(self, user_texture_id, p_min, p_max, uv_min, uv_max, col)
}

fn C.ImDrawList_AddImageQuad(self &C.ImDrawList, user_texture_id ImTextureID, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, uv1 C.ImVec2, uv2 C.ImVec2, uv3 C.ImVec2, uv4 C.ImVec2, col ImU32)

pub fn im_draw_list_add_image_quad(self &C.ImDrawList, user_texture_id ImTextureID, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, uv1 C.ImVec2, uv2 C.ImVec2, uv3 C.ImVec2, uv4 C.ImVec2, col ImU32) {
	C.ImDrawList_AddImageQuad(self, user_texture_id, p1, p2, p3, p4, uv1, uv2, uv3, uv4,
		col)
}

fn C.ImDrawList_AddImageRounded(self &C.ImDrawList, user_texture_id ImTextureID, p_min C.ImVec2, p_max C.ImVec2, uv_min C.ImVec2, uv_max C.ImVec2, col ImU32, rounding f32, flags ImDrawFlags)

pub fn im_draw_list_add_image_rounded(self &C.ImDrawList, user_texture_id ImTextureID, p_min C.ImVec2, p_max C.ImVec2, uv_min C.ImVec2, uv_max C.ImVec2, col ImU32, rounding f32, flags ImDrawFlags) {
	C.ImDrawList_AddImageRounded(self, user_texture_id, p_min, p_max, uv_min, uv_max,
		col, rounding, flags)
}

fn C.ImDrawList_PathClear(self &C.ImDrawList)

pub fn im_draw_list_path_clear(self &C.ImDrawList) {
	C.ImDrawList_PathClear(self)
}

fn C.ImDrawList_PathLineTo(self &C.ImDrawList, pos C.ImVec2)

pub fn im_draw_list_path_line_to(self &C.ImDrawList, pos C.ImVec2) {
	C.ImDrawList_PathLineTo(self, pos)
}

fn C.ImDrawList_PathLineToMergeDuplicate(self &C.ImDrawList, pos C.ImVec2)

pub fn im_draw_list_path_line_to_merge_duplicate(self &C.ImDrawList, pos C.ImVec2) {
	C.ImDrawList_PathLineToMergeDuplicate(self, pos)
}

fn C.ImDrawList_PathFillConvex(self &C.ImDrawList, col ImU32)

pub fn im_draw_list_path_fill_convex(self &C.ImDrawList, col ImU32) {
	C.ImDrawList_PathFillConvex(self, col)
}

fn C.ImDrawList_PathFillConcave(self &C.ImDrawList, col ImU32)

pub fn im_draw_list_path_fill_concave(self &C.ImDrawList, col ImU32) {
	C.ImDrawList_PathFillConcave(self, col)
}

fn C.ImDrawList_PathStroke(self &C.ImDrawList, col ImU32, flags ImDrawFlags, thickness f32)

pub fn im_draw_list_path_stroke(self &C.ImDrawList, col ImU32, flags ImDrawFlags, thickness f32) {
	C.ImDrawList_PathStroke(self, col, flags, thickness)
}

fn C.ImDrawList_PathArcTo(self &C.ImDrawList, center C.ImVec2, radius f32, a_min f32, a_max f32, num_segments int)

pub fn im_draw_list_path_arc_to(self &C.ImDrawList, center C.ImVec2, radius f32, a_min f32, a_max f32, num_segments int) {
	C.ImDrawList_PathArcTo(self, center, radius, a_min, a_max, num_segments)
}

fn C.ImDrawList_PathArcToFast(self &C.ImDrawList, center C.ImVec2, radius f32, a_min_of_12 int, a_max_of_12 int)

pub fn im_draw_list_path_arc_to_fast(self &C.ImDrawList, center C.ImVec2, radius f32, a_min_of_12 int, a_max_of_12 int) {
	C.ImDrawList_PathArcToFast(self, center, radius, a_min_of_12, a_max_of_12)
}

fn C.ImDrawList_PathEllipticalArcTo(self &C.ImDrawList, center C.ImVec2, radius C.ImVec2, rot f32, a_min f32, a_max f32, num_segments int)

pub fn im_draw_list_path_elliptical_arc_to(self &C.ImDrawList, center C.ImVec2, radius C.ImVec2, rot f32, a_min f32, a_max f32, num_segments int) {
	C.ImDrawList_PathEllipticalArcTo(self, center, radius, rot, a_min, a_max, num_segments)
}

fn C.ImDrawList_PathBezierCubicCurveTo(self &C.ImDrawList, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, num_segments int)

pub fn im_draw_list_path_bezier_cubic_curve_to(self &C.ImDrawList, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, num_segments int) {
	C.ImDrawList_PathBezierCubicCurveTo(self, p2, p3, p4, num_segments)
}

fn C.ImDrawList_PathBezierQuadraticCurveTo(self &C.ImDrawList, p2 C.ImVec2, p3 C.ImVec2, num_segments int)

pub fn im_draw_list_path_bezier_quadratic_curve_to(self &C.ImDrawList, p2 C.ImVec2, p3 C.ImVec2, num_segments int) {
	C.ImDrawList_PathBezierQuadraticCurveTo(self, p2, p3, num_segments)
}

fn C.ImDrawList_PathRect(self &C.ImDrawList, rect_min C.ImVec2, rect_max C.ImVec2, rounding f32, flags ImDrawFlags)

pub fn im_draw_list_path_rect(self &C.ImDrawList, rect_min C.ImVec2, rect_max C.ImVec2, rounding f32, flags ImDrawFlags) {
	C.ImDrawList_PathRect(self, rect_min, rect_max, rounding, flags)
}

fn C.ImDrawList_AddCallback(self &C.ImDrawList, callback ImDrawCallback, callback_data voidptr)

pub fn im_draw_list_add_callback(self &C.ImDrawList, callback ImDrawCallback, callback_data voidptr) {
	C.ImDrawList_AddCallback(self, callback, callback_data)
}

fn C.ImDrawList_AddDrawCmd(self &C.ImDrawList)

pub fn im_draw_list_add_draw_cmd(self &C.ImDrawList) {
	C.ImDrawList_AddDrawCmd(self)
}

fn C.ImDrawList_CloneOutput(self &C.ImDrawList) &C.ImDrawList

pub fn im_draw_list_clone_output(self &C.ImDrawList) &C.ImDrawList {
	return C.ImDrawList_CloneOutput(self)
}

fn C.ImDrawList_ChannelsSplit(self &C.ImDrawList, count int)

pub fn im_draw_list_channels_split(self &C.ImDrawList, count int) {
	C.ImDrawList_ChannelsSplit(self, count)
}

fn C.ImDrawList_ChannelsMerge(self &C.ImDrawList)

pub fn im_draw_list_channels_merge(self &C.ImDrawList) {
	C.ImDrawList_ChannelsMerge(self)
}

fn C.ImDrawList_ChannelsSetCurrent(self &C.ImDrawList, n int)

pub fn im_draw_list_channels_set_current(self &C.ImDrawList, n int) {
	C.ImDrawList_ChannelsSetCurrent(self, n)
}

fn C.ImDrawList_PrimReserve(self &C.ImDrawList, idx_count int, vtx_count int)

pub fn im_draw_list_prim_reserve(self &C.ImDrawList, idx_count int, vtx_count int) {
	C.ImDrawList_PrimReserve(self, idx_count, vtx_count)
}

fn C.ImDrawList_PrimUnreserve(self &C.ImDrawList, idx_count int, vtx_count int)

pub fn im_draw_list_prim_unreserve(self &C.ImDrawList, idx_count int, vtx_count int) {
	C.ImDrawList_PrimUnreserve(self, idx_count, vtx_count)
}

fn C.ImDrawList_PrimRect(self &C.ImDrawList, a C.ImVec2, b C.ImVec2, col ImU32)

pub fn im_draw_list_prim_rect(self &C.ImDrawList, a C.ImVec2, b C.ImVec2, col ImU32) {
	C.ImDrawList_PrimRect(self, a, b, col)
}

fn C.ImDrawList_PrimRectUV(self &C.ImDrawList, a C.ImVec2, b C.ImVec2, uv_a C.ImVec2, uv_b C.ImVec2, col ImU32)

pub fn im_draw_list_prim_rect_uv(self &C.ImDrawList, a C.ImVec2, b C.ImVec2, uv_a C.ImVec2, uv_b C.ImVec2, col ImU32) {
	C.ImDrawList_PrimRectUV(self, a, b, uv_a, uv_b, col)
}

fn C.ImDrawList_PrimQuadUV(self &C.ImDrawList, a C.ImVec2, b C.ImVec2, c C.ImVec2, d C.ImVec2, uv_a C.ImVec2, uv_b C.ImVec2, uv_c C.ImVec2, uv_d C.ImVec2, col ImU32)

pub fn im_draw_list_prim_quad_uv(self &C.ImDrawList, a C.ImVec2, b C.ImVec2, c C.ImVec2, d C.ImVec2, uv_a C.ImVec2, uv_b C.ImVec2, uv_c C.ImVec2, uv_d C.ImVec2, col ImU32) {
	C.ImDrawList_PrimQuadUV(self, a, b, c, d, uv_a, uv_b, uv_c, uv_d, col)
}

fn C.ImDrawList_PrimWriteVtx(self &C.ImDrawList, pos C.ImVec2, uv C.ImVec2, col ImU32)

pub fn im_draw_list_prim_write_vtx(self &C.ImDrawList, pos C.ImVec2, uv C.ImVec2, col ImU32) {
	C.ImDrawList_PrimWriteVtx(self, pos, uv, col)
}

fn C.ImDrawList_PrimWriteIdx(self &C.ImDrawList, idx ImDrawIdx)

pub fn im_draw_list_prim_write_idx(self &C.ImDrawList, idx ImDrawIdx) {
	C.ImDrawList_PrimWriteIdx(self, idx)
}

fn C.ImDrawList_PrimVtx(self &C.ImDrawList, pos C.ImVec2, uv C.ImVec2, col ImU32)

pub fn im_draw_list_prim_vtx(self &C.ImDrawList, pos C.ImVec2, uv C.ImVec2, col ImU32) {
	C.ImDrawList_PrimVtx(self, pos, uv, col)
}

fn C.ImDrawList__ResetForNewFrame(self &C.ImDrawList)

pub fn im_draw_list__reset_for_new_frame(self &C.ImDrawList) {
	C.ImDrawList__ResetForNewFrame(self)
}

fn C.ImDrawList__ClearFreeMemory(self &C.ImDrawList)

pub fn im_draw_list__clear_free_memory(self &C.ImDrawList) {
	C.ImDrawList__ClearFreeMemory(self)
}

fn C.ImDrawList__PopUnusedDrawCmd(self &C.ImDrawList)

pub fn im_draw_list__pop_unused_draw_cmd(self &C.ImDrawList) {
	C.ImDrawList__PopUnusedDrawCmd(self)
}

fn C.ImDrawList__TryMergeDrawCmds(self &C.ImDrawList)

pub fn im_draw_list__try_merge_draw_cmds(self &C.ImDrawList) {
	C.ImDrawList__TryMergeDrawCmds(self)
}

fn C.ImDrawList__OnChangedClipRect(self &C.ImDrawList)

pub fn im_draw_list__on_changed_clip_rect(self &C.ImDrawList) {
	C.ImDrawList__OnChangedClipRect(self)
}

fn C.ImDrawList__OnChangedTextureID(self &C.ImDrawList)

pub fn im_draw_list__on_changed_texture_id(self &C.ImDrawList) {
	C.ImDrawList__OnChangedTextureID(self)
}

fn C.ImDrawList__OnChangedVtxOffset(self &C.ImDrawList)

pub fn im_draw_list__on_changed_vtx_offset(self &C.ImDrawList) {
	C.ImDrawList__OnChangedVtxOffset(self)
}

fn C.ImDrawList__SetTextureID(self &C.ImDrawList, texture_id ImTextureID)

pub fn im_draw_list__set_texture_id(self &C.ImDrawList, texture_id ImTextureID) {
	C.ImDrawList__SetTextureID(self, texture_id)
}

fn C.ImDrawList__CalcCircleAutoSegmentCount(self &C.ImDrawList, radius f32) int

pub fn im_draw_list__calc_circle_auto_segment_count(self &C.ImDrawList, radius f32) int {
	return C.ImDrawList__CalcCircleAutoSegmentCount(self, radius)
}

fn C.ImDrawList__PathArcToFastEx(self &C.ImDrawList, center C.ImVec2, radius f32, a_min_sample int, a_max_sample int, a_step int)

pub fn im_draw_list__path_arc_to_fast_ex(self &C.ImDrawList, center C.ImVec2, radius f32, a_min_sample int, a_max_sample int, a_step int) {
	C.ImDrawList__PathArcToFastEx(self, center, radius, a_min_sample, a_max_sample, a_step)
}

fn C.ImDrawList__PathArcToN(self &C.ImDrawList, center C.ImVec2, radius f32, a_min f32, a_max f32, num_segments int)

pub fn im_draw_list__path_arc_to_n(self &C.ImDrawList, center C.ImVec2, radius f32, a_min f32, a_max f32, num_segments int) {
	C.ImDrawList__PathArcToN(self, center, radius, a_min, a_max, num_segments)
}

fn C.ImDrawData_ImDrawData() &C.ImDrawData

pub fn im_draw_data_im_draw_data() &C.ImDrawData {
	return C.ImDrawData_ImDrawData()
}

fn C.ImDrawData_destroy(self &C.ImDrawData)

pub fn im_draw_data_destroy(self &C.ImDrawData) {
	C.ImDrawData_destroy(self)
}

fn C.ImDrawData_Clear(self &C.ImDrawData)

pub fn im_draw_data_clear(self &C.ImDrawData) {
	C.ImDrawData_Clear(self)
}

fn C.ImDrawData_AddDrawList(self &C.ImDrawData, draw_list &C.ImDrawList)

pub fn im_draw_data_add_draw_list(self &C.ImDrawData, draw_list &C.ImDrawList) {
	C.ImDrawData_AddDrawList(self, draw_list)
}

fn C.ImDrawData_DeIndexAllBuffers(self &C.ImDrawData)

pub fn im_draw_data_de_index_all_buffers(self &C.ImDrawData) {
	C.ImDrawData_DeIndexAllBuffers(self)
}

fn C.ImDrawData_ScaleClipRects(self &C.ImDrawData, fb_scale C.ImVec2)

pub fn im_draw_data_scale_clip_rects(self &C.ImDrawData, fb_scale C.ImVec2) {
	C.ImDrawData_ScaleClipRects(self, fb_scale)
}

fn C.ImFontConfig_ImFontConfig() &C.ImFontConfig

pub fn im_font_config_im_font_config() &C.ImFontConfig {
	return C.ImFontConfig_ImFontConfig()
}

fn C.ImFontConfig_destroy(self &C.ImFontConfig)

pub fn im_font_config_destroy(self &C.ImFontConfig) {
	C.ImFontConfig_destroy(self)
}

fn C.ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder() &C.ImFontGlyphRangesBuilder

pub fn im_font_glyph_ranges_builder_im_font_glyph_ranges_builder() &C.ImFontGlyphRangesBuilder {
	return C.ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder()
}

fn C.ImFontGlyphRangesBuilder_destroy(self &C.ImFontGlyphRangesBuilder)

pub fn im_font_glyph_ranges_builder_destroy(self &C.ImFontGlyphRangesBuilder) {
	C.ImFontGlyphRangesBuilder_destroy(self)
}

fn C.ImFontGlyphRangesBuilder_Clear(self &C.ImFontGlyphRangesBuilder)

pub fn im_font_glyph_ranges_builder_clear(self &C.ImFontGlyphRangesBuilder) {
	C.ImFontGlyphRangesBuilder_Clear(self)
}

fn C.ImFontGlyphRangesBuilder_GetBit(self &C.ImFontGlyphRangesBuilder, n usize) bool

pub fn im_font_glyph_ranges_builder_get_bit(self &C.ImFontGlyphRangesBuilder, n usize) bool {
	return C.ImFontGlyphRangesBuilder_GetBit(self, n)
}

fn C.ImFontGlyphRangesBuilder_SetBit(self &C.ImFontGlyphRangesBuilder, n usize)

pub fn im_font_glyph_ranges_builder_set_bit(self &C.ImFontGlyphRangesBuilder, n usize) {
	C.ImFontGlyphRangesBuilder_SetBit(self, n)
}

fn C.ImFontGlyphRangesBuilder_AddChar(self &C.ImFontGlyphRangesBuilder, c ImWchar)

pub fn im_font_glyph_ranges_builder_add_char(self &C.ImFontGlyphRangesBuilder, c ImWchar) {
	C.ImFontGlyphRangesBuilder_AddChar(self, c)
}

fn C.ImFontGlyphRangesBuilder_AddText(self &C.ImFontGlyphRangesBuilder, text &i8, text_end &i8)

pub fn im_font_glyph_ranges_builder_add_text(self &C.ImFontGlyphRangesBuilder, text &i8, text_end &i8) {
	C.ImFontGlyphRangesBuilder_AddText(self, text, text_end)
}

fn C.ImFontGlyphRangesBuilder_AddRanges(self &C.ImFontGlyphRangesBuilder, ranges &ImWchar)

pub fn im_font_glyph_ranges_builder_add_ranges(self &C.ImFontGlyphRangesBuilder, ranges &ImWchar) {
	C.ImFontGlyphRangesBuilder_AddRanges(self, ranges)
}

fn C.ImFontGlyphRangesBuilder_BuildRanges(self &C.ImFontGlyphRangesBuilder, out_ranges &C.ImVector_ImWchar)

pub fn im_font_glyph_ranges_builder_build_ranges(self &C.ImFontGlyphRangesBuilder, out_ranges &C.ImVector_ImWchar) {
	C.ImFontGlyphRangesBuilder_BuildRanges(self, out_ranges)
}

fn C.ImFontAtlasCustomRect_ImFontAtlasCustomRect() &C.ImFontAtlasCustomRect

pub fn im_font_atlas_custom_rect_im_font_atlas_custom_rect() &C.ImFontAtlasCustomRect {
	return C.ImFontAtlasCustomRect_ImFontAtlasCustomRect()
}

fn C.ImFontAtlasCustomRect_destroy(self &C.ImFontAtlasCustomRect)

pub fn im_font_atlas_custom_rect_destroy(self &C.ImFontAtlasCustomRect) {
	C.ImFontAtlasCustomRect_destroy(self)
}

fn C.ImFontAtlasCustomRect_IsPacked(self &C.ImFontAtlasCustomRect) bool

pub fn im_font_atlas_custom_rect_is_packed(self &C.ImFontAtlasCustomRect) bool {
	return C.ImFontAtlasCustomRect_IsPacked(self)
}

fn C.ImFontAtlas_ImFontAtlas() &C.ImFontAtlas

pub fn im_font_atlas_im_font_atlas() &C.ImFontAtlas {
	return C.ImFontAtlas_ImFontAtlas()
}

fn C.ImFontAtlas_destroy(self &C.ImFontAtlas)

pub fn im_font_atlas_destroy(self &C.ImFontAtlas) {
	C.ImFontAtlas_destroy(self)
}

fn C.ImFontAtlas_AddFont(self &C.ImFontAtlas, font_cfg &C.ImFontConfig) &C.ImFont

pub fn im_font_atlas_add_font(self &C.ImFontAtlas, font_cfg &C.ImFontConfig) &C.ImFont {
	return C.ImFontAtlas_AddFont(self, font_cfg)
}

fn C.ImFontAtlas_AddFontDefault(self &C.ImFontAtlas, font_cfg &C.ImFontConfig) &C.ImFont

pub fn im_font_atlas_add_font_default(self &C.ImFontAtlas, font_cfg &C.ImFontConfig) &C.ImFont {
	return C.ImFontAtlas_AddFontDefault(self, font_cfg)
}

fn C.ImFontAtlas_AddFontFromFileTTF(self &C.ImFontAtlas, filename &i8, size_pixels f32, font_cfg &C.ImFontConfig, glyph_ranges &ImWchar) &C.ImFont

pub fn im_font_atlas_add_font_from_file_ttf(self &C.ImFontAtlas, filename &i8, size_pixels f32, font_cfg &C.ImFontConfig, glyph_ranges &ImWchar) &C.ImFont {
	return C.ImFontAtlas_AddFontFromFileTTF(self, filename, size_pixels, font_cfg, glyph_ranges)
}

fn C.ImFontAtlas_AddFontFromMemoryTTF(self &C.ImFontAtlas, font_data voidptr, font_data_size int, size_pixels f32, font_cfg &C.ImFontConfig, glyph_ranges &ImWchar) &C.ImFont

pub fn im_font_atlas_add_font_from_memory_ttf(self &C.ImFontAtlas, font_data voidptr, font_data_size int, size_pixels f32, font_cfg &C.ImFontConfig, glyph_ranges &ImWchar) &C.ImFont {
	return C.ImFontAtlas_AddFontFromMemoryTTF(self, font_data, font_data_size, size_pixels,
		font_cfg, glyph_ranges)
}

fn C.ImFontAtlas_AddFontFromMemoryCompressedTTF(self &C.ImFontAtlas, compressed_font_data voidptr, compressed_font_data_size int, size_pixels f32, font_cfg &C.ImFontConfig, glyph_ranges &ImWchar) &C.ImFont

pub fn im_font_atlas_add_font_from_memory_compressed_ttf(self &C.ImFontAtlas, compressed_font_data voidptr, compressed_font_data_size int, size_pixels f32, font_cfg &C.ImFontConfig, glyph_ranges &ImWchar) &C.ImFont {
	return C.ImFontAtlas_AddFontFromMemoryCompressedTTF(self, compressed_font_data, compressed_font_data_size,
		size_pixels, font_cfg, glyph_ranges)
}

fn C.ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(self &C.ImFontAtlas, compressed_font_data_base85 &i8, size_pixels f32, font_cfg &C.ImFontConfig, glyph_ranges &ImWchar) &C.ImFont

pub fn im_font_atlas_add_font_from_memory_compressed_base85_ttf(self &C.ImFontAtlas, compressed_font_data_base85 &i8, size_pixels f32, font_cfg &C.ImFontConfig, glyph_ranges &ImWchar) &C.ImFont {
	return C.ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(self, compressed_font_data_base85,
		size_pixels, font_cfg, glyph_ranges)
}

fn C.ImFontAtlas_ClearInputData(self &C.ImFontAtlas)

pub fn im_font_atlas_clear_input_data(self &C.ImFontAtlas) {
	C.ImFontAtlas_ClearInputData(self)
}

fn C.ImFontAtlas_ClearTexData(self &C.ImFontAtlas)

pub fn im_font_atlas_clear_tex_data(self &C.ImFontAtlas) {
	C.ImFontAtlas_ClearTexData(self)
}

fn C.ImFontAtlas_ClearFonts(self &C.ImFontAtlas)

pub fn im_font_atlas_clear_fonts(self &C.ImFontAtlas) {
	C.ImFontAtlas_ClearFonts(self)
}

fn C.ImFontAtlas_Clear(self &C.ImFontAtlas)

pub fn im_font_atlas_clear(self &C.ImFontAtlas) {
	C.ImFontAtlas_Clear(self)
}

fn C.ImFontAtlas_Build(self &C.ImFontAtlas) bool

pub fn im_font_atlas_build(self &C.ImFontAtlas) bool {
	return C.ImFontAtlas_Build(self)
}

fn C.ImFontAtlas_GetTexDataAsAlpha8(self &C.ImFontAtlas, out_pixels &&u8, out_width &int, out_height &int, out_bytes_per_pixel &int)

pub fn im_font_atlas_get_tex_data_as_alpha8(self &C.ImFontAtlas, out_pixels &&u8, out_width &int, out_height &int, out_bytes_per_pixel &int) {
	C.ImFontAtlas_GetTexDataAsAlpha8(self, out_pixels, out_width, out_height, out_bytes_per_pixel)
}

fn C.ImFontAtlas_GetTexDataAsRGBA32(self &C.ImFontAtlas, out_pixels &&u8, out_width &int, out_height &int, out_bytes_per_pixel &int)

pub fn im_font_atlas_get_tex_data_as_rgba_32(self &C.ImFontAtlas, out_pixels &&u8, out_width &int, out_height &int, out_bytes_per_pixel &int) {
	C.ImFontAtlas_GetTexDataAsRGBA32(self, out_pixels, out_width, out_height, out_bytes_per_pixel)
}

fn C.ImFontAtlas_IsBuilt(self &C.ImFontAtlas) bool

pub fn im_font_atlas_is_built(self &C.ImFontAtlas) bool {
	return C.ImFontAtlas_IsBuilt(self)
}

fn C.ImFontAtlas_SetTexID(self &C.ImFontAtlas, id ImTextureID)

pub fn im_font_atlas_set_tex_id(self &C.ImFontAtlas, id ImTextureID) {
	C.ImFontAtlas_SetTexID(self, id)
}

fn C.ImFontAtlas_GetGlyphRangesDefault(self &C.ImFontAtlas) &ImWchar

pub fn im_font_atlas_get_glyph_ranges_default(self &C.ImFontAtlas) &ImWchar {
	return C.ImFontAtlas_GetGlyphRangesDefault(self)
}

fn C.ImFontAtlas_GetGlyphRangesGreek(self &C.ImFontAtlas) &ImWchar

pub fn im_font_atlas_get_glyph_ranges_greek(self &C.ImFontAtlas) &ImWchar {
	return C.ImFontAtlas_GetGlyphRangesGreek(self)
}

fn C.ImFontAtlas_GetGlyphRangesKorean(self &C.ImFontAtlas) &ImWchar

pub fn im_font_atlas_get_glyph_ranges_korean(self &C.ImFontAtlas) &ImWchar {
	return C.ImFontAtlas_GetGlyphRangesKorean(self)
}

fn C.ImFontAtlas_GetGlyphRangesJapanese(self &C.ImFontAtlas) &ImWchar

pub fn im_font_atlas_get_glyph_ranges_japanese(self &C.ImFontAtlas) &ImWchar {
	return C.ImFontAtlas_GetGlyphRangesJapanese(self)
}

fn C.ImFontAtlas_GetGlyphRangesChineseFull(self &C.ImFontAtlas) &ImWchar

pub fn im_font_atlas_get_glyph_ranges_chinese_full(self &C.ImFontAtlas) &ImWchar {
	return C.ImFontAtlas_GetGlyphRangesChineseFull(self)
}

fn C.ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon(self &C.ImFontAtlas) &ImWchar

pub fn im_font_atlas_get_glyph_ranges_chinese_simplified_common(self &C.ImFontAtlas) &ImWchar {
	return C.ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon(self)
}

fn C.ImFontAtlas_GetGlyphRangesCyrillic(self &C.ImFontAtlas) &ImWchar

pub fn im_font_atlas_get_glyph_ranges_cyrillic(self &C.ImFontAtlas) &ImWchar {
	return C.ImFontAtlas_GetGlyphRangesCyrillic(self)
}

fn C.ImFontAtlas_GetGlyphRangesThai(self &C.ImFontAtlas) &ImWchar

pub fn im_font_atlas_get_glyph_ranges_thai(self &C.ImFontAtlas) &ImWchar {
	return C.ImFontAtlas_GetGlyphRangesThai(self)
}

fn C.ImFontAtlas_GetGlyphRangesVietnamese(self &C.ImFontAtlas) &ImWchar

pub fn im_font_atlas_get_glyph_ranges_vietnamese(self &C.ImFontAtlas) &ImWchar {
	return C.ImFontAtlas_GetGlyphRangesVietnamese(self)
}

fn C.ImFontAtlas_AddCustomRectRegular(self &C.ImFontAtlas, width int, height int) int

pub fn im_font_atlas_add_custom_rect_regular(self &C.ImFontAtlas, width int, height int) int {
	return C.ImFontAtlas_AddCustomRectRegular(self, width, height)
}

fn C.ImFontAtlas_AddCustomRectFontGlyph(self &C.ImFontAtlas, font &C.ImFont, id ImWchar, width int, height int, advance_x f32, offset C.ImVec2) int

pub fn im_font_atlas_add_custom_rect_font_glyph(self &C.ImFontAtlas, font &C.ImFont, id ImWchar, width int, height int, advance_x f32, offset C.ImVec2) int {
	return C.ImFontAtlas_AddCustomRectFontGlyph(self, font, id, width, height, advance_x,
		offset)
}

fn C.ImFontAtlas_GetCustomRectByIndex(self &C.ImFontAtlas, index int) &C.ImFontAtlasCustomRect

pub fn im_font_atlas_get_custom_rect_by_index(self &C.ImFontAtlas, index int) &C.ImFontAtlasCustomRect {
	return C.ImFontAtlas_GetCustomRectByIndex(self, index)
}

fn C.ImFontAtlas_CalcCustomRectUV(self &C.ImFontAtlas, rect &C.ImFontAtlasCustomRect, out_uv_min &C.ImVec2, out_uv_max &C.ImVec2)

pub fn im_font_atlas_calc_custom_rect_uv(self &C.ImFontAtlas, rect &C.ImFontAtlasCustomRect, out_uv_min &C.ImVec2, out_uv_max &C.ImVec2) {
	C.ImFontAtlas_CalcCustomRectUV(self, rect, out_uv_min, out_uv_max)
}

fn C.ImFontAtlas_GetMouseCursorTexData(self &C.ImFontAtlas, cursor ImGuiMouseCursor, out_offset &C.ImVec2, out_size &C.ImVec2, out_uv_border &C.ImVec2, out_uv_fill &C.ImVec2) bool

pub fn im_font_atlas_get_mouse_cursor_tex_data(self &C.ImFontAtlas, cursor ImGuiMouseCursor, out_offset &C.ImVec2, out_size &C.ImVec2, out_uv_border &C.ImVec2, out_uv_fill &C.ImVec2) bool {
	return C.ImFontAtlas_GetMouseCursorTexData(self, cursor, out_offset, out_size, out_uv_border,
		out_uv_fill)
}

fn C.ImFont_ImFont() &C.ImFont

pub fn im_font_im_font() &C.ImFont {
	return C.ImFont_ImFont()
}

fn C.ImFont_destroy(self &C.ImFont)

pub fn im_font_destroy(self &C.ImFont) {
	C.ImFont_destroy(self)
}

fn C.ImFont_FindGlyph(self &C.ImFont, c ImWchar) &C.ImFontGlyph

pub fn im_font_find_glyph(self &C.ImFont, c ImWchar) &C.ImFontGlyph {
	return C.ImFont_FindGlyph(self, c)
}

fn C.ImFont_FindGlyphNoFallback(self &C.ImFont, c ImWchar) &C.ImFontGlyph

pub fn im_font_find_glyph_no_fallback(self &C.ImFont, c ImWchar) &C.ImFontGlyph {
	return C.ImFont_FindGlyphNoFallback(self, c)
}

fn C.ImFont_GetCharAdvance(self &C.ImFont, c ImWchar) f32

pub fn im_font_get_char_advance(self &C.ImFont, c ImWchar) f32 {
	return C.ImFont_GetCharAdvance(self, c)
}

fn C.ImFont_IsLoaded(self &C.ImFont) bool

pub fn im_font_is_loaded(self &C.ImFont) bool {
	return C.ImFont_IsLoaded(self)
}

fn C.ImFont_GetDebugName(self &C.ImFont) &i8

pub fn im_font_get_debug_name(self &C.ImFont) &i8 {
	return C.ImFont_GetDebugName(self)
}

fn C.ImFont_CalcTextSizeA(p_out &C.ImVec2, self &C.ImFont, size f32, max_width f32, wrap_width f32, text_begin &i8, text_end &i8, remaining &&u8)

pub fn im_font_calc_text_size_a(p_out &C.ImVec2, self &C.ImFont, size f32, max_width f32, wrap_width f32, text_begin &i8, text_end &i8, remaining &&u8) {
	C.ImFont_CalcTextSizeA(p_out, self, size, max_width, wrap_width, text_begin, text_end,
		remaining)
}

fn C.ImFont_CalcWordWrapPositionA(self &C.ImFont, scale f32, text &i8, text_end &i8, wrap_width f32) &i8

pub fn im_font_calc_word_wrap_position_a(self &C.ImFont, scale f32, text &i8, text_end &i8, wrap_width f32) &i8 {
	return C.ImFont_CalcWordWrapPositionA(self, scale, text, text_end, wrap_width)
}

fn C.ImFont_RenderChar(self &C.ImFont, draw_list &C.ImDrawList, size f32, pos C.ImVec2, col ImU32, c ImWchar)

pub fn im_font_render_char(self &C.ImFont, draw_list &C.ImDrawList, size f32, pos C.ImVec2, col ImU32, c ImWchar) {
	C.ImFont_RenderChar(self, draw_list, size, pos, col, c)
}

fn C.ImFont_RenderText(self &C.ImFont, draw_list &C.ImDrawList, size f32, pos C.ImVec2, col ImU32, clip_rect C.ImVec4, text_begin &i8, text_end &i8, wrap_width f32, cpu_fine_clip bool)

pub fn im_font_render_text(self &C.ImFont, draw_list &C.ImDrawList, size f32, pos C.ImVec2, col ImU32, clip_rect C.ImVec4, text_begin &i8, text_end &i8, wrap_width f32, cpu_fine_clip bool) {
	C.ImFont_RenderText(self, draw_list, size, pos, col, clip_rect, text_begin, text_end,
		wrap_width, cpu_fine_clip)
}

fn C.ImFont_BuildLookupTable(self &C.ImFont)

pub fn im_font_build_lookup_table(self &C.ImFont) {
	C.ImFont_BuildLookupTable(self)
}

fn C.ImFont_ClearOutputData(self &C.ImFont)

pub fn im_font_clear_output_data(self &C.ImFont) {
	C.ImFont_ClearOutputData(self)
}

fn C.ImFont_GrowIndex(self &C.ImFont, new_size int)

pub fn im_font_grow_index(self &C.ImFont, new_size int) {
	C.ImFont_GrowIndex(self, new_size)
}

fn C.ImFont_AddGlyph(self &C.ImFont, src_cfg &C.ImFontConfig, c ImWchar, x0 f32, y0 f32, x1 f32, y1 f32, u0 f32, v0 f32, u1 f32, v1 f32, advance_x f32)

pub fn im_font_add_glyph(self &C.ImFont, src_cfg &C.ImFontConfig, c ImWchar, x0 f32, y0 f32, x1 f32, y1 f32, u0 f32, v0 f32, u1 f32, v1 f32, advance_x f32) {
	C.ImFont_AddGlyph(self, src_cfg, c, x0, y0, x1, y1, u0, v0, u1, v1, advance_x)
}

fn C.ImFont_AddRemapChar(self &C.ImFont, dst ImWchar, src ImWchar, overwrite_dst bool)

pub fn im_font_add_remap_char(self &C.ImFont, dst ImWchar, src ImWchar, overwrite_dst bool) {
	C.ImFont_AddRemapChar(self, dst, src, overwrite_dst)
}

fn C.ImFont_SetGlyphVisible(self &C.ImFont, c ImWchar, visible bool)

pub fn im_font_set_glyph_visible(self &C.ImFont, c ImWchar, visible bool) {
	C.ImFont_SetGlyphVisible(self, c, visible)
}

fn C.ImFont_IsGlyphRangeUnused(self &C.ImFont, c_begin u32, c_last u32) bool

pub fn im_font_is_glyph_range_unused(self &C.ImFont, c_begin u32, c_last u32) bool {
	return C.ImFont_IsGlyphRangeUnused(self, c_begin, c_last)
}

fn C.ImGuiViewport_ImGuiViewport() &C.ImGuiViewport

pub fn im_gui_viewport_im_gui_viewport() &C.ImGuiViewport {
	return C.ImGuiViewport_ImGuiViewport()
}

fn C.ImGuiViewport_destroy(self &C.ImGuiViewport)

pub fn im_gui_viewport_destroy(self &C.ImGuiViewport) {
	C.ImGuiViewport_destroy(self)
}

fn C.ImGuiViewport_GetCenter(p_out &C.ImVec2, self &C.ImGuiViewport)

pub fn im_gui_viewport_get_center(p_out &C.ImVec2, self &C.ImGuiViewport) {
	C.ImGuiViewport_GetCenter(p_out, self)
}

fn C.ImGuiViewport_GetWorkCenter(p_out &C.ImVec2, self &C.ImGuiViewport)

pub fn im_gui_viewport_get_work_center(p_out &C.ImVec2, self &C.ImGuiViewport) {
	C.ImGuiViewport_GetWorkCenter(p_out, self)
}

fn C.ImGuiPlatformIO_ImGuiPlatformIO() &C.ImGuiPlatformIO

pub fn im_gui_platform_io_im_gui_platform_io() &C.ImGuiPlatformIO {
	return C.ImGuiPlatformIO_ImGuiPlatformIO()
}

fn C.ImGuiPlatformIO_destroy(self &C.ImGuiPlatformIO)

pub fn im_gui_platform_io_destroy(self &C.ImGuiPlatformIO) {
	C.ImGuiPlatformIO_destroy(self)
}

fn C.ImGuiPlatformMonitor_ImGuiPlatformMonitor() &C.ImGuiPlatformMonitor

pub fn im_gui_platform_monitor_im_gui_platform_monitor() &C.ImGuiPlatformMonitor {
	return C.ImGuiPlatformMonitor_ImGuiPlatformMonitor()
}

fn C.ImGuiPlatformMonitor_destroy(self &C.ImGuiPlatformMonitor)

pub fn im_gui_platform_monitor_destroy(self &C.ImGuiPlatformMonitor) {
	C.ImGuiPlatformMonitor_destroy(self)
}

fn C.ImGuiPlatformImeData_ImGuiPlatformImeData() &C.ImGuiPlatformImeData

pub fn im_gui_platform_ime_data_im_gui_platform_ime_data() &C.ImGuiPlatformImeData {
	return C.ImGuiPlatformImeData_ImGuiPlatformImeData()
}

fn C.ImGuiPlatformImeData_destroy(self &C.ImGuiPlatformImeData)

pub fn im_gui_platform_ime_data_destroy(self &C.ImGuiPlatformImeData) {
	C.ImGuiPlatformImeData_destroy(self)
}

fn C.igImHashData(data voidptr, data_size usize, seed ImGuiID) ImGuiID

pub fn ig_im_hash_data(data voidptr, data_size usize, seed ImGuiID) ImGuiID {
	return C.igImHashData(data, data_size, seed)
}

fn C.igImHashStr(data &i8, data_size usize, seed ImGuiID) ImGuiID

pub fn ig_im_hash_str(data &i8, data_size usize, seed ImGuiID) ImGuiID {
	return C.igImHashStr(data, data_size, seed)
}

fn C.igImQsort(base voidptr, count usize, size_of_element usize, compare_func fn (voidptr, voidptr) int)

pub fn ig_im_qsort(base voidptr, count usize, size_of_element usize, compare_func fn (voidptr, voidptr) int) {
	C.igImQsort(base, count, size_of_element, compare_func)
}

fn C.igImAlphaBlendColors(col_a ImU32, col_b ImU32) ImU32

pub fn ig_im_alpha_blend_colors(col_a ImU32, col_b ImU32) ImU32 {
	return C.igImAlphaBlendColors(col_a, col_b)
}

fn C.igImIsPowerOfTwo_Int(v int) bool

pub fn ig_im_is_power_of_two_int(v int) bool {
	return C.igImIsPowerOfTwo_Int(v)
}

fn C.igImIsPowerOfTwo_U64(v ImU64) bool

pub fn ig_im_is_power_of_two_u64(v ImU64) bool {
	return C.igImIsPowerOfTwo_U64(v)
}

fn C.igImUpperPowerOfTwo(v int) int

pub fn ig_im_upper_power_of_two(v int) int {
	return C.igImUpperPowerOfTwo(v)
}

fn C.igImStricmp(str1 &i8, str2 &i8) int

pub fn ig_im_stricmp(str1 &i8, str2 &i8) int {
	return C.igImStricmp(str1, str2)
}

fn C.igImStrnicmp(str1 &i8, str2 &i8, count usize) int

pub fn ig_im_strnicmp(str1 &i8, str2 &i8, count usize) int {
	return C.igImStrnicmp(str1, str2, count)
}

fn C.igImStrncpy(dst &i8, src &i8, count usize)

pub fn ig_im_strncpy(dst &i8, src &i8, count usize) {
	C.igImStrncpy(dst, src, count)
}

fn C.igImStrdup(str &i8) &i8

pub fn ig_im_strdup(str &i8) &i8 {
	return C.igImStrdup(str)
}

fn C.igImStrdupcpy(dst &i8, p_dst_size &usize, str &i8) &i8

pub fn ig_im_strdupcpy(dst &i8, p_dst_size &usize, str &i8) &i8 {
	return C.igImStrdupcpy(dst, p_dst_size, str)
}

fn C.igImStrchrRange(str_begin &i8, str_end &i8, c i8) &i8

pub fn ig_im_strchr_range(str_begin &i8, str_end &i8, c i8) &i8 {
	return C.igImStrchrRange(str_begin, str_end, c)
}

fn C.igImStreolRange(str &i8, str_end &i8) &i8

pub fn ig_im_streol_range(str &i8, str_end &i8) &i8 {
	return C.igImStreolRange(str, str_end)
}

fn C.igImStristr(haystack &i8, haystack_end &i8, needle &i8, needle_end &i8) &i8

pub fn ig_im_stristr(haystack &i8, haystack_end &i8, needle &i8, needle_end &i8) &i8 {
	return C.igImStristr(haystack, haystack_end, needle, needle_end)
}

fn C.igImStrTrimBlanks(str &i8)

pub fn ig_im_str_trim_blanks(str &i8) {
	C.igImStrTrimBlanks(str)
}

fn C.igImStrSkipBlank(str &i8) &i8

pub fn ig_im_str_skip_blank(str &i8) &i8 {
	return C.igImStrSkipBlank(str)
}

fn C.igImStrlenW(str &ImWchar) int

pub fn ig_im_strlen_w(str &ImWchar) int {
	return C.igImStrlenW(str)
}

fn C.igImStrbolW(buf_mid_line &ImWchar, buf_begin &ImWchar) &ImWchar

pub fn ig_im_strbol_w(buf_mid_line &ImWchar, buf_begin &ImWchar) &ImWchar {
	return C.igImStrbolW(buf_mid_line, buf_begin)
}

fn C.igImToUpper(c i8) i8

pub fn ig_im_to_upper(c i8) i8 {
	return C.igImToUpper(c)
}

fn C.igImCharIsBlankA(c i8) bool

pub fn ig_im_char_is_blank_a(c i8) bool {
	return C.igImCharIsBlankA(c)
}

fn C.igImCharIsBlankW(c u32) bool

pub fn ig_im_char_is_blank_w(c u32) bool {
	return C.igImCharIsBlankW(c)
}

fn C.igImCharIsXdigitA(c i8) bool

pub fn ig_im_char_is_xdigit_a(c i8) bool {
	return C.igImCharIsXdigitA(c)
}

@[c2v_variadic]
fn C.igImFormatString(buf &i8, buf_size usize, fmt ...&i8) int

pub fn ig_im_format_string(buf &i8, buf_size usize, fmt &i8) int {
	return C.igImFormatString(buf, buf_size, fmt)
}

fn C.igImFormatStringV(buf &i8, buf_size usize, fmt &i8, args C.va_list) int

pub fn ig_im_format_string_v(buf &i8, buf_size usize, fmt &i8, args C.va_list) int {
	return C.igImFormatStringV(buf, buf_size, fmt, args)
}

@[c2v_variadic]
fn C.igImFormatStringToTempBuffer(out_buf &&u8, out_buf_end &&u8, fmt ...&i8)

pub fn ig_im_format_string_to_temp_buffer(out_buf &&u8, out_buf_end &&u8, fmt &i8) {
	C.igImFormatStringToTempBuffer(out_buf, out_buf_end, fmt)
}

fn C.igImFormatStringToTempBufferV(out_buf &&u8, out_buf_end &&u8, fmt &i8, args C.va_list)

pub fn ig_im_format_string_to_temp_buffer_v(out_buf &&u8, out_buf_end &&u8, fmt &i8, args C.va_list) {
	C.igImFormatStringToTempBufferV(out_buf, out_buf_end, fmt, args)
}

fn C.igImParseFormatFindStart(format &i8) &i8

pub fn ig_im_parse_format_find_start(format &i8) &i8 {
	return C.igImParseFormatFindStart(format)
}

fn C.igImParseFormatFindEnd(format &i8) &i8

pub fn ig_im_parse_format_find_end(format &i8) &i8 {
	return C.igImParseFormatFindEnd(format)
}

fn C.igImParseFormatTrimDecorations(format &i8, buf &i8, buf_size usize) &i8

pub fn ig_im_parse_format_trim_decorations(format &i8, buf &i8, buf_size usize) &i8 {
	return C.igImParseFormatTrimDecorations(format, buf, buf_size)
}

fn C.igImParseFormatSanitizeForPrinting(fmt_in &i8, fmt_out &i8, fmt_out_size usize)

pub fn ig_im_parse_format_sanitize_for_printing(fmt_in &i8, fmt_out &i8, fmt_out_size usize) {
	C.igImParseFormatSanitizeForPrinting(fmt_in, fmt_out, fmt_out_size)
}

fn C.igImParseFormatSanitizeForScanning(fmt_in &i8, fmt_out &i8, fmt_out_size usize) &i8

pub fn ig_im_parse_format_sanitize_for_scanning(fmt_in &i8, fmt_out &i8, fmt_out_size usize) &i8 {
	return C.igImParseFormatSanitizeForScanning(fmt_in, fmt_out, fmt_out_size)
}

fn C.igImParseFormatPrecision(format &i8, default_value int) int

pub fn ig_im_parse_format_precision(format &i8, default_value int) int {
	return C.igImParseFormatPrecision(format, default_value)
}

fn C.igImTextCharToUtf8(out_buf &i8, c u32) &i8

pub fn ig_im_text_char_to_utf8(out_buf &i8, c u32) &i8 {
	return C.igImTextCharToUtf8(out_buf, c)
}

fn C.igImTextStrToUtf8(out_buf &i8, out_buf_size int, in_text &ImWchar, in_text_end &ImWchar) int

pub fn ig_im_text_str_to_utf8(out_buf &i8, out_buf_size int, in_text &ImWchar, in_text_end &ImWchar) int {
	return C.igImTextStrToUtf8(out_buf, out_buf_size, in_text, in_text_end)
}

fn C.igImTextCharFromUtf8(out_char &u32, in_text &i8, in_text_end &i8) int

pub fn ig_im_text_char_from_utf8(out_char &u32, in_text &i8, in_text_end &i8) int {
	return C.igImTextCharFromUtf8(out_char, in_text, in_text_end)
}

fn C.igImTextStrFromUtf8(out_buf &ImWchar, out_buf_size int, in_text &i8, in_text_end &i8, in_remaining &&u8) int

pub fn ig_im_text_str_from_utf8(out_buf &ImWchar, out_buf_size int, in_text &i8, in_text_end &i8, in_remaining &&u8) int {
	return C.igImTextStrFromUtf8(out_buf, out_buf_size, in_text, in_text_end, in_remaining)
}

fn C.igImTextCountCharsFromUtf8(in_text &i8, in_text_end &i8) int

pub fn ig_im_text_count_chars_from_utf8(in_text &i8, in_text_end &i8) int {
	return C.igImTextCountCharsFromUtf8(in_text, in_text_end)
}

fn C.igImTextCountUtf8BytesFromChar(in_text &i8, in_text_end &i8) int

pub fn ig_im_text_count_utf8_bytes_from_char(in_text &i8, in_text_end &i8) int {
	return C.igImTextCountUtf8BytesFromChar(in_text, in_text_end)
}

fn C.igImTextCountUtf8BytesFromStr(in_text &ImWchar, in_text_end &ImWchar) int

pub fn ig_im_text_count_utf8_bytes_from_str(in_text &ImWchar, in_text_end &ImWchar) int {
	return C.igImTextCountUtf8BytesFromStr(in_text, in_text_end)
}

fn C.igImTextFindPreviousUtf8Codepoint(in_text_start &i8, in_text_curr &i8) &i8

pub fn ig_im_text_find_previous_utf8_codepoint(in_text_start &i8, in_text_curr &i8) &i8 {
	return C.igImTextFindPreviousUtf8Codepoint(in_text_start, in_text_curr)
}

fn C.igImTextCountLines(in_text &i8, in_text_end &i8) int

pub fn ig_im_text_count_lines(in_text &i8, in_text_end &i8) int {
	return C.igImTextCountLines(in_text, in_text_end)
}

fn C.igImFileOpen(filename &i8, mode &i8) C.ImFileHandle

pub fn ig_im_file_open(filename &i8, mode &i8) C.ImFileHandle {
	return C.igImFileOpen(filename, mode)
}

fn C.igImFileClose(file C.ImFileHandle) bool

pub fn ig_im_file_close(file C.ImFileHandle) bool {
	return C.igImFileClose(file)
}

fn C.igImFileGetSize(file C.ImFileHandle) ImU64

pub fn ig_im_file_get_size(file C.ImFileHandle) ImU64 {
	return C.igImFileGetSize(file)
}

fn C.igImFileRead(data voidptr, size ImU64, count ImU64, file C.ImFileHandle) ImU64

pub fn ig_im_file_read(data voidptr, size ImU64, count ImU64, file C.ImFileHandle) ImU64 {
	return C.igImFileRead(data, size, count, file)
}

fn C.igImFileWrite(data voidptr, size ImU64, count ImU64, file C.ImFileHandle) ImU64

pub fn ig_im_file_write(data voidptr, size ImU64, count ImU64, file C.ImFileHandle) ImU64 {
	return C.igImFileWrite(data, size, count, file)
}

fn C.igImFileLoadToMemory(filename &i8, mode &i8, out_file_size &usize, padding_bytes int) voidptr

pub fn ig_im_file_load_to_memory(filename &i8, mode &i8, out_file_size &usize, padding_bytes int) voidptr {
	return C.igImFileLoadToMemory(filename, mode, out_file_size, padding_bytes)
}

fn C.igImPow_Float(x f32, y f32) f32

pub fn ig_im_pow_float(x f32, y f32) f32 {
	return C.igImPow_Float(x, y)
}

fn C.igImPow_double(x f64, y f64) f64

pub fn ig_im_pow_double(x f64, y f64) f64 {
	return C.igImPow_double(x, y)
}

fn C.igImLog_Float(x f32) f32

pub fn ig_im_log_float(x f32) f32 {
	return C.igImLog_Float(x)
}

fn C.igImLog_double(x f64) f64

pub fn ig_im_log_double(x f64) f64 {
	return C.igImLog_double(x)
}

fn C.igImAbs_Int(x int) int

pub fn ig_im_abs_int(x int) int {
	return C.igImAbs_Int(x)
}

fn C.igImAbs_Float(x f32) f32

pub fn ig_im_abs_float(x f32) f32 {
	return C.igImAbs_Float(x)
}

fn C.igImAbs_double(x f64) f64

pub fn ig_im_abs_double(x f64) f64 {
	return C.igImAbs_double(x)
}

fn C.igImSign_Float(x f32) f32

pub fn ig_im_sign_float(x f32) f32 {
	return C.igImSign_Float(x)
}

fn C.igImSign_double(x f64) f64

pub fn ig_im_sign_double(x f64) f64 {
	return C.igImSign_double(x)
}

fn C.igImRsqrt_Float(x f32) f32

pub fn ig_im_rsqrt_float(x f32) f32 {
	return C.igImRsqrt_Float(x)
}

fn C.igImRsqrt_double(x f64) f64

pub fn ig_im_rsqrt_double(x f64) f64 {
	return C.igImRsqrt_double(x)
}

fn C.igImMin(p_out &C.ImVec2, lhs C.ImVec2, rhs C.ImVec2)

pub fn ig_im_min(p_out &C.ImVec2, lhs C.ImVec2, rhs C.ImVec2) {
	C.igImMin(p_out, lhs, rhs)
}

fn C.igImMax(p_out &C.ImVec2, lhs C.ImVec2, rhs C.ImVec2)

pub fn ig_im_max(p_out &C.ImVec2, lhs C.ImVec2, rhs C.ImVec2) {
	C.igImMax(p_out, lhs, rhs)
}

fn C.igImClamp(p_out &C.ImVec2, v C.ImVec2, mn C.ImVec2, mx C.ImVec2)

pub fn ig_im_clamp(p_out &C.ImVec2, v C.ImVec2, mn C.ImVec2, mx C.ImVec2) {
	C.igImClamp(p_out, v, mn, mx)
}

fn C.igImLerp_Vec2Float(p_out &C.ImVec2, a C.ImVec2, b C.ImVec2, t f32)

pub fn ig_im_lerp_vec2_float(p_out &C.ImVec2, a C.ImVec2, b C.ImVec2, t f32) {
	C.igImLerp_Vec2Float(p_out, a, b, t)
}

fn C.igImLerp_Vec2Vec2(p_out &C.ImVec2, a C.ImVec2, b C.ImVec2, t C.ImVec2)

pub fn ig_im_lerp_vec2_vec2(p_out &C.ImVec2, a C.ImVec2, b C.ImVec2, t C.ImVec2) {
	C.igImLerp_Vec2Vec2(p_out, a, b, t)
}

fn C.igImLerp_Vec4(p_out &C.ImVec4, a C.ImVec4, b C.ImVec4, t f32)

pub fn ig_im_lerp_vec4(p_out &C.ImVec4, a C.ImVec4, b C.ImVec4, t f32) {
	C.igImLerp_Vec4(p_out, a, b, t)
}

fn C.igImSaturate(f f32) f32

pub fn ig_im_saturate(f f32) f32 {
	return C.igImSaturate(f)
}

fn C.igImLengthSqr_Vec2(lhs C.ImVec2) f32

pub fn ig_im_length_sqr_vec2(lhs C.ImVec2) f32 {
	return C.igImLengthSqr_Vec2(lhs)
}

fn C.igImLengthSqr_Vec4(lhs C.ImVec4) f32

pub fn ig_im_length_sqr_vec4(lhs C.ImVec4) f32 {
	return C.igImLengthSqr_Vec4(lhs)
}

fn C.igImInvLength(lhs C.ImVec2, fail_value f32) f32

pub fn ig_im_inv_length(lhs C.ImVec2, fail_value f32) f32 {
	return C.igImInvLength(lhs, fail_value)
}

fn C.igImTrunc_Float(f f32) f32

pub fn ig_im_trunc_float(f f32) f32 {
	return C.igImTrunc_Float(f)
}

fn C.igImTrunc_Vec2(p_out &C.ImVec2, v C.ImVec2)

pub fn ig_im_trunc_vec2(p_out &C.ImVec2, v C.ImVec2) {
	C.igImTrunc_Vec2(p_out, v)
}

fn C.igImFloor_Float(f f32) f32

pub fn ig_im_floor_float(f f32) f32 {
	return C.igImFloor_Float(f)
}

fn C.igImFloor_Vec2(p_out &C.ImVec2, v C.ImVec2)

pub fn ig_im_floor_vec2(p_out &C.ImVec2, v C.ImVec2) {
	C.igImFloor_Vec2(p_out, v)
}

fn C.igImModPositive(a int, b int) int

pub fn ig_im_mod_positive(a int, b int) int {
	return C.igImModPositive(a, b)
}

fn C.igImDot(a C.ImVec2, b C.ImVec2) f32

pub fn ig_im_dot(a C.ImVec2, b C.ImVec2) f32 {
	return C.igImDot(a, b)
}

fn C.igImRotate(p_out &C.ImVec2, v C.ImVec2, cos_a f32, sin_a f32)

pub fn ig_im_rotate(p_out &C.ImVec2, v C.ImVec2, cos_a f32, sin_a f32) {
	C.igImRotate(p_out, v, cos_a, sin_a)
}

fn C.igImLinearSweep(current f32, target f32, speed f32) f32

pub fn ig_im_linear_sweep(current f32, target f32, speed f32) f32 {
	return C.igImLinearSweep(current, target, speed)
}

fn C.igImLinearRemapClamp(s0 f32, s1 f32, d0 f32, d1 f32, x f32) f32

pub fn ig_im_linear_remap_clamp(s0 f32, s1 f32, d0 f32, d1 f32, x f32) f32 {
	return C.igImLinearRemapClamp(s0, s1, d0, d1, x)
}

fn C.igImMul(p_out &C.ImVec2, lhs C.ImVec2, rhs C.ImVec2)

pub fn ig_im_mul(p_out &C.ImVec2, lhs C.ImVec2, rhs C.ImVec2) {
	C.igImMul(p_out, lhs, rhs)
}

fn C.igImIsFloatAboveGuaranteedIntegerPrecision(f f32) bool

pub fn ig_im_is_float_above_guaranteed_integer_precision(f f32) bool {
	return C.igImIsFloatAboveGuaranteedIntegerPrecision(f)
}

fn C.igImExponentialMovingAverage(avg f32, sample f32, n int) f32

pub fn ig_im_exponential_moving_average(avg f32, sample f32, n int) f32 {
	return C.igImExponentialMovingAverage(avg, sample, n)
}

fn C.igImBezierCubicCalc(p_out &C.ImVec2, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, t f32)

pub fn ig_im_bezier_cubic_calc(p_out &C.ImVec2, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, t f32) {
	C.igImBezierCubicCalc(p_out, p1, p2, p3, p4, t)
}

fn C.igImBezierCubicClosestPoint(p_out &C.ImVec2, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, p C.ImVec2, num_segments int)

pub fn ig_im_bezier_cubic_closest_point(p_out &C.ImVec2, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, p C.ImVec2, num_segments int) {
	C.igImBezierCubicClosestPoint(p_out, p1, p2, p3, p4, p, num_segments)
}

fn C.igImBezierCubicClosestPointCasteljau(p_out &C.ImVec2, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, p C.ImVec2, tess_tol f32)

pub fn ig_im_bezier_cubic_closest_point_casteljau(p_out &C.ImVec2, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, p4 C.ImVec2, p C.ImVec2, tess_tol f32) {
	C.igImBezierCubicClosestPointCasteljau(p_out, p1, p2, p3, p4, p, tess_tol)
}

fn C.igImBezierQuadraticCalc(p_out &C.ImVec2, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, t f32)

pub fn ig_im_bezier_quadratic_calc(p_out &C.ImVec2, p1 C.ImVec2, p2 C.ImVec2, p3 C.ImVec2, t f32) {
	C.igImBezierQuadraticCalc(p_out, p1, p2, p3, t)
}

fn C.igImLineClosestPoint(p_out &C.ImVec2, a C.ImVec2, b C.ImVec2, p C.ImVec2)

pub fn ig_im_line_closest_point(p_out &C.ImVec2, a C.ImVec2, b C.ImVec2, p C.ImVec2) {
	C.igImLineClosestPoint(p_out, a, b, p)
}

fn C.igImTriangleContainsPoint(a C.ImVec2, b C.ImVec2, c C.ImVec2, p C.ImVec2) bool

pub fn ig_im_triangle_contains_point(a C.ImVec2, b C.ImVec2, c C.ImVec2, p C.ImVec2) bool {
	return C.igImTriangleContainsPoint(a, b, c, p)
}

fn C.igImTriangleClosestPoint(p_out &C.ImVec2, a C.ImVec2, b C.ImVec2, c C.ImVec2, p C.ImVec2)

pub fn ig_im_triangle_closest_point(p_out &C.ImVec2, a C.ImVec2, b C.ImVec2, c C.ImVec2, p C.ImVec2) {
	C.igImTriangleClosestPoint(p_out, a, b, c, p)
}

fn C.igImTriangleBarycentricCoords(a C.ImVec2, b C.ImVec2, c C.ImVec2, p C.ImVec2, out_u &f32, out_v &f32, out_w &f32)

pub fn ig_im_triangle_barycentric_coords(a C.ImVec2, b C.ImVec2, c C.ImVec2, p C.ImVec2, out_u &f32, out_v &f32, out_w &f32) {
	C.igImTriangleBarycentricCoords(a, b, c, p, out_u, out_v, out_w)
}

fn C.igImTriangleArea(a C.ImVec2, b C.ImVec2, c C.ImVec2) f32

pub fn ig_im_triangle_area(a C.ImVec2, b C.ImVec2, c C.ImVec2) f32 {
	return C.igImTriangleArea(a, b, c)
}

fn C.igImTriangleIsClockwise(a C.ImVec2, b C.ImVec2, c C.ImVec2) bool

pub fn ig_im_triangle_is_clockwise(a C.ImVec2, b C.ImVec2, c C.ImVec2) bool {
	return C.igImTriangleIsClockwise(a, b, c)
}

fn C.ImVec1_ImVec1_Nil() &C.ImVec1

pub fn im_vec1_im_vec1_nil() &C.ImVec1 {
	return C.ImVec1_ImVec1_Nil()
}

fn C.ImVec1_destroy(self &C.ImVec1)

pub fn im_vec1_destroy(self &C.ImVec1) {
	C.ImVec1_destroy(self)
}

fn C.ImVec1_ImVec1_Float(_x f32) &C.ImVec1

pub fn im_vec1_im_vec1_float(_x f32) &C.ImVec1 {
	return C.ImVec1_ImVec1_Float(_x)
}

fn C.ImVec2ih_ImVec2ih_Nil() &C.ImVec2ih

pub fn im_vec2ih_im_vec2ih_nil() &C.ImVec2ih {
	return C.ImVec2ih_ImVec2ih_Nil()
}

fn C.ImVec2ih_destroy(self &C.ImVec2ih)

pub fn im_vec2ih_destroy(self &C.ImVec2ih) {
	C.ImVec2ih_destroy(self)
}

fn C.ImVec2ih_ImVec2ih_short(_x i16, _y i16) &C.ImVec2ih

pub fn im_vec2ih_im_vec2ih_short(_x i16, _y i16) &C.ImVec2ih {
	return C.ImVec2ih_ImVec2ih_short(_x, _y)
}

fn C.ImVec2ih_ImVec2ih_Vec2(rhs C.ImVec2) &C.ImVec2ih

pub fn im_vec2ih_im_vec2ih_vec2(rhs C.ImVec2) &C.ImVec2ih {
	return C.ImVec2ih_ImVec2ih_Vec2(rhs)
}

fn C.ImRect_ImRect_Nil() &C.ImRect

pub fn im_rect_im_rect_nil() &C.ImRect {
	return C.ImRect_ImRect_Nil()
}

fn C.ImRect_destroy(self &C.ImRect)

pub fn im_rect_destroy(self &C.ImRect) {
	C.ImRect_destroy(self)
}

fn C.ImRect_ImRect_Vec2(min C.ImVec2, max C.ImVec2) &C.ImRect

pub fn im_rect_im_rect_vec2(min C.ImVec2, max C.ImVec2) &C.ImRect {
	return C.ImRect_ImRect_Vec2(min, max)
}

fn C.ImRect_ImRect_Vec4(v C.ImVec4) &C.ImRect

pub fn im_rect_im_rect_vec4(v C.ImVec4) &C.ImRect {
	return C.ImRect_ImRect_Vec4(v)
}

fn C.ImRect_ImRect_Float(x1 f32, y1 f32, x2 f32, y2 f32) &C.ImRect

pub fn im_rect_im_rect_float(x1 f32, y1 f32, x2 f32, y2 f32) &C.ImRect {
	return C.ImRect_ImRect_Float(x1, y1, x2, y2)
}

fn C.ImRect_GetCenter(p_out &C.ImVec2, self &C.ImRect)

pub fn im_rect_get_center(p_out &C.ImVec2, self &C.ImRect) {
	C.ImRect_GetCenter(p_out, self)
}

fn C.ImRect_GetSize(p_out &C.ImVec2, self &C.ImRect)

pub fn im_rect_get_size(p_out &C.ImVec2, self &C.ImRect) {
	C.ImRect_GetSize(p_out, self)
}

fn C.ImRect_GetWidth(self &C.ImRect) f32

pub fn im_rect_get_width(self &C.ImRect) f32 {
	return C.ImRect_GetWidth(self)
}

fn C.ImRect_GetHeight(self &C.ImRect) f32

pub fn im_rect_get_height(self &C.ImRect) f32 {
	return C.ImRect_GetHeight(self)
}

fn C.ImRect_GetArea(self &C.ImRect) f32

pub fn im_rect_get_area(self &C.ImRect) f32 {
	return C.ImRect_GetArea(self)
}

fn C.ImRect_GetTL(p_out &C.ImVec2, self &C.ImRect)

pub fn im_rect_get_tl(p_out &C.ImVec2, self &C.ImRect) {
	C.ImRect_GetTL(p_out, self)
}

fn C.ImRect_GetTR(p_out &C.ImVec2, self &C.ImRect)

pub fn im_rect_get_tr(p_out &C.ImVec2, self &C.ImRect) {
	C.ImRect_GetTR(p_out, self)
}

fn C.ImRect_GetBL(p_out &C.ImVec2, self &C.ImRect)

pub fn im_rect_get_bl(p_out &C.ImVec2, self &C.ImRect) {
	C.ImRect_GetBL(p_out, self)
}

fn C.ImRect_GetBR(p_out &C.ImVec2, self &C.ImRect)

pub fn im_rect_get_br(p_out &C.ImVec2, self &C.ImRect) {
	C.ImRect_GetBR(p_out, self)
}

fn C.ImRect_Contains_Vec2(self &C.ImRect, p C.ImVec2) bool

pub fn im_rect_contains_vec2(self &C.ImRect, p C.ImVec2) bool {
	return C.ImRect_Contains_Vec2(self, p)
}

fn C.ImRect_Contains_Rect(self &C.ImRect, r C.ImRect) bool

pub fn im_rect_contains_rect(self &C.ImRect, r C.ImRect) bool {
	return C.ImRect_Contains_Rect(self, r)
}

fn C.ImRect_ContainsWithPad(self &C.ImRect, p C.ImVec2, pad C.ImVec2) bool

pub fn im_rect_contains_with_pad(self &C.ImRect, p C.ImVec2, pad C.ImVec2) bool {
	return C.ImRect_ContainsWithPad(self, p, pad)
}

fn C.ImRect_Overlaps(self &C.ImRect, r C.ImRect) bool

pub fn im_rect_overlaps(self &C.ImRect, r C.ImRect) bool {
	return C.ImRect_Overlaps(self, r)
}

fn C.ImRect_Add_Vec2(self &C.ImRect, p C.ImVec2)

pub fn im_rect_add_vec2(self &C.ImRect, p C.ImVec2) {
	C.ImRect_Add_Vec2(self, p)
}

fn C.ImRect_Add_Rect(self &C.ImRect, r C.ImRect)

pub fn im_rect_add_rect(self &C.ImRect, r C.ImRect) {
	C.ImRect_Add_Rect(self, r)
}

fn C.ImRect_Expand_Float(self &C.ImRect, amount f32)

pub fn im_rect_expand_float(self &C.ImRect, amount f32) {
	C.ImRect_Expand_Float(self, amount)
}

fn C.ImRect_Expand_Vec2(self &C.ImRect, amount C.ImVec2)

pub fn im_rect_expand_vec2(self &C.ImRect, amount C.ImVec2) {
	C.ImRect_Expand_Vec2(self, amount)
}

fn C.ImRect_Translate(self &C.ImRect, d C.ImVec2)

pub fn im_rect_translate(self &C.ImRect, d C.ImVec2) {
	C.ImRect_Translate(self, d)
}

fn C.ImRect_TranslateX(self &C.ImRect, dx f32)

pub fn im_rect_translate_x(self &C.ImRect, dx f32) {
	C.ImRect_TranslateX(self, dx)
}

fn C.ImRect_TranslateY(self &C.ImRect, dy f32)

pub fn im_rect_translate_y(self &C.ImRect, dy f32) {
	C.ImRect_TranslateY(self, dy)
}

fn C.ImRect_ClipWith(self &C.ImRect, r C.ImRect)

pub fn im_rect_clip_with(self &C.ImRect, r C.ImRect) {
	C.ImRect_ClipWith(self, r)
}

fn C.ImRect_ClipWithFull(self &C.ImRect, r C.ImRect)

pub fn im_rect_clip_with_full(self &C.ImRect, r C.ImRect) {
	C.ImRect_ClipWithFull(self, r)
}

fn C.ImRect_Floor(self &C.ImRect)

pub fn im_rect_floor(self &C.ImRect) {
	C.ImRect_Floor(self)
}

fn C.ImRect_IsInverted(self &C.ImRect) bool

pub fn im_rect_is_inverted(self &C.ImRect) bool {
	return C.ImRect_IsInverted(self)
}

fn C.ImRect_ToVec4(p_out &C.ImVec4, self &C.ImRect)

pub fn im_rect_to_vec4(p_out &C.ImVec4, self &C.ImRect) {
	C.ImRect_ToVec4(p_out, self)
}

fn C.igImBitArrayGetStorageSizeInBytes(bitcount int) usize

pub fn ig_im_bit_array_get_storage_size_in_bytes(bitcount int) usize {
	return C.igImBitArrayGetStorageSizeInBytes(bitcount)
}

fn C.igImBitArrayClearAllBits(arr &ImU32, bitcount int)

pub fn ig_im_bit_array_clear_all_bits(arr &ImU32, bitcount int) {
	C.igImBitArrayClearAllBits(arr, bitcount)
}

fn C.igImBitArrayTestBit(arr &ImU32, n int) bool

pub fn ig_im_bit_array_test_bit(arr &ImU32, n int) bool {
	return C.igImBitArrayTestBit(arr, n)
}

fn C.igImBitArrayClearBit(arr &ImU32, n int)

pub fn ig_im_bit_array_clear_bit(arr &ImU32, n int) {
	C.igImBitArrayClearBit(arr, n)
}

fn C.igImBitArraySetBit(arr &ImU32, n int)

pub fn ig_im_bit_array_set_bit(arr &ImU32, n int) {
	C.igImBitArraySetBit(arr, n)
}

fn C.igImBitArraySetBitRange(arr &ImU32, n int, n2 int)

pub fn ig_im_bit_array_set_bit_range(arr &ImU32, n int, n2 int) {
	C.igImBitArraySetBitRange(arr, n, n2)
}

fn C.ImBitVector_Create(self &C.ImBitVector, sz int)

pub fn im_bit_vector_create(self &C.ImBitVector, sz int) {
	C.ImBitVector_Create(self, sz)
}

fn C.ImBitVector_Clear(self &C.ImBitVector)

pub fn im_bit_vector_clear(self &C.ImBitVector) {
	C.ImBitVector_Clear(self)
}

fn C.ImBitVector_TestBit(self &C.ImBitVector, n int) bool

pub fn im_bit_vector_test_bit(self &C.ImBitVector, n int) bool {
	return C.ImBitVector_TestBit(self, n)
}

fn C.ImBitVector_SetBit(self &C.ImBitVector, n int)

pub fn im_bit_vector_set_bit(self &C.ImBitVector, n int) {
	C.ImBitVector_SetBit(self, n)
}

fn C.ImBitVector_ClearBit(self &C.ImBitVector, n int)

pub fn im_bit_vector_clear_bit(self &C.ImBitVector, n int) {
	C.ImBitVector_ClearBit(self, n)
}

fn C.ImGuiTextIndex_clear(self &C.ImGuiTextIndex)

pub fn im_gui_text_index_clear(self &C.ImGuiTextIndex) {
	C.ImGuiTextIndex_clear(self)
}

fn C.ImGuiTextIndex_size(self &C.ImGuiTextIndex) int

pub fn im_gui_text_index_size(self &C.ImGuiTextIndex) int {
	return C.ImGuiTextIndex_size(self)
}

fn C.ImGuiTextIndex_get_line_begin(self &C.ImGuiTextIndex, base &i8, n int) &i8

pub fn im_gui_text_index_get_line_begin(self &C.ImGuiTextIndex, base &i8, n int) &i8 {
	return C.ImGuiTextIndex_get_line_begin(self, base, n)
}

fn C.ImGuiTextIndex_get_line_end(self &C.ImGuiTextIndex, base &i8, n int) &i8

pub fn im_gui_text_index_get_line_end(self &C.ImGuiTextIndex, base &i8, n int) &i8 {
	return C.ImGuiTextIndex_get_line_end(self, base, n)
}

fn C.ImGuiTextIndex_append(self &C.ImGuiTextIndex, base &i8, old_size int, new_size int)

pub fn im_gui_text_index_append(self &C.ImGuiTextIndex, base &i8, old_size int, new_size int) {
	C.ImGuiTextIndex_append(self, base, old_size, new_size)
}

fn C.igImLowerBound(in_begin &C.ImGuiStoragePair, in_end &C.ImGuiStoragePair, key ImGuiID) &C.ImGuiStoragePair

pub fn ig_im_lower_bound(in_begin &C.ImGuiStoragePair, in_end &C.ImGuiStoragePair, key ImGuiID) &C.ImGuiStoragePair {
	return C.igImLowerBound(in_begin, in_end, key)
}

fn C.ImDrawListSharedData_ImDrawListSharedData() &C.ImDrawListSharedData

pub fn im_draw_list_shared_data_im_draw_list_shared_data() &C.ImDrawListSharedData {
	return C.ImDrawListSharedData_ImDrawListSharedData()
}

fn C.ImDrawListSharedData_destroy(self &C.ImDrawListSharedData)

pub fn im_draw_list_shared_data_destroy(self &C.ImDrawListSharedData) {
	C.ImDrawListSharedData_destroy(self)
}

fn C.ImDrawListSharedData_SetCircleTessellationMaxError(self &C.ImDrawListSharedData, max_error f32)

pub fn im_draw_list_shared_data_set_circle_tessellation_max_error(self &C.ImDrawListSharedData, max_error f32) {
	C.ImDrawListSharedData_SetCircleTessellationMaxError(self, max_error)
}

fn C.ImDrawDataBuilder_ImDrawDataBuilder() &C.ImDrawDataBuilder

pub fn im_draw_data_builder_im_draw_data_builder() &C.ImDrawDataBuilder {
	return C.ImDrawDataBuilder_ImDrawDataBuilder()
}

fn C.ImDrawDataBuilder_destroy(self &C.ImDrawDataBuilder)

pub fn im_draw_data_builder_destroy(self &C.ImDrawDataBuilder) {
	C.ImDrawDataBuilder_destroy(self)
}

fn C.ImGuiDataVarInfo_GetVarPtr(self &C.ImGuiDataVarInfo, parent voidptr) voidptr

pub fn im_gui_data_var_info_get_var_ptr(self &C.ImGuiDataVarInfo, parent voidptr) voidptr {
	return C.ImGuiDataVarInfo_GetVarPtr(self, parent)
}

fn C.ImGuiStyleMod_ImGuiStyleMod_Int(idx ImGuiStyleVar, v int) &C.ImGuiStyleMod

pub fn im_gui_style_mod_im_gui_style_mod_int(idx ImGuiStyleVar, v int) &C.ImGuiStyleMod {
	return C.ImGuiStyleMod_ImGuiStyleMod_Int(idx, v)
}

fn C.ImGuiStyleMod_destroy(self &C.ImGuiStyleMod)

pub fn im_gui_style_mod_destroy(self &C.ImGuiStyleMod) {
	C.ImGuiStyleMod_destroy(self)
}

fn C.ImGuiStyleMod_ImGuiStyleMod_Float(idx ImGuiStyleVar, v f32) &C.ImGuiStyleMod

pub fn im_gui_style_mod_im_gui_style_mod_float(idx ImGuiStyleVar, v f32) &C.ImGuiStyleMod {
	return C.ImGuiStyleMod_ImGuiStyleMod_Float(idx, v)
}

fn C.ImGuiStyleMod_ImGuiStyleMod_Vec2(idx ImGuiStyleVar, v C.ImVec2) &C.ImGuiStyleMod

pub fn im_gui_style_mod_im_gui_style_mod_vec2(idx ImGuiStyleVar, v C.ImVec2) &C.ImGuiStyleMod {
	return C.ImGuiStyleMod_ImGuiStyleMod_Vec2(idx, v)
}

fn C.ImGuiComboPreviewData_ImGuiComboPreviewData() &C.ImGuiComboPreviewData

pub fn im_gui_combo_preview_data_im_gui_combo_preview_data() &C.ImGuiComboPreviewData {
	return C.ImGuiComboPreviewData_ImGuiComboPreviewData()
}

fn C.ImGuiComboPreviewData_destroy(self &C.ImGuiComboPreviewData)

pub fn im_gui_combo_preview_data_destroy(self &C.ImGuiComboPreviewData) {
	C.ImGuiComboPreviewData_destroy(self)
}

fn C.ImGuiMenuColumns_ImGuiMenuColumns() &C.ImGuiMenuColumns

pub fn im_gui_menu_columns_im_gui_menu_columns() &C.ImGuiMenuColumns {
	return C.ImGuiMenuColumns_ImGuiMenuColumns()
}

fn C.ImGuiMenuColumns_destroy(self &C.ImGuiMenuColumns)

pub fn im_gui_menu_columns_destroy(self &C.ImGuiMenuColumns) {
	C.ImGuiMenuColumns_destroy(self)
}

fn C.ImGuiMenuColumns_Update(self &C.ImGuiMenuColumns, spacing f32, window_reappearing bool)

pub fn im_gui_menu_columns_update(self &C.ImGuiMenuColumns, spacing f32, window_reappearing bool) {
	C.ImGuiMenuColumns_Update(self, spacing, window_reappearing)
}

fn C.ImGuiMenuColumns_DeclColumns(self &C.ImGuiMenuColumns, w_icon f32, w_label f32, w_shortcut f32, w_mark f32) f32

pub fn im_gui_menu_columns_decl_columns(self &C.ImGuiMenuColumns, w_icon f32, w_label f32, w_shortcut f32, w_mark f32) f32 {
	return C.ImGuiMenuColumns_DeclColumns(self, w_icon, w_label, w_shortcut, w_mark)
}

fn C.ImGuiMenuColumns_CalcNextTotalWidth(self &C.ImGuiMenuColumns, update_offsets bool)

pub fn im_gui_menu_columns_calc_next_total_width(self &C.ImGuiMenuColumns, update_offsets bool) {
	C.ImGuiMenuColumns_CalcNextTotalWidth(self, update_offsets)
}

fn C.ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState() &C.ImGuiInputTextDeactivatedState

pub fn im_gui_input_text_deactivated_state_im_gui_input_text_deactivated_state() &C.ImGuiInputTextDeactivatedState {
	return C.ImGuiInputTextDeactivatedState_ImGuiInputTextDeactivatedState()
}

fn C.ImGuiInputTextDeactivatedState_destroy(self &C.ImGuiInputTextDeactivatedState)

pub fn im_gui_input_text_deactivated_state_destroy(self &C.ImGuiInputTextDeactivatedState) {
	C.ImGuiInputTextDeactivatedState_destroy(self)
}

fn C.ImGuiInputTextDeactivatedState_ClearFreeMemory(self &C.ImGuiInputTextDeactivatedState)

pub fn im_gui_input_text_deactivated_state_clear_free_memory(self &C.ImGuiInputTextDeactivatedState) {
	C.ImGuiInputTextDeactivatedState_ClearFreeMemory(self)
}

fn C.ImGuiInputTextState_ImGuiInputTextState() &C.ImGuiInputTextState

pub fn im_gui_input_text_state_im_gui_input_text_state() &C.ImGuiInputTextState {
	return C.ImGuiInputTextState_ImGuiInputTextState()
}

fn C.ImGuiInputTextState_destroy(self &C.ImGuiInputTextState)

pub fn im_gui_input_text_state_destroy(self &C.ImGuiInputTextState) {
	C.ImGuiInputTextState_destroy(self)
}

fn C.ImGuiInputTextState_ClearText(self &C.ImGuiInputTextState)

pub fn im_gui_input_text_state_clear_text(self &C.ImGuiInputTextState) {
	C.ImGuiInputTextState_ClearText(self)
}

fn C.ImGuiInputTextState_ClearFreeMemory(self &C.ImGuiInputTextState)

pub fn im_gui_input_text_state_clear_free_memory(self &C.ImGuiInputTextState) {
	C.ImGuiInputTextState_ClearFreeMemory(self)
}

fn C.ImGuiInputTextState_GetUndoAvailCount(self &C.ImGuiInputTextState) int

pub fn im_gui_input_text_state_get_undo_avail_count(self &C.ImGuiInputTextState) int {
	return C.ImGuiInputTextState_GetUndoAvailCount(self)
}

fn C.ImGuiInputTextState_GetRedoAvailCount(self &C.ImGuiInputTextState) int

pub fn im_gui_input_text_state_get_redo_avail_count(self &C.ImGuiInputTextState) int {
	return C.ImGuiInputTextState_GetRedoAvailCount(self)
}

fn C.ImGuiInputTextState_OnKeyPressed(self &C.ImGuiInputTextState, key int)

pub fn im_gui_input_text_state_on_key_pressed(self &C.ImGuiInputTextState, key int) {
	C.ImGuiInputTextState_OnKeyPressed(self, key)
}

fn C.ImGuiInputTextState_CursorAnimReset(self &C.ImGuiInputTextState)

pub fn im_gui_input_text_state_cursor_anim_reset(self &C.ImGuiInputTextState) {
	C.ImGuiInputTextState_CursorAnimReset(self)
}

fn C.ImGuiInputTextState_CursorClamp(self &C.ImGuiInputTextState)

pub fn im_gui_input_text_state_cursor_clamp(self &C.ImGuiInputTextState) {
	C.ImGuiInputTextState_CursorClamp(self)
}

fn C.ImGuiInputTextState_HasSelection(self &C.ImGuiInputTextState) bool

pub fn im_gui_input_text_state_has_selection(self &C.ImGuiInputTextState) bool {
	return C.ImGuiInputTextState_HasSelection(self)
}

fn C.ImGuiInputTextState_ClearSelection(self &C.ImGuiInputTextState)

pub fn im_gui_input_text_state_clear_selection(self &C.ImGuiInputTextState) {
	C.ImGuiInputTextState_ClearSelection(self)
}

fn C.ImGuiInputTextState_GetCursorPos(self &C.ImGuiInputTextState) int

pub fn im_gui_input_text_state_get_cursor_pos(self &C.ImGuiInputTextState) int {
	return C.ImGuiInputTextState_GetCursorPos(self)
}

fn C.ImGuiInputTextState_GetSelectionStart(self &C.ImGuiInputTextState) int

pub fn im_gui_input_text_state_get_selection_start(self &C.ImGuiInputTextState) int {
	return C.ImGuiInputTextState_GetSelectionStart(self)
}

fn C.ImGuiInputTextState_GetSelectionEnd(self &C.ImGuiInputTextState) int

pub fn im_gui_input_text_state_get_selection_end(self &C.ImGuiInputTextState) int {
	return C.ImGuiInputTextState_GetSelectionEnd(self)
}

fn C.ImGuiInputTextState_SelectAll(self &C.ImGuiInputTextState)

pub fn im_gui_input_text_state_select_all(self &C.ImGuiInputTextState) {
	C.ImGuiInputTextState_SelectAll(self)
}

fn C.ImGuiInputTextState_ReloadUserBufAndSelectAll(self &C.ImGuiInputTextState)

pub fn im_gui_input_text_state_reload_user_buf_and_select_all(self &C.ImGuiInputTextState) {
	C.ImGuiInputTextState_ReloadUserBufAndSelectAll(self)
}

fn C.ImGuiInputTextState_ReloadUserBufAndKeepSelection(self &C.ImGuiInputTextState)

pub fn im_gui_input_text_state_reload_user_buf_and_keep_selection(self &C.ImGuiInputTextState) {
	C.ImGuiInputTextState_ReloadUserBufAndKeepSelection(self)
}

fn C.ImGuiInputTextState_ReloadUserBufAndMoveToEnd(self &C.ImGuiInputTextState)

pub fn im_gui_input_text_state_reload_user_buf_and_move_to_end(self &C.ImGuiInputTextState) {
	C.ImGuiInputTextState_ReloadUserBufAndMoveToEnd(self)
}

fn C.ImGuiNextWindowData_ImGuiNextWindowData() &C.ImGuiNextWindowData

pub fn im_gui_next_window_data_im_gui_next_window_data() &C.ImGuiNextWindowData {
	return C.ImGuiNextWindowData_ImGuiNextWindowData()
}

fn C.ImGuiNextWindowData_destroy(self &C.ImGuiNextWindowData)

pub fn im_gui_next_window_data_destroy(self &C.ImGuiNextWindowData) {
	C.ImGuiNextWindowData_destroy(self)
}

fn C.ImGuiNextWindowData_ClearFlags(self &C.ImGuiNextWindowData)

pub fn im_gui_next_window_data_clear_flags(self &C.ImGuiNextWindowData) {
	C.ImGuiNextWindowData_ClearFlags(self)
}

fn C.ImGuiNextItemData_ImGuiNextItemData() &C.ImGuiNextItemData

pub fn im_gui_next_item_data_im_gui_next_item_data() &C.ImGuiNextItemData {
	return C.ImGuiNextItemData_ImGuiNextItemData()
}

fn C.ImGuiNextItemData_destroy(self &C.ImGuiNextItemData)

pub fn im_gui_next_item_data_destroy(self &C.ImGuiNextItemData) {
	C.ImGuiNextItemData_destroy(self)
}

fn C.ImGuiNextItemData_ClearFlags(self &C.ImGuiNextItemData)

pub fn im_gui_next_item_data_clear_flags(self &C.ImGuiNextItemData) {
	C.ImGuiNextItemData_ClearFlags(self)
}

fn C.ImGuiLastItemData_ImGuiLastItemData() &C.ImGuiLastItemData

pub fn im_gui_last_item_data_im_gui_last_item_data() &C.ImGuiLastItemData {
	return C.ImGuiLastItemData_ImGuiLastItemData()
}

fn C.ImGuiLastItemData_destroy(self &C.ImGuiLastItemData)

pub fn im_gui_last_item_data_destroy(self &C.ImGuiLastItemData) {
	C.ImGuiLastItemData_destroy(self)
}

fn C.ImGuiStackSizes_ImGuiStackSizes() &C.ImGuiStackSizes

pub fn im_gui_stack_sizes_im_gui_stack_sizes() &C.ImGuiStackSizes {
	return C.ImGuiStackSizes_ImGuiStackSizes()
}

fn C.ImGuiStackSizes_destroy(self &C.ImGuiStackSizes)

pub fn im_gui_stack_sizes_destroy(self &C.ImGuiStackSizes) {
	C.ImGuiStackSizes_destroy(self)
}

fn C.ImGuiStackSizes_SetToContextState(self &C.ImGuiStackSizes, ctx &C.ImGuiContext)

pub fn im_gui_stack_sizes_set_to_context_state(self &C.ImGuiStackSizes, ctx &C.ImGuiContext) {
	C.ImGuiStackSizes_SetToContextState(self, ctx)
}

fn C.ImGuiStackSizes_CompareWithContextState(self &C.ImGuiStackSizes, ctx &C.ImGuiContext)

pub fn im_gui_stack_sizes_compare_with_context_state(self &C.ImGuiStackSizes, ctx &C.ImGuiContext) {
	C.ImGuiStackSizes_CompareWithContextState(self, ctx)
}

fn C.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr(ptr voidptr) &C.ImGuiPtrOrIndex

pub fn im_gui_ptr_or_index_im_gui_ptr_or_index_ptr(ptr voidptr) &C.ImGuiPtrOrIndex {
	return C.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr(ptr)
}

fn C.ImGuiPtrOrIndex_destroy(self &C.ImGuiPtrOrIndex)

pub fn im_gui_ptr_or_index_destroy(self &C.ImGuiPtrOrIndex) {
	C.ImGuiPtrOrIndex_destroy(self)
}

fn C.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int(index int) &C.ImGuiPtrOrIndex

pub fn im_gui_ptr_or_index_im_gui_ptr_or_index_int(index int) &C.ImGuiPtrOrIndex {
	return C.ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int(index)
}

fn C.ImGuiPopupData_ImGuiPopupData() &C.ImGuiPopupData

pub fn im_gui_popup_data_im_gui_popup_data() &C.ImGuiPopupData {
	return C.ImGuiPopupData_ImGuiPopupData()
}

fn C.ImGuiPopupData_destroy(self &C.ImGuiPopupData)

pub fn im_gui_popup_data_destroy(self &C.ImGuiPopupData) {
	C.ImGuiPopupData_destroy(self)
}

fn C.ImGuiInputEvent_ImGuiInputEvent() &C.ImGuiInputEvent

pub fn im_gui_input_event_im_gui_input_event() &C.ImGuiInputEvent {
	return C.ImGuiInputEvent_ImGuiInputEvent()
}

fn C.ImGuiInputEvent_destroy(self &C.ImGuiInputEvent)

pub fn im_gui_input_event_destroy(self &C.ImGuiInputEvent) {
	C.ImGuiInputEvent_destroy(self)
}

fn C.ImGuiKeyRoutingData_ImGuiKeyRoutingData() &C.ImGuiKeyRoutingData

pub fn im_gui_key_routing_data_im_gui_key_routing_data() &C.ImGuiKeyRoutingData {
	return C.ImGuiKeyRoutingData_ImGuiKeyRoutingData()
}

fn C.ImGuiKeyRoutingData_destroy(self &C.ImGuiKeyRoutingData)

pub fn im_gui_key_routing_data_destroy(self &C.ImGuiKeyRoutingData) {
	C.ImGuiKeyRoutingData_destroy(self)
}

fn C.ImGuiKeyRoutingTable_ImGuiKeyRoutingTable() &C.ImGuiKeyRoutingTable

pub fn im_gui_key_routing_table_im_gui_key_routing_table() &C.ImGuiKeyRoutingTable {
	return C.ImGuiKeyRoutingTable_ImGuiKeyRoutingTable()
}

fn C.ImGuiKeyRoutingTable_destroy(self &C.ImGuiKeyRoutingTable)

pub fn im_gui_key_routing_table_destroy(self &C.ImGuiKeyRoutingTable) {
	C.ImGuiKeyRoutingTable_destroy(self)
}

fn C.ImGuiKeyRoutingTable_Clear(self &C.ImGuiKeyRoutingTable)

pub fn im_gui_key_routing_table_clear(self &C.ImGuiKeyRoutingTable) {
	C.ImGuiKeyRoutingTable_Clear(self)
}

fn C.ImGuiKeyOwnerData_ImGuiKeyOwnerData() &C.ImGuiKeyOwnerData

pub fn im_gui_key_owner_data_im_gui_key_owner_data() &C.ImGuiKeyOwnerData {
	return C.ImGuiKeyOwnerData_ImGuiKeyOwnerData()
}

fn C.ImGuiKeyOwnerData_destroy(self &C.ImGuiKeyOwnerData)

pub fn im_gui_key_owner_data_destroy(self &C.ImGuiKeyOwnerData) {
	C.ImGuiKeyOwnerData_destroy(self)
}

fn C.ImGuiListClipperRange_FromIndices(min int, max int) C.ImGuiListClipperRange

pub fn im_gui_list_clipper_range_from_indices(min int, max int) C.ImGuiListClipperRange {
	return C.ImGuiListClipperRange_FromIndices(min, max)
}

fn C.ImGuiListClipperRange_FromPositions(y1 f32, y2 f32, off_min int, off_max int) C.ImGuiListClipperRange

pub fn im_gui_list_clipper_range_from_positions(y1 f32, y2 f32, off_min int, off_max int) C.ImGuiListClipperRange {
	return C.ImGuiListClipperRange_FromPositions(y1, y2, off_min, off_max)
}

fn C.ImGuiListClipperData_ImGuiListClipperData() &C.ImGuiListClipperData

pub fn im_gui_list_clipper_data_im_gui_list_clipper_data() &C.ImGuiListClipperData {
	return C.ImGuiListClipperData_ImGuiListClipperData()
}

fn C.ImGuiListClipperData_destroy(self &C.ImGuiListClipperData)

pub fn im_gui_list_clipper_data_destroy(self &C.ImGuiListClipperData) {
	C.ImGuiListClipperData_destroy(self)
}

fn C.ImGuiListClipperData_Reset(self &C.ImGuiListClipperData, clipper &C.ImGuiListClipper)

pub fn im_gui_list_clipper_data_reset(self &C.ImGuiListClipperData, clipper &C.ImGuiListClipper) {
	C.ImGuiListClipperData_Reset(self, clipper)
}

fn C.ImGuiNavItemData_ImGuiNavItemData() &C.ImGuiNavItemData

pub fn im_gui_nav_item_data_im_gui_nav_item_data() &C.ImGuiNavItemData {
	return C.ImGuiNavItemData_ImGuiNavItemData()
}

fn C.ImGuiNavItemData_destroy(self &C.ImGuiNavItemData)

pub fn im_gui_nav_item_data_destroy(self &C.ImGuiNavItemData) {
	C.ImGuiNavItemData_destroy(self)
}

fn C.ImGuiNavItemData_Clear(self &C.ImGuiNavItemData)

pub fn im_gui_nav_item_data_clear(self &C.ImGuiNavItemData) {
	C.ImGuiNavItemData_Clear(self)
}

fn C.ImGuiTypingSelectState_ImGuiTypingSelectState() &C.ImGuiTypingSelectState

pub fn im_gui_typing_select_state_im_gui_typing_select_state() &C.ImGuiTypingSelectState {
	return C.ImGuiTypingSelectState_ImGuiTypingSelectState()
}

fn C.ImGuiTypingSelectState_destroy(self &C.ImGuiTypingSelectState)

pub fn im_gui_typing_select_state_destroy(self &C.ImGuiTypingSelectState) {
	C.ImGuiTypingSelectState_destroy(self)
}

fn C.ImGuiTypingSelectState_Clear(self &C.ImGuiTypingSelectState)

pub fn im_gui_typing_select_state_clear(self &C.ImGuiTypingSelectState) {
	C.ImGuiTypingSelectState_Clear(self)
}

fn C.ImGuiOldColumnData_ImGuiOldColumnData() &C.ImGuiOldColumnData

pub fn im_gui_old_column_data_im_gui_old_column_data() &C.ImGuiOldColumnData {
	return C.ImGuiOldColumnData_ImGuiOldColumnData()
}

fn C.ImGuiOldColumnData_destroy(self &C.ImGuiOldColumnData)

pub fn im_gui_old_column_data_destroy(self &C.ImGuiOldColumnData) {
	C.ImGuiOldColumnData_destroy(self)
}

fn C.ImGuiOldColumns_ImGuiOldColumns() &C.ImGuiOldColumns

pub fn im_gui_old_columns_im_gui_old_columns() &C.ImGuiOldColumns {
	return C.ImGuiOldColumns_ImGuiOldColumns()
}

fn C.ImGuiOldColumns_destroy(self &C.ImGuiOldColumns)

pub fn im_gui_old_columns_destroy(self &C.ImGuiOldColumns) {
	C.ImGuiOldColumns_destroy(self)
}

fn C.ImGuiBoxSelectState_ImGuiBoxSelectState() &C.ImGuiBoxSelectState

pub fn im_gui_box_select_state_im_gui_box_select_state() &C.ImGuiBoxSelectState {
	return C.ImGuiBoxSelectState_ImGuiBoxSelectState()
}

fn C.ImGuiBoxSelectState_destroy(self &C.ImGuiBoxSelectState)

pub fn im_gui_box_select_state_destroy(self &C.ImGuiBoxSelectState) {
	C.ImGuiBoxSelectState_destroy(self)
}

fn C.ImGuiMultiSelectTempData_ImGuiMultiSelectTempData() &C.ImGuiMultiSelectTempData

pub fn im_gui_multi_select_temp_data_im_gui_multi_select_temp_data() &C.ImGuiMultiSelectTempData {
	return C.ImGuiMultiSelectTempData_ImGuiMultiSelectTempData()
}

fn C.ImGuiMultiSelectTempData_destroy(self &C.ImGuiMultiSelectTempData)

pub fn im_gui_multi_select_temp_data_destroy(self &C.ImGuiMultiSelectTempData) {
	C.ImGuiMultiSelectTempData_destroy(self)
}

fn C.ImGuiMultiSelectTempData_Clear(self &C.ImGuiMultiSelectTempData)

pub fn im_gui_multi_select_temp_data_clear(self &C.ImGuiMultiSelectTempData) {
	C.ImGuiMultiSelectTempData_Clear(self)
}

fn C.ImGuiMultiSelectTempData_ClearIO(self &C.ImGuiMultiSelectTempData)

pub fn im_gui_multi_select_temp_data_clear_io(self &C.ImGuiMultiSelectTempData) {
	C.ImGuiMultiSelectTempData_ClearIO(self)
}

fn C.ImGuiMultiSelectState_ImGuiMultiSelectState() &C.ImGuiMultiSelectState

pub fn im_gui_multi_select_state_im_gui_multi_select_state() &C.ImGuiMultiSelectState {
	return C.ImGuiMultiSelectState_ImGuiMultiSelectState()
}

fn C.ImGuiMultiSelectState_destroy(self &C.ImGuiMultiSelectState)

pub fn im_gui_multi_select_state_destroy(self &C.ImGuiMultiSelectState) {
	C.ImGuiMultiSelectState_destroy(self)
}

fn C.ImGuiDockNode_ImGuiDockNode(id ImGuiID) &C.ImGuiDockNode

pub fn im_gui_dock_node_im_gui_dock_node(id ImGuiID) &C.ImGuiDockNode {
	return C.ImGuiDockNode_ImGuiDockNode(id)
}

fn C.ImGuiDockNode_destroy(self &C.ImGuiDockNode)

pub fn im_gui_dock_node_destroy(self &C.ImGuiDockNode) {
	C.ImGuiDockNode_destroy(self)
}

fn C.ImGuiDockNode_IsRootNode(self &C.ImGuiDockNode) bool

pub fn im_gui_dock_node_is_root_node(self &C.ImGuiDockNode) bool {
	return C.ImGuiDockNode_IsRootNode(self)
}

fn C.ImGuiDockNode_IsDockSpace(self &C.ImGuiDockNode) bool

pub fn im_gui_dock_node_is_dock_space(self &C.ImGuiDockNode) bool {
	return C.ImGuiDockNode_IsDockSpace(self)
}

fn C.ImGuiDockNode_IsFloatingNode(self &C.ImGuiDockNode) bool

pub fn im_gui_dock_node_is_floating_node(self &C.ImGuiDockNode) bool {
	return C.ImGuiDockNode_IsFloatingNode(self)
}

fn C.ImGuiDockNode_IsCentralNode(self &C.ImGuiDockNode) bool

pub fn im_gui_dock_node_is_central_node(self &C.ImGuiDockNode) bool {
	return C.ImGuiDockNode_IsCentralNode(self)
}

fn C.ImGuiDockNode_IsHiddenTabBar(self &C.ImGuiDockNode) bool

pub fn im_gui_dock_node_is_hidden_tab_bar(self &C.ImGuiDockNode) bool {
	return C.ImGuiDockNode_IsHiddenTabBar(self)
}

fn C.ImGuiDockNode_IsNoTabBar(self &C.ImGuiDockNode) bool

pub fn im_gui_dock_node_is_no_tab_bar(self &C.ImGuiDockNode) bool {
	return C.ImGuiDockNode_IsNoTabBar(self)
}

fn C.ImGuiDockNode_IsSplitNode(self &C.ImGuiDockNode) bool

pub fn im_gui_dock_node_is_split_node(self &C.ImGuiDockNode) bool {
	return C.ImGuiDockNode_IsSplitNode(self)
}

fn C.ImGuiDockNode_IsLeafNode(self &C.ImGuiDockNode) bool

pub fn im_gui_dock_node_is_leaf_node(self &C.ImGuiDockNode) bool {
	return C.ImGuiDockNode_IsLeafNode(self)
}

fn C.ImGuiDockNode_IsEmpty(self &C.ImGuiDockNode) bool

pub fn im_gui_dock_node_is_empty(self &C.ImGuiDockNode) bool {
	return C.ImGuiDockNode_IsEmpty(self)
}

fn C.ImGuiDockNode_Rect(p_out &C.ImRect, self &C.ImGuiDockNode)

pub fn im_gui_dock_node_rect(p_out &C.ImRect, self &C.ImGuiDockNode) {
	C.ImGuiDockNode_Rect(p_out, self)
}

fn C.ImGuiDockNode_SetLocalFlags(self &C.ImGuiDockNode, flags ImGuiDockNodeFlags)

pub fn im_gui_dock_node_set_local_flags(self &C.ImGuiDockNode, flags ImGuiDockNodeFlags) {
	C.ImGuiDockNode_SetLocalFlags(self, flags)
}

fn C.ImGuiDockNode_UpdateMergedFlags(self &C.ImGuiDockNode)

pub fn im_gui_dock_node_update_merged_flags(self &C.ImGuiDockNode) {
	C.ImGuiDockNode_UpdateMergedFlags(self)
}

fn C.ImGuiDockContext_ImGuiDockContext() &C.ImGuiDockContext

pub fn im_gui_dock_context_im_gui_dock_context() &C.ImGuiDockContext {
	return C.ImGuiDockContext_ImGuiDockContext()
}

fn C.ImGuiDockContext_destroy(self &C.ImGuiDockContext)

pub fn im_gui_dock_context_destroy(self &C.ImGuiDockContext) {
	C.ImGuiDockContext_destroy(self)
}

fn C.ImGuiViewportP_ImGuiViewportP() &C.ImGuiViewportP

pub fn im_gui_viewport_p_im_gui_viewport_p() &C.ImGuiViewportP {
	return C.ImGuiViewportP_ImGuiViewportP()
}

fn C.ImGuiViewportP_destroy(self &C.ImGuiViewportP)

pub fn im_gui_viewport_p_destroy(self &C.ImGuiViewportP) {
	C.ImGuiViewportP_destroy(self)
}

fn C.ImGuiViewportP_ClearRequestFlags(self &C.ImGuiViewportP)

pub fn im_gui_viewport_p_clear_request_flags(self &C.ImGuiViewportP) {
	C.ImGuiViewportP_ClearRequestFlags(self)
}

fn C.ImGuiViewportP_CalcWorkRectPos(p_out &C.ImVec2, self &C.ImGuiViewportP, inset_min C.ImVec2)

pub fn im_gui_viewport_p_calc_work_rect_pos(p_out &C.ImVec2, self &C.ImGuiViewportP, inset_min C.ImVec2) {
	C.ImGuiViewportP_CalcWorkRectPos(p_out, self, inset_min)
}

fn C.ImGuiViewportP_CalcWorkRectSize(p_out &C.ImVec2, self &C.ImGuiViewportP, inset_min C.ImVec2, inset_max C.ImVec2)

pub fn im_gui_viewport_p_calc_work_rect_size(p_out &C.ImVec2, self &C.ImGuiViewportP, inset_min C.ImVec2, inset_max C.ImVec2) {
	C.ImGuiViewportP_CalcWorkRectSize(p_out, self, inset_min, inset_max)
}

fn C.ImGuiViewportP_UpdateWorkRect(self &C.ImGuiViewportP)

pub fn im_gui_viewport_p_update_work_rect(self &C.ImGuiViewportP) {
	C.ImGuiViewportP_UpdateWorkRect(self)
}

fn C.ImGuiViewportP_GetMainRect(p_out &C.ImRect, self &C.ImGuiViewportP)

pub fn im_gui_viewport_p_get_main_rect(p_out &C.ImRect, self &C.ImGuiViewportP) {
	C.ImGuiViewportP_GetMainRect(p_out, self)
}

fn C.ImGuiViewportP_GetWorkRect(p_out &C.ImRect, self &C.ImGuiViewportP)

pub fn im_gui_viewport_p_get_work_rect(p_out &C.ImRect, self &C.ImGuiViewportP) {
	C.ImGuiViewportP_GetWorkRect(p_out, self)
}

fn C.ImGuiViewportP_GetBuildWorkRect(p_out &C.ImRect, self &C.ImGuiViewportP)

pub fn im_gui_viewport_p_get_build_work_rect(p_out &C.ImRect, self &C.ImGuiViewportP) {
	C.ImGuiViewportP_GetBuildWorkRect(p_out, self)
}

fn C.ImGuiWindowSettings_ImGuiWindowSettings() &C.ImGuiWindowSettings

pub fn im_gui_window_settings_im_gui_window_settings() &C.ImGuiWindowSettings {
	return C.ImGuiWindowSettings_ImGuiWindowSettings()
}

fn C.ImGuiWindowSettings_destroy(self &C.ImGuiWindowSettings)

pub fn im_gui_window_settings_destroy(self &C.ImGuiWindowSettings) {
	C.ImGuiWindowSettings_destroy(self)
}

fn C.ImGuiWindowSettings_GetName(self &C.ImGuiWindowSettings) &i8

pub fn im_gui_window_settings_get_name(self &C.ImGuiWindowSettings) &i8 {
	return C.ImGuiWindowSettings_GetName(self)
}

fn C.ImGuiSettingsHandler_ImGuiSettingsHandler() &C.ImGuiSettingsHandler

pub fn im_gui_settings_handler_im_gui_settings_handler() &C.ImGuiSettingsHandler {
	return C.ImGuiSettingsHandler_ImGuiSettingsHandler()
}

fn C.ImGuiSettingsHandler_destroy(self &C.ImGuiSettingsHandler)

pub fn im_gui_settings_handler_destroy(self &C.ImGuiSettingsHandler) {
	C.ImGuiSettingsHandler_destroy(self)
}

fn C.ImGuiDebugAllocInfo_ImGuiDebugAllocInfo() &C.ImGuiDebugAllocInfo

pub fn im_gui_debug_alloc_info_im_gui_debug_alloc_info() &C.ImGuiDebugAllocInfo {
	return C.ImGuiDebugAllocInfo_ImGuiDebugAllocInfo()
}

fn C.ImGuiDebugAllocInfo_destroy(self &C.ImGuiDebugAllocInfo)

pub fn im_gui_debug_alloc_info_destroy(self &C.ImGuiDebugAllocInfo) {
	C.ImGuiDebugAllocInfo_destroy(self)
}

fn C.ImGuiStackLevelInfo_ImGuiStackLevelInfo() &C.ImGuiStackLevelInfo

pub fn im_gui_stack_level_info_im_gui_stack_level_info() &C.ImGuiStackLevelInfo {
	return C.ImGuiStackLevelInfo_ImGuiStackLevelInfo()
}

fn C.ImGuiStackLevelInfo_destroy(self &C.ImGuiStackLevelInfo)

pub fn im_gui_stack_level_info_destroy(self &C.ImGuiStackLevelInfo) {
	C.ImGuiStackLevelInfo_destroy(self)
}

fn C.ImGuiIDStackTool_ImGuiIDStackTool() &C.ImGuiIDStackTool

pub fn im_gui_ids_tack_tool_im_gui_ids_tack_tool() &C.ImGuiIDStackTool {
	return C.ImGuiIDStackTool_ImGuiIDStackTool()
}

fn C.ImGuiIDStackTool_destroy(self &C.ImGuiIDStackTool)

pub fn im_gui_ids_tack_tool_destroy(self &C.ImGuiIDStackTool) {
	C.ImGuiIDStackTool_destroy(self)
}

fn C.ImGuiContextHook_ImGuiContextHook() &C.ImGuiContextHook

pub fn im_gui_context_hook_im_gui_context_hook() &C.ImGuiContextHook {
	return C.ImGuiContextHook_ImGuiContextHook()
}

fn C.ImGuiContextHook_destroy(self &C.ImGuiContextHook)

pub fn im_gui_context_hook_destroy(self &C.ImGuiContextHook) {
	C.ImGuiContextHook_destroy(self)
}

fn C.ImGuiContext_ImGuiContext(shared_font_atlas &C.ImFontAtlas) &C.ImGuiContext

pub fn im_gui_context_im_gui_context(shared_font_atlas &C.ImFontAtlas) &C.ImGuiContext {
	return C.ImGuiContext_ImGuiContext(shared_font_atlas)
}

fn C.ImGuiContext_destroy(self &C.ImGuiContext)

pub fn im_gui_context_destroy(self &C.ImGuiContext) {
	C.ImGuiContext_destroy(self)
}

fn C.ImGuiWindow_ImGuiWindow(context &C.ImGuiContext, name &i8) &C.ImGuiWindow

pub fn im_gui_window_im_gui_window(context &C.ImGuiContext, name &i8) &C.ImGuiWindow {
	return C.ImGuiWindow_ImGuiWindow(context, name)
}

fn C.ImGuiWindow_destroy(self &C.ImGuiWindow)

pub fn im_gui_window_destroy(self &C.ImGuiWindow) {
	C.ImGuiWindow_destroy(self)
}

fn C.ImGuiWindow_GetID_Str(self &C.ImGuiWindow, str &i8, str_end &i8) ImGuiID

pub fn im_gui_window_get_id_str(self &C.ImGuiWindow, str &i8, str_end &i8) ImGuiID {
	return C.ImGuiWindow_GetID_Str(self, str, str_end)
}

fn C.ImGuiWindow_GetID_Ptr(self &C.ImGuiWindow, ptr voidptr) ImGuiID

pub fn im_gui_window_get_id_ptr(self &C.ImGuiWindow, ptr voidptr) ImGuiID {
	return C.ImGuiWindow_GetID_Ptr(self, ptr)
}

fn C.ImGuiWindow_GetID_Int(self &C.ImGuiWindow, n int) ImGuiID

pub fn im_gui_window_get_id_int(self &C.ImGuiWindow, n int) ImGuiID {
	return C.ImGuiWindow_GetID_Int(self, n)
}

fn C.ImGuiWindow_GetIDFromPos(self &C.ImGuiWindow, p_abs C.ImVec2) ImGuiID

pub fn im_gui_window_get_idf_rom_pos(self &C.ImGuiWindow, p_abs C.ImVec2) ImGuiID {
	return C.ImGuiWindow_GetIDFromPos(self, p_abs)
}

fn C.ImGuiWindow_GetIDFromRectangle(self &C.ImGuiWindow, r_abs C.ImRect) ImGuiID

pub fn im_gui_window_get_idf_rom_rectangle(self &C.ImGuiWindow, r_abs C.ImRect) ImGuiID {
	return C.ImGuiWindow_GetIDFromRectangle(self, r_abs)
}

fn C.ImGuiWindow_Rect(p_out &C.ImRect, self &C.ImGuiWindow)

pub fn im_gui_window_rect(p_out &C.ImRect, self &C.ImGuiWindow) {
	C.ImGuiWindow_Rect(p_out, self)
}

fn C.ImGuiWindow_CalcFontSize(self &C.ImGuiWindow) f32

pub fn im_gui_window_calc_font_size(self &C.ImGuiWindow) f32 {
	return C.ImGuiWindow_CalcFontSize(self)
}

fn C.ImGuiWindow_TitleBarRect(p_out &C.ImRect, self &C.ImGuiWindow)

pub fn im_gui_window_title_bar_rect(p_out &C.ImRect, self &C.ImGuiWindow) {
	C.ImGuiWindow_TitleBarRect(p_out, self)
}

fn C.ImGuiWindow_MenuBarRect(p_out &C.ImRect, self &C.ImGuiWindow)

pub fn im_gui_window_menu_bar_rect(p_out &C.ImRect, self &C.ImGuiWindow) {
	C.ImGuiWindow_MenuBarRect(p_out, self)
}

fn C.ImGuiTabItem_ImGuiTabItem() &C.ImGuiTabItem

pub fn im_gui_tab_item_im_gui_tab_item() &C.ImGuiTabItem {
	return C.ImGuiTabItem_ImGuiTabItem()
}

fn C.ImGuiTabItem_destroy(self &C.ImGuiTabItem)

pub fn im_gui_tab_item_destroy(self &C.ImGuiTabItem) {
	C.ImGuiTabItem_destroy(self)
}

fn C.ImGuiTabBar_ImGuiTabBar() &C.ImGuiTabBar

pub fn im_gui_tab_bar_im_gui_tab_bar() &C.ImGuiTabBar {
	return C.ImGuiTabBar_ImGuiTabBar()
}

fn C.ImGuiTabBar_destroy(self &C.ImGuiTabBar)

pub fn im_gui_tab_bar_destroy(self &C.ImGuiTabBar) {
	C.ImGuiTabBar_destroy(self)
}

fn C.ImGuiTableColumn_ImGuiTableColumn() &C.ImGuiTableColumn

pub fn im_gui_table_column_im_gui_table_column() &C.ImGuiTableColumn {
	return C.ImGuiTableColumn_ImGuiTableColumn()
}

fn C.ImGuiTableColumn_destroy(self &C.ImGuiTableColumn)

pub fn im_gui_table_column_destroy(self &C.ImGuiTableColumn) {
	C.ImGuiTableColumn_destroy(self)
}

fn C.ImGuiTableInstanceData_ImGuiTableInstanceData() &C.ImGuiTableInstanceData

pub fn im_gui_table_instance_data_im_gui_table_instance_data() &C.ImGuiTableInstanceData {
	return C.ImGuiTableInstanceData_ImGuiTableInstanceData()
}

fn C.ImGuiTableInstanceData_destroy(self &C.ImGuiTableInstanceData)

pub fn im_gui_table_instance_data_destroy(self &C.ImGuiTableInstanceData) {
	C.ImGuiTableInstanceData_destroy(self)
}

fn C.ImGuiTable_ImGuiTable() &C.ImGuiTable

pub fn im_gui_table_im_gui_table() &C.ImGuiTable {
	return C.ImGuiTable_ImGuiTable()
}

fn C.ImGuiTable_destroy(self &C.ImGuiTable)

pub fn im_gui_table_destroy(self &C.ImGuiTable) {
	C.ImGuiTable_destroy(self)
}

fn C.ImGuiTableTempData_ImGuiTableTempData() &C.ImGuiTableTempData

pub fn im_gui_table_temp_data_im_gui_table_temp_data() &C.ImGuiTableTempData {
	return C.ImGuiTableTempData_ImGuiTableTempData()
}

fn C.ImGuiTableTempData_destroy(self &C.ImGuiTableTempData)

pub fn im_gui_table_temp_data_destroy(self &C.ImGuiTableTempData) {
	C.ImGuiTableTempData_destroy(self)
}

fn C.ImGuiTableColumnSettings_ImGuiTableColumnSettings() &C.ImGuiTableColumnSettings

pub fn im_gui_table_column_settings_im_gui_table_column_settings() &C.ImGuiTableColumnSettings {
	return C.ImGuiTableColumnSettings_ImGuiTableColumnSettings()
}

fn C.ImGuiTableColumnSettings_destroy(self &C.ImGuiTableColumnSettings)

pub fn im_gui_table_column_settings_destroy(self &C.ImGuiTableColumnSettings) {
	C.ImGuiTableColumnSettings_destroy(self)
}

fn C.ImGuiTableSettings_ImGuiTableSettings() &C.ImGuiTableSettings

pub fn im_gui_table_settings_im_gui_table_settings() &C.ImGuiTableSettings {
	return C.ImGuiTableSettings_ImGuiTableSettings()
}

fn C.ImGuiTableSettings_destroy(self &C.ImGuiTableSettings)

pub fn im_gui_table_settings_destroy(self &C.ImGuiTableSettings) {
	C.ImGuiTableSettings_destroy(self)
}

fn C.ImGuiTableSettings_GetColumnSettings(self &C.ImGuiTableSettings) &C.ImGuiTableColumnSettings

pub fn im_gui_table_settings_get_column_settings(self &C.ImGuiTableSettings) &C.ImGuiTableColumnSettings {
	return C.ImGuiTableSettings_GetColumnSettings(self)
}

fn C.igGetCurrentWindowRead() &C.ImGuiWindow

pub fn ig_get_current_window_read() &C.ImGuiWindow {
	return C.igGetCurrentWindowRead()
}

fn C.igGetCurrentWindow() &C.ImGuiWindow

pub fn ig_get_current_window() &C.ImGuiWindow {
	return C.igGetCurrentWindow()
}

fn C.igFindWindowByID(id ImGuiID) &C.ImGuiWindow

pub fn ig_find_window_by_id(id ImGuiID) &C.ImGuiWindow {
	return C.igFindWindowByID(id)
}

fn C.igFindWindowByName(name &i8) &C.ImGuiWindow

pub fn ig_find_window_by_name(name &i8) &C.ImGuiWindow {
	return C.igFindWindowByName(name)
}

fn C.igUpdateWindowParentAndRootLinks(window &C.ImGuiWindow, flags ImGuiWindowFlags, parent_window &C.ImGuiWindow)

pub fn ig_update_window_parent_and_root_links(window &C.ImGuiWindow, flags ImGuiWindowFlags, parent_window &C.ImGuiWindow) {
	C.igUpdateWindowParentAndRootLinks(window, flags, parent_window)
}

fn C.igUpdateWindowSkipRefresh(window &C.ImGuiWindow)

pub fn ig_update_window_skip_refresh(window &C.ImGuiWindow) {
	C.igUpdateWindowSkipRefresh(window)
}

fn C.igCalcWindowNextAutoFitSize(p_out &C.ImVec2, window &C.ImGuiWindow)

pub fn ig_calc_window_next_auto_fit_size(p_out &C.ImVec2, window &C.ImGuiWindow) {
	C.igCalcWindowNextAutoFitSize(p_out, window)
}

fn C.igIsWindowChildOf(window &C.ImGuiWindow, potential_parent &C.ImGuiWindow, popup_hierarchy bool, dock_hierarchy bool) bool

pub fn ig_is_window_child_of(window &C.ImGuiWindow, potential_parent &C.ImGuiWindow, popup_hierarchy bool, dock_hierarchy bool) bool {
	return C.igIsWindowChildOf(window, potential_parent, popup_hierarchy, dock_hierarchy)
}

fn C.igIsWindowWithinBeginStackOf(window &C.ImGuiWindow, potential_parent &C.ImGuiWindow) bool

pub fn ig_is_window_within_begin_stack_of(window &C.ImGuiWindow, potential_parent &C.ImGuiWindow) bool {
	return C.igIsWindowWithinBeginStackOf(window, potential_parent)
}

fn C.igIsWindowAbove(potential_above &C.ImGuiWindow, potential_below &C.ImGuiWindow) bool

pub fn ig_is_window_above(potential_above &C.ImGuiWindow, potential_below &C.ImGuiWindow) bool {
	return C.igIsWindowAbove(potential_above, potential_below)
}

fn C.igIsWindowNavFocusable(window &C.ImGuiWindow) bool

pub fn ig_is_window_nav_focusable(window &C.ImGuiWindow) bool {
	return C.igIsWindowNavFocusable(window)
}

fn C.igSetWindowPos_WindowPtr(window &C.ImGuiWindow, pos C.ImVec2, cond ImGuiCond)

pub fn ig_set_window_pos_window_ptr(window &C.ImGuiWindow, pos C.ImVec2, cond ImGuiCond) {
	C.igSetWindowPos_WindowPtr(window, pos, cond)
}

fn C.igSetWindowSize_WindowPtr(window &C.ImGuiWindow, size C.ImVec2, cond ImGuiCond)

pub fn ig_set_window_size_window_ptr(window &C.ImGuiWindow, size C.ImVec2, cond ImGuiCond) {
	C.igSetWindowSize_WindowPtr(window, size, cond)
}

fn C.igSetWindowCollapsed_WindowPtr(window &C.ImGuiWindow, collapsed bool, cond ImGuiCond)

pub fn ig_set_window_collapsed_window_ptr(window &C.ImGuiWindow, collapsed bool, cond ImGuiCond) {
	C.igSetWindowCollapsed_WindowPtr(window, collapsed, cond)
}

fn C.igSetWindowHitTestHole(window &C.ImGuiWindow, pos C.ImVec2, size C.ImVec2)

pub fn ig_set_window_hit_test_hole(window &C.ImGuiWindow, pos C.ImVec2, size C.ImVec2) {
	C.igSetWindowHitTestHole(window, pos, size)
}

fn C.igSetWindowHiddenAndSkipItemsForCurrentFrame(window &C.ImGuiWindow)

pub fn ig_set_window_hidden_and_skip_items_for_current_frame(window &C.ImGuiWindow) {
	C.igSetWindowHiddenAndSkipItemsForCurrentFrame(window)
}

fn C.igSetWindowParentWindowForFocusRoute(window &C.ImGuiWindow, parent_window &C.ImGuiWindow)

pub fn ig_set_window_parent_window_for_focus_route(window &C.ImGuiWindow, parent_window &C.ImGuiWindow) {
	C.igSetWindowParentWindowForFocusRoute(window, parent_window)
}

fn C.igWindowRectAbsToRel(p_out &C.ImRect, window &C.ImGuiWindow, r C.ImRect)

pub fn ig_window_rect_abs_to_rel(p_out &C.ImRect, window &C.ImGuiWindow, r C.ImRect) {
	C.igWindowRectAbsToRel(p_out, window, r)
}

fn C.igWindowRectRelToAbs(p_out &C.ImRect, window &C.ImGuiWindow, r C.ImRect)

pub fn ig_window_rect_rel_to_abs(p_out &C.ImRect, window &C.ImGuiWindow, r C.ImRect) {
	C.igWindowRectRelToAbs(p_out, window, r)
}

fn C.igWindowPosAbsToRel(p_out &C.ImVec2, window &C.ImGuiWindow, p C.ImVec2)

pub fn ig_window_pos_abs_to_rel(p_out &C.ImVec2, window &C.ImGuiWindow, p C.ImVec2) {
	C.igWindowPosAbsToRel(p_out, window, p)
}

fn C.igWindowPosRelToAbs(p_out &C.ImVec2, window &C.ImGuiWindow, p C.ImVec2)

pub fn ig_window_pos_rel_to_abs(p_out &C.ImVec2, window &C.ImGuiWindow, p C.ImVec2) {
	C.igWindowPosRelToAbs(p_out, window, p)
}

fn C.igFocusWindow(window &C.ImGuiWindow, flags ImGuiFocusRequestFlags)

pub fn ig_focus_window(window &C.ImGuiWindow, flags ImGuiFocusRequestFlags) {
	C.igFocusWindow(window, flags)
}

fn C.igFocusTopMostWindowUnderOne(under_this_window &C.ImGuiWindow, ignore_window &C.ImGuiWindow, filter_viewport &C.ImGuiViewport, flags ImGuiFocusRequestFlags)

pub fn ig_focus_top_most_window_under_one(under_this_window &C.ImGuiWindow, ignore_window &C.ImGuiWindow, filter_viewport &C.ImGuiViewport, flags ImGuiFocusRequestFlags) {
	C.igFocusTopMostWindowUnderOne(under_this_window, ignore_window, filter_viewport,
		flags)
}

fn C.igBringWindowToFocusFront(window &C.ImGuiWindow)

pub fn ig_bring_window_to_focus_front(window &C.ImGuiWindow) {
	C.igBringWindowToFocusFront(window)
}

fn C.igBringWindowToDisplayFront(window &C.ImGuiWindow)

pub fn ig_bring_window_to_display_front(window &C.ImGuiWindow) {
	C.igBringWindowToDisplayFront(window)
}

fn C.igBringWindowToDisplayBack(window &C.ImGuiWindow)

pub fn ig_bring_window_to_display_back(window &C.ImGuiWindow) {
	C.igBringWindowToDisplayBack(window)
}

fn C.igBringWindowToDisplayBehind(window &C.ImGuiWindow, above_window &C.ImGuiWindow)

pub fn ig_bring_window_to_display_behind(window &C.ImGuiWindow, above_window &C.ImGuiWindow) {
	C.igBringWindowToDisplayBehind(window, above_window)
}

fn C.igFindWindowDisplayIndex(window &C.ImGuiWindow) int

pub fn ig_find_window_display_index(window &C.ImGuiWindow) int {
	return C.igFindWindowDisplayIndex(window)
}

fn C.igFindBottomMostVisibleWindowWithinBeginStack(window &C.ImGuiWindow) &C.ImGuiWindow

pub fn ig_find_bottom_most_visible_window_within_begin_stack(window &C.ImGuiWindow) &C.ImGuiWindow {
	return C.igFindBottomMostVisibleWindowWithinBeginStack(window)
}

fn C.igSetNextWindowRefreshPolicy(flags ImGuiWindowRefreshFlags)

pub fn ig_set_next_window_refresh_policy(flags ImGuiWindowRefreshFlags) {
	C.igSetNextWindowRefreshPolicy(flags)
}

fn C.igSetCurrentFont(font &C.ImFont)

pub fn ig_set_current_font(font &C.ImFont) {
	C.igSetCurrentFont(font)
}

fn C.igGetDefaultFont() &C.ImFont

pub fn ig_get_default_font() &C.ImFont {
	return C.igGetDefaultFont()
}

fn C.igGetForegroundDrawList_WindowPtr(window &C.ImGuiWindow) &C.ImDrawList

pub fn ig_get_foreground_draw_list_window_ptr(window &C.ImGuiWindow) &C.ImDrawList {
	return C.igGetForegroundDrawList_WindowPtr(window)
}

fn C.igAddDrawListToDrawDataEx(draw_data &C.ImDrawData, out_list &C.ImVector_ImDrawListPtr, draw_list &C.ImDrawList)

pub fn ig_add_draw_list_to_draw_data_ex(draw_data &C.ImDrawData, out_list &C.ImVector_ImDrawListPtr, draw_list &C.ImDrawList) {
	C.igAddDrawListToDrawDataEx(draw_data, out_list, draw_list)
}

fn C.igInitialize()

pub fn ig_initialize() {
	C.igInitialize()
}

fn C.igShutdown()

pub fn ig_shutdown() {
	C.igShutdown()
}

fn C.igUpdateInputEvents(trickle_fast_inputs bool)

pub fn ig_update_input_events(trickle_fast_inputs bool) {
	C.igUpdateInputEvents(trickle_fast_inputs)
}

fn C.igUpdateHoveredWindowAndCaptureFlags()

pub fn ig_update_hovered_window_and_capture_flags() {
	C.igUpdateHoveredWindowAndCaptureFlags()
}

fn C.igFindHoveredWindowEx(pos C.ImVec2, find_first_and_in_any_viewport bool, out_hovered_window &&C.ImGuiWindow, out_hovered_window_under_moving_window &&C.ImGuiWindow)

pub fn ig_find_hovered_window_ex(pos C.ImVec2, find_first_and_in_any_viewport bool, out_hovered_window &&C.ImGuiWindow, out_hovered_window_under_moving_window &&C.ImGuiWindow) {
	C.igFindHoveredWindowEx(pos, find_first_and_in_any_viewport, out_hovered_window, out_hovered_window_under_moving_window)
}

fn C.igStartMouseMovingWindow(window &C.ImGuiWindow)

pub fn ig_start_mouse_moving_window(window &C.ImGuiWindow) {
	C.igStartMouseMovingWindow(window)
}

fn C.igStartMouseMovingWindowOrNode(window &C.ImGuiWindow, node &C.ImGuiDockNode, undock bool)

pub fn ig_start_mouse_moving_window_or_node(window &C.ImGuiWindow, node &C.ImGuiDockNode, undock bool) {
	C.igStartMouseMovingWindowOrNode(window, node, undock)
}

fn C.igUpdateMouseMovingWindowNewFrame()

pub fn ig_update_mouse_moving_window_new_frame() {
	C.igUpdateMouseMovingWindowNewFrame()
}

fn C.igUpdateMouseMovingWindowEndFrame()

pub fn ig_update_mouse_moving_window_end_frame() {
	C.igUpdateMouseMovingWindowEndFrame()
}

fn C.igAddContextHook(context &C.ImGuiContext, hook &C.ImGuiContextHook) ImGuiID

pub fn ig_add_context_hook(context &C.ImGuiContext, hook &C.ImGuiContextHook) ImGuiID {
	return C.igAddContextHook(context, hook)
}

fn C.igRemoveContextHook(context &C.ImGuiContext, hook_to_remove ImGuiID)

pub fn ig_remove_context_hook(context &C.ImGuiContext, hook_to_remove ImGuiID) {
	C.igRemoveContextHook(context, hook_to_remove)
}

fn C.igCallContextHooks(context &C.ImGuiContext, type_ ImGuiContextHookType)

pub fn ig_call_context_hooks(context &C.ImGuiContext, type_ ImGuiContextHookType) {
	C.igCallContextHooks(context, type_)
}

fn C.igTranslateWindowsInViewport(viewport &C.ImGuiViewportP, old_pos C.ImVec2, new_pos C.ImVec2)

pub fn ig_translate_windows_in_viewport(viewport &C.ImGuiViewportP, old_pos C.ImVec2, new_pos C.ImVec2) {
	C.igTranslateWindowsInViewport(viewport, old_pos, new_pos)
}

fn C.igScaleWindowsInViewport(viewport &C.ImGuiViewportP, scale f32)

pub fn ig_scale_windows_in_viewport(viewport &C.ImGuiViewportP, scale f32) {
	C.igScaleWindowsInViewport(viewport, scale)
}

fn C.igDestroyPlatformWindow(viewport &C.ImGuiViewportP)

pub fn ig_destroy_platform_window(viewport &C.ImGuiViewportP) {
	C.igDestroyPlatformWindow(viewport)
}

fn C.igSetWindowViewport(window &C.ImGuiWindow, viewport &C.ImGuiViewportP)

pub fn ig_set_window_viewport(window &C.ImGuiWindow, viewport &C.ImGuiViewportP) {
	C.igSetWindowViewport(window, viewport)
}

fn C.igSetCurrentViewport(window &C.ImGuiWindow, viewport &C.ImGuiViewportP)

pub fn ig_set_current_viewport(window &C.ImGuiWindow, viewport &C.ImGuiViewportP) {
	C.igSetCurrentViewport(window, viewport)
}

fn C.igGetViewportPlatformMonitor(viewport &C.ImGuiViewport) &C.ImGuiPlatformMonitor

pub fn ig_get_viewport_platform_monitor(viewport &C.ImGuiViewport) &C.ImGuiPlatformMonitor {
	return C.igGetViewportPlatformMonitor(viewport)
}

fn C.igFindHoveredViewportFromPlatformWindowStack(mouse_platform_pos C.ImVec2) &C.ImGuiViewportP

pub fn ig_find_hovered_viewport_from_platform_window_stack(mouse_platform_pos C.ImVec2) &C.ImGuiViewportP {
	return C.igFindHoveredViewportFromPlatformWindowStack(mouse_platform_pos)
}

fn C.igMarkIniSettingsDirty_Nil()

pub fn ig_mark_ini_settings_dirty_nil() {
	C.igMarkIniSettingsDirty_Nil()
}

fn C.igMarkIniSettingsDirty_WindowPtr(window &C.ImGuiWindow)

pub fn ig_mark_ini_settings_dirty_window_ptr(window &C.ImGuiWindow) {
	C.igMarkIniSettingsDirty_WindowPtr(window)
}

fn C.igClearIniSettings()

pub fn ig_clear_ini_settings() {
	C.igClearIniSettings()
}

fn C.igAddSettingsHandler(handler &C.ImGuiSettingsHandler)

pub fn ig_add_settings_handler(handler &C.ImGuiSettingsHandler) {
	C.igAddSettingsHandler(handler)
}

fn C.igRemoveSettingsHandler(type_name &i8)

pub fn ig_remove_settings_handler(type_name &i8) {
	C.igRemoveSettingsHandler(type_name)
}

fn C.igFindSettingsHandler(type_name &i8) &C.ImGuiSettingsHandler

pub fn ig_find_settings_handler(type_name &i8) &C.ImGuiSettingsHandler {
	return C.igFindSettingsHandler(type_name)
}

fn C.igCreateNewWindowSettings(name &i8) &C.ImGuiWindowSettings

pub fn ig_create_new_window_settings(name &i8) &C.ImGuiWindowSettings {
	return C.igCreateNewWindowSettings(name)
}

fn C.igFindWindowSettingsByID(id ImGuiID) &C.ImGuiWindowSettings

pub fn ig_find_window_settings_by_id(id ImGuiID) &C.ImGuiWindowSettings {
	return C.igFindWindowSettingsByID(id)
}

fn C.igFindWindowSettingsByWindow(window &C.ImGuiWindow) &C.ImGuiWindowSettings

pub fn ig_find_window_settings_by_window(window &C.ImGuiWindow) &C.ImGuiWindowSettings {
	return C.igFindWindowSettingsByWindow(window)
}

fn C.igClearWindowSettings(name &i8)

pub fn ig_clear_window_settings(name &i8) {
	C.igClearWindowSettings(name)
}

fn C.igLocalizeRegisterEntries(entries &C.ImGuiLocEntry, count int)

pub fn ig_localize_register_entries(entries &C.ImGuiLocEntry, count int) {
	C.igLocalizeRegisterEntries(entries, count)
}

fn C.igLocalizeGetMsg(key ImGuiLocKey) &i8

pub fn ig_localize_get_msg(key ImGuiLocKey) &i8 {
	return C.igLocalizeGetMsg(key)
}

fn C.igSetScrollX_WindowPtr(window &C.ImGuiWindow, scroll_x f32)

pub fn ig_set_scroll_x_window_ptr(window &C.ImGuiWindow, scroll_x f32) {
	C.igSetScrollX_WindowPtr(window, scroll_x)
}

fn C.igSetScrollY_WindowPtr(window &C.ImGuiWindow, scroll_y f32)

pub fn ig_set_scroll_y_window_ptr(window &C.ImGuiWindow, scroll_y f32) {
	C.igSetScrollY_WindowPtr(window, scroll_y)
}

fn C.igSetScrollFromPosX_WindowPtr(window &C.ImGuiWindow, local_x f32, center_x_ratio f32)

pub fn ig_set_scroll_from_pos_x_window_ptr(window &C.ImGuiWindow, local_x f32, center_x_ratio f32) {
	C.igSetScrollFromPosX_WindowPtr(window, local_x, center_x_ratio)
}

fn C.igSetScrollFromPosY_WindowPtr(window &C.ImGuiWindow, local_y f32, center_y_ratio f32)

pub fn ig_set_scroll_from_pos_y_window_ptr(window &C.ImGuiWindow, local_y f32, center_y_ratio f32) {
	C.igSetScrollFromPosY_WindowPtr(window, local_y, center_y_ratio)
}

fn C.igScrollToItem(flags ImGuiScrollFlags)

pub fn ig_scroll_to_item(flags ImGuiScrollFlags) {
	C.igScrollToItem(flags)
}

fn C.igScrollToRect(window &C.ImGuiWindow, rect C.ImRect, flags ImGuiScrollFlags)

pub fn ig_scroll_to_rect(window &C.ImGuiWindow, rect C.ImRect, flags ImGuiScrollFlags) {
	C.igScrollToRect(window, rect, flags)
}

fn C.igScrollToRectEx(p_out &C.ImVec2, window &C.ImGuiWindow, rect C.ImRect, flags ImGuiScrollFlags)

pub fn ig_scroll_to_rect_ex(p_out &C.ImVec2, window &C.ImGuiWindow, rect C.ImRect, flags ImGuiScrollFlags) {
	C.igScrollToRectEx(p_out, window, rect, flags)
}

fn C.igScrollToBringRectIntoView(window &C.ImGuiWindow, rect C.ImRect)

pub fn ig_scroll_to_bring_rect_into_view(window &C.ImGuiWindow, rect C.ImRect) {
	C.igScrollToBringRectIntoView(window, rect)
}

fn C.igGetItemStatusFlags() ImGuiItemStatusFlags

pub fn ig_get_item_status_flags() ImGuiItemStatusFlags {
	return C.igGetItemStatusFlags()
}

fn C.igGetItemFlags() ImGuiItemFlags

pub fn ig_get_item_flags() ImGuiItemFlags {
	return C.igGetItemFlags()
}

fn C.igGetActiveID() ImGuiID

pub fn ig_get_active_id() ImGuiID {
	return C.igGetActiveID()
}

fn C.igGetFocusID() ImGuiID

pub fn ig_get_focus_id() ImGuiID {
	return C.igGetFocusID()
}

fn C.igSetActiveID(id ImGuiID, window &C.ImGuiWindow)

pub fn ig_set_active_id(id ImGuiID, window &C.ImGuiWindow) {
	C.igSetActiveID(id, window)
}

fn C.igSetFocusID(id ImGuiID, window &C.ImGuiWindow)

pub fn ig_set_focus_id(id ImGuiID, window &C.ImGuiWindow) {
	C.igSetFocusID(id, window)
}

fn C.igClearActiveID()

pub fn ig_clear_active_id() {
	C.igClearActiveID()
}

fn C.igGetHoveredID() ImGuiID

pub fn ig_get_hovered_id() ImGuiID {
	return C.igGetHoveredID()
}

fn C.igSetHoveredID(id ImGuiID)

pub fn ig_set_hovered_id(id ImGuiID) {
	C.igSetHoveredID(id)
}

fn C.igKeepAliveID(id ImGuiID)

pub fn ig_keep_alive_id(id ImGuiID) {
	C.igKeepAliveID(id)
}

fn C.igMarkItemEdited(id ImGuiID)

pub fn ig_mark_item_edited(id ImGuiID) {
	C.igMarkItemEdited(id)
}

fn C.igPushOverrideID(id ImGuiID)

pub fn ig_push_override_id(id ImGuiID) {
	C.igPushOverrideID(id)
}

fn C.igGetIDWithSeed_Str(str_id_begin &i8, str_id_end &i8, seed ImGuiID) ImGuiID

pub fn ig_get_idw_ith_seed_str(str_id_begin &i8, str_id_end &i8, seed ImGuiID) ImGuiID {
	return C.igGetIDWithSeed_Str(str_id_begin, str_id_end, seed)
}

fn C.igGetIDWithSeed_Int(n int, seed ImGuiID) ImGuiID

pub fn ig_get_idw_ith_seed_int(n int, seed ImGuiID) ImGuiID {
	return C.igGetIDWithSeed_Int(n, seed)
}

fn C.igItemSize_Vec2(size C.ImVec2, text_baseline_y f32)

pub fn ig_item_size_vec2(size C.ImVec2, text_baseline_y f32) {
	C.igItemSize_Vec2(size, text_baseline_y)
}

fn C.igItemSize_Rect(bb C.ImRect, text_baseline_y f32)

pub fn ig_item_size_rect(bb C.ImRect, text_baseline_y f32) {
	C.igItemSize_Rect(bb, text_baseline_y)
}

fn C.igItemAdd(bb C.ImRect, id ImGuiID, nav_bb &C.ImRect, extra_flags ImGuiItemFlags) bool

pub fn ig_item_add(bb C.ImRect, id ImGuiID, nav_bb &C.ImRect, extra_flags ImGuiItemFlags) bool {
	return C.igItemAdd(bb, id, nav_bb, extra_flags)
}

fn C.igItemHoverable(bb C.ImRect, id ImGuiID, item_flags ImGuiItemFlags) bool

pub fn ig_item_hoverable(bb C.ImRect, id ImGuiID, item_flags ImGuiItemFlags) bool {
	return C.igItemHoverable(bb, id, item_flags)
}

fn C.igIsWindowContentHoverable(window &C.ImGuiWindow, flags ImGuiHoveredFlags) bool

pub fn ig_is_window_content_hoverable(window &C.ImGuiWindow, flags ImGuiHoveredFlags) bool {
	return C.igIsWindowContentHoverable(window, flags)
}

fn C.igIsClippedEx(bb C.ImRect, id ImGuiID) bool

pub fn ig_is_clipped_ex(bb C.ImRect, id ImGuiID) bool {
	return C.igIsClippedEx(bb, id)
}

fn C.igSetLastItemData(item_id ImGuiID, in_flags ImGuiItemFlags, status_flags ImGuiItemStatusFlags, item_rect C.ImRect)

pub fn ig_set_last_item_data(item_id ImGuiID, in_flags ImGuiItemFlags, status_flags ImGuiItemStatusFlags, item_rect C.ImRect) {
	C.igSetLastItemData(item_id, in_flags, status_flags, item_rect)
}

fn C.igCalcItemSize(p_out &C.ImVec2, size C.ImVec2, default_w f32, default_h f32)

pub fn ig_calc_item_size(p_out &C.ImVec2, size C.ImVec2, default_w f32, default_h f32) {
	C.igCalcItemSize(p_out, size, default_w, default_h)
}

fn C.igCalcWrapWidthForPos(pos C.ImVec2, wrap_pos_x f32) f32

pub fn ig_calc_wrap_width_for_pos(pos C.ImVec2, wrap_pos_x f32) f32 {
	return C.igCalcWrapWidthForPos(pos, wrap_pos_x)
}

fn C.igPushMultiItemsWidths(components int, width_full f32)

pub fn ig_push_multi_items_widths(components int, width_full f32) {
	C.igPushMultiItemsWidths(components, width_full)
}

fn C.igShrinkWidths(items &C.ImGuiShrinkWidthItem, count int, width_excess f32)

pub fn ig_shrink_widths(items &C.ImGuiShrinkWidthItem, count int, width_excess f32) {
	C.igShrinkWidths(items, count, width_excess)
}

fn C.igGetStyleVarInfo(idx ImGuiStyleVar) &C.ImGuiDataVarInfo

pub fn ig_get_style_var_info(idx ImGuiStyleVar) &C.ImGuiDataVarInfo {
	return C.igGetStyleVarInfo(idx)
}

fn C.igBeginDisabledOverrideReenable()

pub fn ig_begin_disabled_override_reenable() {
	C.igBeginDisabledOverrideReenable()
}

fn C.igEndDisabledOverrideReenable()

pub fn ig_end_disabled_override_reenable() {
	C.igEndDisabledOverrideReenable()
}

fn C.igLogBegin(type_ ImGuiLogType, auto_open_depth int)

pub fn ig_log_begin(type_ ImGuiLogType, auto_open_depth int) {
	C.igLogBegin(type_, auto_open_depth)
}

fn C.igLogToBuffer(auto_open_depth int)

pub fn ig_log_to_buffer(auto_open_depth int) {
	C.igLogToBuffer(auto_open_depth)
}

fn C.igLogRenderedText(ref_pos &C.ImVec2, text &i8, text_end &i8)

pub fn ig_log_rendered_text(ref_pos &C.ImVec2, text &i8, text_end &i8) {
	C.igLogRenderedText(ref_pos, text, text_end)
}

fn C.igLogSetNextTextDecoration(prefix &i8, suffix &i8)

pub fn ig_log_set_next_text_decoration(prefix &i8, suffix &i8) {
	C.igLogSetNextTextDecoration(prefix, suffix)
}

fn C.igBeginChildEx(name &i8, id ImGuiID, size_arg C.ImVec2, child_flags ImGuiChildFlags, window_flags ImGuiWindowFlags) bool

pub fn ig_begin_child_ex(name &i8, id ImGuiID, size_arg C.ImVec2, child_flags ImGuiChildFlags, window_flags ImGuiWindowFlags) bool {
	return C.igBeginChildEx(name, id, size_arg, child_flags, window_flags)
}

fn C.igBeginPopupEx(id ImGuiID, extra_window_flags ImGuiWindowFlags) bool

pub fn ig_begin_popup_ex(id ImGuiID, extra_window_flags ImGuiWindowFlags) bool {
	return C.igBeginPopupEx(id, extra_window_flags)
}

fn C.igOpenPopupEx(id ImGuiID, popup_flags ImGuiPopupFlags)

pub fn ig_open_popup_ex(id ImGuiID, popup_flags ImGuiPopupFlags) {
	C.igOpenPopupEx(id, popup_flags)
}

fn C.igClosePopupToLevel(remaining int, restore_focus_to_window_under_popup bool)

pub fn ig_close_popup_to_level(remaining int, restore_focus_to_window_under_popup bool) {
	C.igClosePopupToLevel(remaining, restore_focus_to_window_under_popup)
}

fn C.igClosePopupsOverWindow(ref_window &C.ImGuiWindow, restore_focus_to_window_under_popup bool)

pub fn ig_close_popups_over_window(ref_window &C.ImGuiWindow, restore_focus_to_window_under_popup bool) {
	C.igClosePopupsOverWindow(ref_window, restore_focus_to_window_under_popup)
}

fn C.igClosePopupsExceptModals()

pub fn ig_close_popups_except_modals() {
	C.igClosePopupsExceptModals()
}

fn C.igIsPopupOpen_ID(id ImGuiID, popup_flags ImGuiPopupFlags) bool

pub fn ig_is_popup_open_id(id ImGuiID, popup_flags ImGuiPopupFlags) bool {
	return C.igIsPopupOpen_ID(id, popup_flags)
}

fn C.igGetPopupAllowedExtentRect(p_out &C.ImRect, window &C.ImGuiWindow)

pub fn ig_get_popup_allowed_extent_rect(p_out &C.ImRect, window &C.ImGuiWindow) {
	C.igGetPopupAllowedExtentRect(p_out, window)
}

fn C.igGetTopMostPopupModal() &C.ImGuiWindow

pub fn ig_get_top_most_popup_modal() &C.ImGuiWindow {
	return C.igGetTopMostPopupModal()
}

fn C.igGetTopMostAndVisiblePopupModal() &C.ImGuiWindow

pub fn ig_get_top_most_and_visible_popup_modal() &C.ImGuiWindow {
	return C.igGetTopMostAndVisiblePopupModal()
}

fn C.igFindBlockingModal(window &C.ImGuiWindow) &C.ImGuiWindow

pub fn ig_find_blocking_modal(window &C.ImGuiWindow) &C.ImGuiWindow {
	return C.igFindBlockingModal(window)
}

fn C.igFindBestWindowPosForPopup(p_out &C.ImVec2, window &C.ImGuiWindow)

pub fn ig_find_best_window_pos_for_popup(p_out &C.ImVec2, window &C.ImGuiWindow) {
	C.igFindBestWindowPosForPopup(p_out, window)
}

fn C.igFindBestWindowPosForPopupEx(p_out &C.ImVec2, ref_pos C.ImVec2, size C.ImVec2, last_dir &ImGuiDir, r_outer C.ImRect, r_avoid C.ImRect, policy ImGuiPopupPositionPolicy)

pub fn ig_find_best_window_pos_for_popup_ex(p_out &C.ImVec2, ref_pos C.ImVec2, size C.ImVec2, last_dir &ImGuiDir, r_outer C.ImRect, r_avoid C.ImRect, policy ImGuiPopupPositionPolicy) {
	C.igFindBestWindowPosForPopupEx(p_out, ref_pos, size, last_dir, r_outer, r_avoid,
		policy)
}

fn C.igBeginTooltipEx(tooltip_flags ImGuiTooltipFlags, extra_window_flags ImGuiWindowFlags) bool

pub fn ig_begin_tooltip_ex(tooltip_flags ImGuiTooltipFlags, extra_window_flags ImGuiWindowFlags) bool {
	return C.igBeginTooltipEx(tooltip_flags, extra_window_flags)
}

fn C.igBeginTooltipHidden() bool

pub fn ig_begin_tooltip_hidden() bool {
	return C.igBeginTooltipHidden()
}

fn C.igBeginViewportSideBar(name &i8, viewport &C.ImGuiViewport, dir ImGuiDir, size f32, window_flags ImGuiWindowFlags) bool

pub fn ig_begin_viewport_side_bar(name &i8, viewport &C.ImGuiViewport, dir ImGuiDir, size f32, window_flags ImGuiWindowFlags) bool {
	return C.igBeginViewportSideBar(name, viewport, dir, size, window_flags)
}

fn C.igBeginMenuEx(label &i8, icon &i8, enabled bool) bool

pub fn ig_begin_menu_ex(label &i8, icon &i8, enabled bool) bool {
	return C.igBeginMenuEx(label, icon, enabled)
}

fn C.igMenuItemEx(label &i8, icon &i8, shortcut &i8, selected bool, enabled bool) bool

pub fn ig_menu_item_ex(label &i8, icon &i8, shortcut &i8, selected bool, enabled bool) bool {
	return C.igMenuItemEx(label, icon, shortcut, selected, enabled)
}

fn C.igBeginComboPopup(popup_id ImGuiID, bb C.ImRect, flags ImGuiComboFlags) bool

pub fn ig_begin_combo_popup(popup_id ImGuiID, bb C.ImRect, flags ImGuiComboFlags) bool {
	return C.igBeginComboPopup(popup_id, bb, flags)
}

fn C.igBeginComboPreview() bool

pub fn ig_begin_combo_preview() bool {
	return C.igBeginComboPreview()
}

fn C.igEndComboPreview()

pub fn ig_end_combo_preview() {
	C.igEndComboPreview()
}

fn C.igNavInitWindow(window &C.ImGuiWindow, force_reinit bool)

pub fn ig_nav_init_window(window &C.ImGuiWindow, force_reinit bool) {
	C.igNavInitWindow(window, force_reinit)
}

fn C.igNavInitRequestApplyResult()

pub fn ig_nav_init_request_apply_result() {
	C.igNavInitRequestApplyResult()
}

fn C.igNavMoveRequestButNoResultYet() bool

pub fn ig_nav_move_request_but_no_result_yet() bool {
	return C.igNavMoveRequestButNoResultYet()
}

fn C.igNavMoveRequestSubmit(move_dir ImGuiDir, clip_dir ImGuiDir, move_flags ImGuiNavMoveFlags, scroll_flags ImGuiScrollFlags)

pub fn ig_nav_move_request_submit(move_dir ImGuiDir, clip_dir ImGuiDir, move_flags ImGuiNavMoveFlags, scroll_flags ImGuiScrollFlags) {
	C.igNavMoveRequestSubmit(move_dir, clip_dir, move_flags, scroll_flags)
}

fn C.igNavMoveRequestForward(move_dir ImGuiDir, clip_dir ImGuiDir, move_flags ImGuiNavMoveFlags, scroll_flags ImGuiScrollFlags)

pub fn ig_nav_move_request_forward(move_dir ImGuiDir, clip_dir ImGuiDir, move_flags ImGuiNavMoveFlags, scroll_flags ImGuiScrollFlags) {
	C.igNavMoveRequestForward(move_dir, clip_dir, move_flags, scroll_flags)
}

fn C.igNavMoveRequestResolveWithLastItem(result &C.ImGuiNavItemData)

pub fn ig_nav_move_request_resolve_with_last_item(result &C.ImGuiNavItemData) {
	C.igNavMoveRequestResolveWithLastItem(result)
}

fn C.igNavMoveRequestResolveWithPastTreeNode(result &C.ImGuiNavItemData, tree_node_data &C.ImGuiTreeNodeStackData)

pub fn ig_nav_move_request_resolve_with_past_tree_node(result &C.ImGuiNavItemData, tree_node_data &C.ImGuiTreeNodeStackData) {
	C.igNavMoveRequestResolveWithPastTreeNode(result, tree_node_data)
}

fn C.igNavMoveRequestCancel()

pub fn ig_nav_move_request_cancel() {
	C.igNavMoveRequestCancel()
}

fn C.igNavMoveRequestApplyResult()

pub fn ig_nav_move_request_apply_result() {
	C.igNavMoveRequestApplyResult()
}

fn C.igNavMoveRequestTryWrapping(window &C.ImGuiWindow, move_flags ImGuiNavMoveFlags)

pub fn ig_nav_move_request_try_wrapping(window &C.ImGuiWindow, move_flags ImGuiNavMoveFlags) {
	C.igNavMoveRequestTryWrapping(window, move_flags)
}

fn C.igNavHighlightActivated(id ImGuiID)

pub fn ig_nav_highlight_activated(id ImGuiID) {
	C.igNavHighlightActivated(id)
}

fn C.igNavClearPreferredPosForAxis(axis ImGuiAxis)

pub fn ig_nav_clear_preferred_pos_for_axis(axis ImGuiAxis) {
	C.igNavClearPreferredPosForAxis(axis)
}

fn C.igNavRestoreHighlightAfterMove()

pub fn ig_nav_restore_highlight_after_move() {
	C.igNavRestoreHighlightAfterMove()
}

fn C.igNavUpdateCurrentWindowIsScrollPushableX()

pub fn ig_nav_update_current_window_is_scroll_pushable_x() {
	C.igNavUpdateCurrentWindowIsScrollPushableX()
}

fn C.igSetNavWindow(window &C.ImGuiWindow)

pub fn ig_set_nav_window(window &C.ImGuiWindow) {
	C.igSetNavWindow(window)
}

fn C.igSetNavID(id ImGuiID, nav_layer ImGuiNavLayer, focus_scope_id ImGuiID, rect_rel C.ImRect)

pub fn ig_set_nav_id(id ImGuiID, nav_layer ImGuiNavLayer, focus_scope_id ImGuiID, rect_rel C.ImRect) {
	C.igSetNavID(id, nav_layer, focus_scope_id, rect_rel)
}

fn C.igSetNavFocusScope(focus_scope_id ImGuiID)

pub fn ig_set_nav_focus_scope(focus_scope_id ImGuiID) {
	C.igSetNavFocusScope(focus_scope_id)
}

fn C.igFocusItem()

pub fn ig_focus_item() {
	C.igFocusItem()
}

fn C.igActivateItemByID(id ImGuiID)

pub fn ig_activate_item_by_id(id ImGuiID) {
	C.igActivateItemByID(id)
}

fn C.igIsNamedKey(key ImGuiKey) bool

pub fn ig_is_named_key(key ImGuiKey) bool {
	return C.igIsNamedKey(key)
}

fn C.igIsNamedKeyOrMod(key ImGuiKey) bool

pub fn ig_is_named_key_or_mod(key ImGuiKey) bool {
	return C.igIsNamedKeyOrMod(key)
}

fn C.igIsLegacyKey(key ImGuiKey) bool

pub fn ig_is_legacy_key(key ImGuiKey) bool {
	return C.igIsLegacyKey(key)
}

fn C.igIsKeyboardKey(key ImGuiKey) bool

pub fn ig_is_keyboard_key(key ImGuiKey) bool {
	return C.igIsKeyboardKey(key)
}

fn C.igIsGamepadKey(key ImGuiKey) bool

pub fn ig_is_gamepad_key(key ImGuiKey) bool {
	return C.igIsGamepadKey(key)
}

fn C.igIsMouseKey(key ImGuiKey) bool

pub fn ig_is_mouse_key(key ImGuiKey) bool {
	return C.igIsMouseKey(key)
}

fn C.igIsAliasKey(key ImGuiKey) bool

pub fn ig_is_alias_key(key ImGuiKey) bool {
	return C.igIsAliasKey(key)
}

fn C.igIsLRModKey(key ImGuiKey) bool

pub fn ig_is_lrm_od_key(key ImGuiKey) bool {
	return C.igIsLRModKey(key)
}

fn C.igFixupKeyChord(key_chord ImGuiKeyChord) ImGuiKeyChord

pub fn ig_fixup_key_chord(key_chord ImGuiKeyChord) ImGuiKeyChord {
	return C.igFixupKeyChord(key_chord)
}

fn C.igConvertSingleModFlagToKey(key ImGuiKey) ImGuiKey

pub fn ig_convert_single_mod_flag_to_key(key ImGuiKey) ImGuiKey {
	return C.igConvertSingleModFlagToKey(key)
}

fn C.igGetKeyData_ContextPtr(ctx &C.ImGuiContext, key ImGuiKey) &C.ImGuiKeyData

pub fn ig_get_key_data_context_ptr(ctx &C.ImGuiContext, key ImGuiKey) &C.ImGuiKeyData {
	return C.igGetKeyData_ContextPtr(ctx, key)
}

fn C.igGetKeyData_Key(key ImGuiKey) &C.ImGuiKeyData

pub fn ig_get_key_data_key(key ImGuiKey) &C.ImGuiKeyData {
	return C.igGetKeyData_Key(key)
}

fn C.igGetKeyChordName(key_chord ImGuiKeyChord) &i8

pub fn ig_get_key_chord_name(key_chord ImGuiKeyChord) &i8 {
	return C.igGetKeyChordName(key_chord)
}

fn C.igMouseButtonToKey(button ImGuiMouseButton) ImGuiKey

pub fn ig_mouse_button_to_key(button ImGuiMouseButton) ImGuiKey {
	return C.igMouseButtonToKey(button)
}

fn C.igIsMouseDragPastThreshold(button ImGuiMouseButton, lock_threshold f32) bool

pub fn ig_is_mouse_drag_past_threshold(button ImGuiMouseButton, lock_threshold f32) bool {
	return C.igIsMouseDragPastThreshold(button, lock_threshold)
}

fn C.igGetKeyMagnitude2d(p_out &C.ImVec2, key_left ImGuiKey, key_right ImGuiKey, key_up ImGuiKey, key_down ImGuiKey)

pub fn ig_get_key_magnitude2d(p_out &C.ImVec2, key_left ImGuiKey, key_right ImGuiKey, key_up ImGuiKey, key_down ImGuiKey) {
	C.igGetKeyMagnitude2d(p_out, key_left, key_right, key_up, key_down)
}

fn C.igGetNavTweakPressedAmount(axis ImGuiAxis) f32

pub fn ig_get_nav_tweak_pressed_amount(axis ImGuiAxis) f32 {
	return C.igGetNavTweakPressedAmount(axis)
}

fn C.igCalcTypematicRepeatAmount(t0 f32, t1 f32, repeat_delay f32, repeat_rate f32) int

pub fn ig_calc_typematic_repeat_amount(t0 f32, t1 f32, repeat_delay f32, repeat_rate f32) int {
	return C.igCalcTypematicRepeatAmount(t0, t1, repeat_delay, repeat_rate)
}

fn C.igGetTypematicRepeatRate(flags ImGuiInputFlags, repeat_delay &f32, repeat_rate &f32)

pub fn ig_get_typematic_repeat_rate(flags ImGuiInputFlags, repeat_delay &f32, repeat_rate &f32) {
	C.igGetTypematicRepeatRate(flags, repeat_delay, repeat_rate)
}

fn C.igTeleportMousePos(pos C.ImVec2)

pub fn ig_teleport_mouse_pos(pos C.ImVec2) {
	C.igTeleportMousePos(pos)
}

fn C.igSetActiveIdUsingAllKeyboardKeys()

pub fn ig_set_active_id_using_all_keyboard_keys() {
	C.igSetActiveIdUsingAllKeyboardKeys()
}

fn C.igIsActiveIdUsingNavDir(dir ImGuiDir) bool

pub fn ig_is_active_id_using_nav_dir(dir ImGuiDir) bool {
	return C.igIsActiveIdUsingNavDir(dir)
}

fn C.igGetKeyOwner(key ImGuiKey) ImGuiID

pub fn ig_get_key_owner(key ImGuiKey) ImGuiID {
	return C.igGetKeyOwner(key)
}

fn C.igSetKeyOwner(key ImGuiKey, owner_id ImGuiID, flags ImGuiInputFlags)

pub fn ig_set_key_owner(key ImGuiKey, owner_id ImGuiID, flags ImGuiInputFlags) {
	C.igSetKeyOwner(key, owner_id, flags)
}

fn C.igSetKeyOwnersForKeyChord(key ImGuiKeyChord, owner_id ImGuiID, flags ImGuiInputFlags)

pub fn ig_set_key_owners_for_key_chord(key ImGuiKeyChord, owner_id ImGuiID, flags ImGuiInputFlags) {
	C.igSetKeyOwnersForKeyChord(key, owner_id, flags)
}

fn C.igSetItemKeyOwner_InputFlags(key ImGuiKey, flags ImGuiInputFlags)

pub fn ig_set_item_key_owner_input_flags(key ImGuiKey, flags ImGuiInputFlags) {
	C.igSetItemKeyOwner_InputFlags(key, flags)
}

fn C.igTestKeyOwner(key ImGuiKey, owner_id ImGuiID) bool

pub fn ig_test_key_owner(key ImGuiKey, owner_id ImGuiID) bool {
	return C.igTestKeyOwner(key, owner_id)
}

fn C.igGetKeyOwnerData(ctx &C.ImGuiContext, key ImGuiKey) &C.ImGuiKeyOwnerData

pub fn ig_get_key_owner_data(ctx &C.ImGuiContext, key ImGuiKey) &C.ImGuiKeyOwnerData {
	return C.igGetKeyOwnerData(ctx, key)
}

fn C.igIsKeyDown_ID(key ImGuiKey, owner_id ImGuiID) bool

pub fn ig_is_key_down_id(key ImGuiKey, owner_id ImGuiID) bool {
	return C.igIsKeyDown_ID(key, owner_id)
}

fn C.igIsKeyPressed_InputFlags(key ImGuiKey, flags ImGuiInputFlags, owner_id ImGuiID) bool

pub fn ig_is_key_pressed_input_flags(key ImGuiKey, flags ImGuiInputFlags, owner_id ImGuiID) bool {
	return C.igIsKeyPressed_InputFlags(key, flags, owner_id)
}

fn C.igIsKeyReleased_ID(key ImGuiKey, owner_id ImGuiID) bool

pub fn ig_is_key_released_id(key ImGuiKey, owner_id ImGuiID) bool {
	return C.igIsKeyReleased_ID(key, owner_id)
}

fn C.igIsKeyChordPressed_InputFlags(key_chord ImGuiKeyChord, flags ImGuiInputFlags, owner_id ImGuiID) bool

pub fn ig_is_key_chord_pressed_input_flags(key_chord ImGuiKeyChord, flags ImGuiInputFlags, owner_id ImGuiID) bool {
	return C.igIsKeyChordPressed_InputFlags(key_chord, flags, owner_id)
}

fn C.igIsMouseDown_ID(button ImGuiMouseButton, owner_id ImGuiID) bool

pub fn ig_is_mouse_down_id(button ImGuiMouseButton, owner_id ImGuiID) bool {
	return C.igIsMouseDown_ID(button, owner_id)
}

fn C.igIsMouseClicked_InputFlags(button ImGuiMouseButton, flags ImGuiInputFlags, owner_id ImGuiID) bool

pub fn ig_is_mouse_clicked_input_flags(button ImGuiMouseButton, flags ImGuiInputFlags, owner_id ImGuiID) bool {
	return C.igIsMouseClicked_InputFlags(button, flags, owner_id)
}

fn C.igIsMouseReleased_ID(button ImGuiMouseButton, owner_id ImGuiID) bool

pub fn ig_is_mouse_released_id(button ImGuiMouseButton, owner_id ImGuiID) bool {
	return C.igIsMouseReleased_ID(button, owner_id)
}

fn C.igIsMouseDoubleClicked_ID(button ImGuiMouseButton, owner_id ImGuiID) bool

pub fn ig_is_mouse_double_clicked_id(button ImGuiMouseButton, owner_id ImGuiID) bool {
	return C.igIsMouseDoubleClicked_ID(button, owner_id)
}

fn C.igShortcut_ID(key_chord ImGuiKeyChord, flags ImGuiInputFlags, owner_id ImGuiID) bool

pub fn ig_shortcut_id(key_chord ImGuiKeyChord, flags ImGuiInputFlags, owner_id ImGuiID) bool {
	return C.igShortcut_ID(key_chord, flags, owner_id)
}

fn C.igSetShortcutRouting(key_chord ImGuiKeyChord, flags ImGuiInputFlags, owner_id ImGuiID) bool

pub fn ig_set_shortcut_routing(key_chord ImGuiKeyChord, flags ImGuiInputFlags, owner_id ImGuiID) bool {
	return C.igSetShortcutRouting(key_chord, flags, owner_id)
}

fn C.igTestShortcutRouting(key_chord ImGuiKeyChord, owner_id ImGuiID) bool

pub fn ig_test_shortcut_routing(key_chord ImGuiKeyChord, owner_id ImGuiID) bool {
	return C.igTestShortcutRouting(key_chord, owner_id)
}

fn C.igGetShortcutRoutingData(key_chord ImGuiKeyChord) &C.ImGuiKeyRoutingData

pub fn ig_get_shortcut_routing_data(key_chord ImGuiKeyChord) &C.ImGuiKeyRoutingData {
	return C.igGetShortcutRoutingData(key_chord)
}

fn C.igDockContextInitialize(ctx &C.ImGuiContext)

pub fn ig_dock_context_initialize(ctx &C.ImGuiContext) {
	C.igDockContextInitialize(ctx)
}

fn C.igDockContextShutdown(ctx &C.ImGuiContext)

pub fn ig_dock_context_shutdown(ctx &C.ImGuiContext) {
	C.igDockContextShutdown(ctx)
}

fn C.igDockContextClearNodes(ctx &C.ImGuiContext, root_id ImGuiID, clear_settings_refs bool)

pub fn ig_dock_context_clear_nodes(ctx &C.ImGuiContext, root_id ImGuiID, clear_settings_refs bool) {
	C.igDockContextClearNodes(ctx, root_id, clear_settings_refs)
}

fn C.igDockContextRebuildNodes(ctx &C.ImGuiContext)

pub fn ig_dock_context_rebuild_nodes(ctx &C.ImGuiContext) {
	C.igDockContextRebuildNodes(ctx)
}

fn C.igDockContextNewFrameUpdateUndocking(ctx &C.ImGuiContext)

pub fn ig_dock_context_new_frame_update_undocking(ctx &C.ImGuiContext) {
	C.igDockContextNewFrameUpdateUndocking(ctx)
}

fn C.igDockContextNewFrameUpdateDocking(ctx &C.ImGuiContext)

pub fn ig_dock_context_new_frame_update_docking(ctx &C.ImGuiContext) {
	C.igDockContextNewFrameUpdateDocking(ctx)
}

fn C.igDockContextEndFrame(ctx &C.ImGuiContext)

pub fn ig_dock_context_end_frame(ctx &C.ImGuiContext) {
	C.igDockContextEndFrame(ctx)
}

fn C.igDockContextGenNodeID(ctx &C.ImGuiContext) ImGuiID

pub fn ig_dock_context_gen_node_id(ctx &C.ImGuiContext) ImGuiID {
	return C.igDockContextGenNodeID(ctx)
}

fn C.igDockContextQueueDock(ctx &C.ImGuiContext, target &C.ImGuiWindow, target_node &C.ImGuiDockNode, payload &C.ImGuiWindow, split_dir ImGuiDir, split_ratio f32, split_outer bool)

pub fn ig_dock_context_queue_dock(ctx &C.ImGuiContext, target &C.ImGuiWindow, target_node &C.ImGuiDockNode, payload &C.ImGuiWindow, split_dir ImGuiDir, split_ratio f32, split_outer bool) {
	C.igDockContextQueueDock(ctx, target, target_node, payload, split_dir, split_ratio,
		split_outer)
}

fn C.igDockContextQueueUndockWindow(ctx &C.ImGuiContext, window &C.ImGuiWindow)

pub fn ig_dock_context_queue_undock_window(ctx &C.ImGuiContext, window &C.ImGuiWindow) {
	C.igDockContextQueueUndockWindow(ctx, window)
}

fn C.igDockContextQueueUndockNode(ctx &C.ImGuiContext, node &C.ImGuiDockNode)

pub fn ig_dock_context_queue_undock_node(ctx &C.ImGuiContext, node &C.ImGuiDockNode) {
	C.igDockContextQueueUndockNode(ctx, node)
}

fn C.igDockContextProcessUndockWindow(ctx &C.ImGuiContext, window &C.ImGuiWindow, clear_persistent_docking_ref bool)

pub fn ig_dock_context_process_undock_window(ctx &C.ImGuiContext, window &C.ImGuiWindow, clear_persistent_docking_ref bool) {
	C.igDockContextProcessUndockWindow(ctx, window, clear_persistent_docking_ref)
}

fn C.igDockContextProcessUndockNode(ctx &C.ImGuiContext, node &C.ImGuiDockNode)

pub fn ig_dock_context_process_undock_node(ctx &C.ImGuiContext, node &C.ImGuiDockNode) {
	C.igDockContextProcessUndockNode(ctx, node)
}

fn C.igDockContextCalcDropPosForDocking(target &C.ImGuiWindow, target_node &C.ImGuiDockNode, payload_window &C.ImGuiWindow, payload_node &C.ImGuiDockNode, split_dir ImGuiDir, split_outer bool, out_pos &C.ImVec2) bool

pub fn ig_dock_context_calc_drop_pos_for_docking(target &C.ImGuiWindow, target_node &C.ImGuiDockNode, payload_window &C.ImGuiWindow, payload_node &C.ImGuiDockNode, split_dir ImGuiDir, split_outer bool, out_pos &C.ImVec2) bool {
	return C.igDockContextCalcDropPosForDocking(target, target_node, payload_window, payload_node,
		split_dir, split_outer, out_pos)
}

fn C.igDockContextFindNodeByID(ctx &C.ImGuiContext, id ImGuiID) &C.ImGuiDockNode

pub fn ig_dock_context_find_node_by_id(ctx &C.ImGuiContext, id ImGuiID) &C.ImGuiDockNode {
	return C.igDockContextFindNodeByID(ctx, id)
}

fn C.igDockNodeWindowMenuHandler_Default(ctx &C.ImGuiContext, node &C.ImGuiDockNode, tab_bar &C.ImGuiTabBar)

pub fn ig_dock_node_window_menu_handler_default(ctx &C.ImGuiContext, node &C.ImGuiDockNode, tab_bar &C.ImGuiTabBar) {
	C.igDockNodeWindowMenuHandler_Default(ctx, node, tab_bar)
}

fn C.igDockNodeBeginAmendTabBar(node &C.ImGuiDockNode) bool

pub fn ig_dock_node_begin_amend_tab_bar(node &C.ImGuiDockNode) bool {
	return C.igDockNodeBeginAmendTabBar(node)
}

fn C.igDockNodeEndAmendTabBar()

pub fn ig_dock_node_end_amend_tab_bar() {
	C.igDockNodeEndAmendTabBar()
}

fn C.igDockNodeGetRootNode(node &C.ImGuiDockNode) &C.ImGuiDockNode

pub fn ig_dock_node_get_root_node(node &C.ImGuiDockNode) &C.ImGuiDockNode {
	return C.igDockNodeGetRootNode(node)
}

fn C.igDockNodeIsInHierarchyOf(node &C.ImGuiDockNode, parent &C.ImGuiDockNode) bool

pub fn ig_dock_node_is_in_hierarchy_of(node &C.ImGuiDockNode, parent &C.ImGuiDockNode) bool {
	return C.igDockNodeIsInHierarchyOf(node, parent)
}

fn C.igDockNodeGetDepth(node &C.ImGuiDockNode) int

pub fn ig_dock_node_get_depth(node &C.ImGuiDockNode) int {
	return C.igDockNodeGetDepth(node)
}

fn C.igDockNodeGetWindowMenuButtonId(node &C.ImGuiDockNode) ImGuiID

pub fn ig_dock_node_get_window_menu_button_id(node &C.ImGuiDockNode) ImGuiID {
	return C.igDockNodeGetWindowMenuButtonId(node)
}

fn C.igGetWindowDockNode() &C.ImGuiDockNode

pub fn ig_get_window_dock_node() &C.ImGuiDockNode {
	return C.igGetWindowDockNode()
}

fn C.igGetWindowAlwaysWantOwnTabBar(window &C.ImGuiWindow) bool

pub fn ig_get_window_always_want_own_tab_bar(window &C.ImGuiWindow) bool {
	return C.igGetWindowAlwaysWantOwnTabBar(window)
}

fn C.igBeginDocked(window &C.ImGuiWindow, p_open &bool)

pub fn ig_begin_docked(window &C.ImGuiWindow, p_open &bool) {
	C.igBeginDocked(window, p_open)
}

fn C.igBeginDockableDragDropSource(window &C.ImGuiWindow)

pub fn ig_begin_dockable_drag_drop_source(window &C.ImGuiWindow) {
	C.igBeginDockableDragDropSource(window)
}

fn C.igBeginDockableDragDropTarget(window &C.ImGuiWindow)

pub fn ig_begin_dockable_drag_drop_target(window &C.ImGuiWindow) {
	C.igBeginDockableDragDropTarget(window)
}

fn C.igSetWindowDock(window &C.ImGuiWindow, dock_id ImGuiID, cond ImGuiCond)

pub fn ig_set_window_dock(window &C.ImGuiWindow, dock_id ImGuiID, cond ImGuiCond) {
	C.igSetWindowDock(window, dock_id, cond)
}

fn C.igDockBuilderDockWindow(window_name &i8, node_id ImGuiID)

pub fn ig_dock_builder_dock_window(window_name &i8, node_id ImGuiID) {
	C.igDockBuilderDockWindow(window_name, node_id)
}

fn C.igDockBuilderGetNode(node_id ImGuiID) &C.ImGuiDockNode

pub fn ig_dock_builder_get_node(node_id ImGuiID) &C.ImGuiDockNode {
	return C.igDockBuilderGetNode(node_id)
}

fn C.igDockBuilderGetCentralNode(node_id ImGuiID) &C.ImGuiDockNode

pub fn ig_dock_builder_get_central_node(node_id ImGuiID) &C.ImGuiDockNode {
	return C.igDockBuilderGetCentralNode(node_id)
}

fn C.igDockBuilderAddNode(node_id ImGuiID, flags ImGuiDockNodeFlags) ImGuiID

pub fn ig_dock_builder_add_node(node_id ImGuiID, flags ImGuiDockNodeFlags) ImGuiID {
	return C.igDockBuilderAddNode(node_id, flags)
}

fn C.igDockBuilderRemoveNode(node_id ImGuiID)

pub fn ig_dock_builder_remove_node(node_id ImGuiID) {
	C.igDockBuilderRemoveNode(node_id)
}

fn C.igDockBuilderRemoveNodeDockedWindows(node_id ImGuiID, clear_settings_refs bool)

pub fn ig_dock_builder_remove_node_docked_windows(node_id ImGuiID, clear_settings_refs bool) {
	C.igDockBuilderRemoveNodeDockedWindows(node_id, clear_settings_refs)
}

fn C.igDockBuilderRemoveNodeChildNodes(node_id ImGuiID)

pub fn ig_dock_builder_remove_node_child_nodes(node_id ImGuiID) {
	C.igDockBuilderRemoveNodeChildNodes(node_id)
}

fn C.igDockBuilderSetNodePos(node_id ImGuiID, pos C.ImVec2)

pub fn ig_dock_builder_set_node_pos(node_id ImGuiID, pos C.ImVec2) {
	C.igDockBuilderSetNodePos(node_id, pos)
}

fn C.igDockBuilderSetNodeSize(node_id ImGuiID, size C.ImVec2)

pub fn ig_dock_builder_set_node_size(node_id ImGuiID, size C.ImVec2) {
	C.igDockBuilderSetNodeSize(node_id, size)
}

fn C.igDockBuilderSplitNode(node_id ImGuiID, split_dir ImGuiDir, size_ratio_for_node_at_dir f32, out_id_at_dir &ImGuiID, out_id_at_opposite_dir &ImGuiID) ImGuiID

pub fn ig_dock_builder_split_node(node_id ImGuiID, split_dir ImGuiDir, size_ratio_for_node_at_dir f32, out_id_at_dir &ImGuiID, out_id_at_opposite_dir &ImGuiID) ImGuiID {
	return C.igDockBuilderSplitNode(node_id, split_dir, size_ratio_for_node_at_dir, out_id_at_dir,
		out_id_at_opposite_dir)
}

fn C.igDockBuilderCopyDockSpace(src_dockspace_id ImGuiID, dst_dockspace_id ImGuiID, in_window_remap_pairs &C.ImVector_const_charPtr)

pub fn ig_dock_builder_copy_dock_space(src_dockspace_id ImGuiID, dst_dockspace_id ImGuiID, in_window_remap_pairs &C.ImVector_const_charPtr) {
	C.igDockBuilderCopyDockSpace(src_dockspace_id, dst_dockspace_id, in_window_remap_pairs)
}

fn C.igDockBuilderCopyNode(src_node_id ImGuiID, dst_node_id ImGuiID, out_node_remap_pairs &C.ImVector_ImGuiID)

pub fn ig_dock_builder_copy_node(src_node_id ImGuiID, dst_node_id ImGuiID, out_node_remap_pairs &C.ImVector_ImGuiID) {
	C.igDockBuilderCopyNode(src_node_id, dst_node_id, out_node_remap_pairs)
}

fn C.igDockBuilderCopyWindowSettings(src_name &i8, dst_name &i8)

pub fn ig_dock_builder_copy_window_settings(src_name &i8, dst_name &i8) {
	C.igDockBuilderCopyWindowSettings(src_name, dst_name)
}

fn C.igDockBuilderFinish(node_id ImGuiID)

pub fn ig_dock_builder_finish(node_id ImGuiID) {
	C.igDockBuilderFinish(node_id)
}

fn C.igPushFocusScope(id ImGuiID)

pub fn ig_push_focus_scope(id ImGuiID) {
	C.igPushFocusScope(id)
}

fn C.igPopFocusScope()

pub fn ig_pop_focus_scope() {
	C.igPopFocusScope()
}

fn C.igGetCurrentFocusScope() ImGuiID

pub fn ig_get_current_focus_scope() ImGuiID {
	return C.igGetCurrentFocusScope()
}

fn C.igIsDragDropActive() bool

pub fn ig_is_drag_drop_active() bool {
	return C.igIsDragDropActive()
}

fn C.igBeginDragDropTargetCustom(bb C.ImRect, id ImGuiID) bool

pub fn ig_begin_drag_drop_target_custom(bb C.ImRect, id ImGuiID) bool {
	return C.igBeginDragDropTargetCustom(bb, id)
}

fn C.igClearDragDrop()

pub fn ig_clear_drag_drop() {
	C.igClearDragDrop()
}

fn C.igIsDragDropPayloadBeingAccepted() bool

pub fn ig_is_drag_drop_payload_being_accepted() bool {
	return C.igIsDragDropPayloadBeingAccepted()
}

fn C.igRenderDragDropTargetRect(bb C.ImRect, item_clip_rect C.ImRect)

pub fn ig_render_drag_drop_target_rect(bb C.ImRect, item_clip_rect C.ImRect) {
	C.igRenderDragDropTargetRect(bb, item_clip_rect)
}

fn C.igGetTypingSelectRequest(flags ImGuiTypingSelectFlags) &C.ImGuiTypingSelectRequest

pub fn ig_get_typing_select_request(flags ImGuiTypingSelectFlags) &C.ImGuiTypingSelectRequest {
	return C.igGetTypingSelectRequest(flags)
}

fn C.igTypingSelectFindMatch(req &C.ImGuiTypingSelectRequest, items_count int, get_item_name_func fn (voidptr, int) &i8, user_data voidptr, nav_item_idx int) int

pub fn ig_typing_select_find_match(req &C.ImGuiTypingSelectRequest, items_count int, get_item_name_func fn (voidptr, int) &i8, user_data voidptr, nav_item_idx int) int {
	return C.igTypingSelectFindMatch(req, items_count, get_item_name_func, user_data,
		nav_item_idx)
}

fn C.igTypingSelectFindNextSingleCharMatch(req &C.ImGuiTypingSelectRequest, items_count int, get_item_name_func fn (voidptr, int) &i8, user_data voidptr, nav_item_idx int) int

pub fn ig_typing_select_find_next_single_char_match(req &C.ImGuiTypingSelectRequest, items_count int, get_item_name_func fn (voidptr, int) &i8, user_data voidptr, nav_item_idx int) int {
	return C.igTypingSelectFindNextSingleCharMatch(req, items_count, get_item_name_func,
		user_data, nav_item_idx)
}

fn C.igTypingSelectFindBestLeadingMatch(req &C.ImGuiTypingSelectRequest, items_count int, get_item_name_func fn (voidptr, int) &i8, user_data voidptr) int

pub fn ig_typing_select_find_best_leading_match(req &C.ImGuiTypingSelectRequest, items_count int, get_item_name_func fn (voidptr, int) &i8, user_data voidptr) int {
	return C.igTypingSelectFindBestLeadingMatch(req, items_count, get_item_name_func,
		user_data)
}

fn C.igBeginBoxSelect(scope_rect C.ImRect, window &C.ImGuiWindow, box_select_id ImGuiID, ms_flags ImGuiMultiSelectFlags) bool

pub fn ig_begin_box_select(scope_rect C.ImRect, window &C.ImGuiWindow, box_select_id ImGuiID, ms_flags ImGuiMultiSelectFlags) bool {
	return C.igBeginBoxSelect(scope_rect, window, box_select_id, ms_flags)
}

fn C.igEndBoxSelect(scope_rect C.ImRect, ms_flags ImGuiMultiSelectFlags)

pub fn ig_end_box_select(scope_rect C.ImRect, ms_flags ImGuiMultiSelectFlags) {
	C.igEndBoxSelect(scope_rect, ms_flags)
}

fn C.igMultiSelectItemHeader(id ImGuiID, p_selected &bool, p_button_flags &ImGuiButtonFlags)

pub fn ig_multi_select_item_header(id ImGuiID, p_selected &bool, p_button_flags &ImGuiButtonFlags) {
	C.igMultiSelectItemHeader(id, p_selected, p_button_flags)
}

fn C.igMultiSelectItemFooter(id ImGuiID, p_selected &bool, p_pressed &bool)

pub fn ig_multi_select_item_footer(id ImGuiID, p_selected &bool, p_pressed &bool) {
	C.igMultiSelectItemFooter(id, p_selected, p_pressed)
}

fn C.igMultiSelectAddSetAll(ms &C.ImGuiMultiSelectTempData, selected bool)

pub fn ig_multi_select_add_set_all(ms &C.ImGuiMultiSelectTempData, selected bool) {
	C.igMultiSelectAddSetAll(ms, selected)
}

fn C.igMultiSelectAddSetRange(ms &C.ImGuiMultiSelectTempData, selected bool, range_dir int, first_item ImGuiSelectionUserData, last_item ImGuiSelectionUserData)

pub fn ig_multi_select_add_set_range(ms &C.ImGuiMultiSelectTempData, selected bool, range_dir int, first_item ImGuiSelectionUserData, last_item ImGuiSelectionUserData) {
	C.igMultiSelectAddSetRange(ms, selected, range_dir, first_item, last_item)
}

fn C.igGetBoxSelectState(id ImGuiID) &C.ImGuiBoxSelectState

pub fn ig_get_box_select_state(id ImGuiID) &C.ImGuiBoxSelectState {
	return C.igGetBoxSelectState(id)
}

fn C.igGetMultiSelectState(id ImGuiID) &C.ImGuiMultiSelectState

pub fn ig_get_multi_select_state(id ImGuiID) &C.ImGuiMultiSelectState {
	return C.igGetMultiSelectState(id)
}

fn C.igSetWindowClipRectBeforeSetChannel(window &C.ImGuiWindow, clip_rect C.ImRect)

pub fn ig_set_window_clip_rect_before_set_channel(window &C.ImGuiWindow, clip_rect C.ImRect) {
	C.igSetWindowClipRectBeforeSetChannel(window, clip_rect)
}

fn C.igBeginColumns(str_id &i8, count int, flags ImGuiOldColumnFlags)

pub fn ig_begin_columns(str_id &i8, count int, flags ImGuiOldColumnFlags) {
	C.igBeginColumns(str_id, count, flags)
}

fn C.igEndColumns()

pub fn ig_end_columns() {
	C.igEndColumns()
}

fn C.igPushColumnClipRect(column_index int)

pub fn ig_push_column_clip_rect(column_index int) {
	C.igPushColumnClipRect(column_index)
}

fn C.igPushColumnsBackground()

pub fn ig_push_columns_background() {
	C.igPushColumnsBackground()
}

fn C.igPopColumnsBackground()

pub fn ig_pop_columns_background() {
	C.igPopColumnsBackground()
}

fn C.igGetColumnsID(str_id &i8, count int) ImGuiID

pub fn ig_get_columns_id(str_id &i8, count int) ImGuiID {
	return C.igGetColumnsID(str_id, count)
}

fn C.igFindOrCreateColumns(window &C.ImGuiWindow, id ImGuiID) &C.ImGuiOldColumns

pub fn ig_find_or_create_columns(window &C.ImGuiWindow, id ImGuiID) &C.ImGuiOldColumns {
	return C.igFindOrCreateColumns(window, id)
}

fn C.igGetColumnOffsetFromNorm(columns &C.ImGuiOldColumns, offset_norm f32) f32

pub fn ig_get_column_offset_from_norm(columns &C.ImGuiOldColumns, offset_norm f32) f32 {
	return C.igGetColumnOffsetFromNorm(columns, offset_norm)
}

fn C.igGetColumnNormFromOffset(columns &C.ImGuiOldColumns, offset f32) f32

pub fn ig_get_column_norm_from_offset(columns &C.ImGuiOldColumns, offset f32) f32 {
	return C.igGetColumnNormFromOffset(columns, offset)
}

fn C.igTableOpenContextMenu(column_n int)

pub fn ig_table_open_context_menu(column_n int) {
	C.igTableOpenContextMenu(column_n)
}

fn C.igTableSetColumnWidth(column_n int, width f32)

pub fn ig_table_set_column_width(column_n int, width f32) {
	C.igTableSetColumnWidth(column_n, width)
}

fn C.igTableSetColumnSortDirection(column_n int, sort_direction ImGuiSortDirection, append_to_sort_specs bool)

pub fn ig_table_set_column_sort_direction(column_n int, sort_direction ImGuiSortDirection, append_to_sort_specs bool) {
	C.igTableSetColumnSortDirection(column_n, sort_direction, append_to_sort_specs)
}

fn C.igTableGetHoveredRow() int

pub fn ig_table_get_hovered_row() int {
	return C.igTableGetHoveredRow()
}

fn C.igTableGetHeaderRowHeight() f32

pub fn ig_table_get_header_row_height() f32 {
	return C.igTableGetHeaderRowHeight()
}

fn C.igTableGetHeaderAngledMaxLabelWidth() f32

pub fn ig_table_get_header_angled_max_label_width() f32 {
	return C.igTableGetHeaderAngledMaxLabelWidth()
}

fn C.igTablePushBackgroundChannel()

pub fn ig_table_push_background_channel() {
	C.igTablePushBackgroundChannel()
}

fn C.igTablePopBackgroundChannel()

pub fn ig_table_pop_background_channel() {
	C.igTablePopBackgroundChannel()
}

fn C.igTableAngledHeadersRowEx(row_id ImGuiID, angle f32, max_label_width f32, data &C.ImGuiTableHeaderData, data_count int)

pub fn ig_table_angled_headers_row_ex(row_id ImGuiID, angle f32, max_label_width f32, data &C.ImGuiTableHeaderData, data_count int) {
	C.igTableAngledHeadersRowEx(row_id, angle, max_label_width, data, data_count)
}

fn C.igGetCurrentTable() &C.ImGuiTable

pub fn ig_get_current_table() &C.ImGuiTable {
	return C.igGetCurrentTable()
}

fn C.igTableFindByID(id ImGuiID) &C.ImGuiTable

pub fn ig_table_find_by_id(id ImGuiID) &C.ImGuiTable {
	return C.igTableFindByID(id)
}

fn C.igBeginTableEx(name &i8, id ImGuiID, columns_count int, flags ImGuiTableFlags, outer_size C.ImVec2, inner_width f32) bool

pub fn ig_begin_table_ex(name &i8, id ImGuiID, columns_count int, flags ImGuiTableFlags, outer_size C.ImVec2, inner_width f32) bool {
	return C.igBeginTableEx(name, id, columns_count, flags, outer_size, inner_width)
}

fn C.igTableBeginInitMemory(table &C.ImGuiTable, columns_count int)

pub fn ig_table_begin_init_memory(table &C.ImGuiTable, columns_count int) {
	C.igTableBeginInitMemory(table, columns_count)
}

fn C.igTableBeginApplyRequests(table &C.ImGuiTable)

pub fn ig_table_begin_apply_requests(table &C.ImGuiTable) {
	C.igTableBeginApplyRequests(table)
}

fn C.igTableSetupDrawChannels(table &C.ImGuiTable)

pub fn ig_table_setup_draw_channels(table &C.ImGuiTable) {
	C.igTableSetupDrawChannels(table)
}

fn C.igTableUpdateLayout(table &C.ImGuiTable)

pub fn ig_table_update_layout(table &C.ImGuiTable) {
	C.igTableUpdateLayout(table)
}

fn C.igTableUpdateBorders(table &C.ImGuiTable)

pub fn ig_table_update_borders(table &C.ImGuiTable) {
	C.igTableUpdateBorders(table)
}

fn C.igTableUpdateColumnsWeightFromWidth(table &C.ImGuiTable)

pub fn ig_table_update_columns_weight_from_width(table &C.ImGuiTable) {
	C.igTableUpdateColumnsWeightFromWidth(table)
}

fn C.igTableDrawBorders(table &C.ImGuiTable)

pub fn ig_table_draw_borders(table &C.ImGuiTable) {
	C.igTableDrawBorders(table)
}

fn C.igTableDrawDefaultContextMenu(table &C.ImGuiTable, flags_for_section_to_display ImGuiTableFlags)

pub fn ig_table_draw_default_context_menu(table &C.ImGuiTable, flags_for_section_to_display ImGuiTableFlags) {
	C.igTableDrawDefaultContextMenu(table, flags_for_section_to_display)
}

fn C.igTableBeginContextMenuPopup(table &C.ImGuiTable) bool

pub fn ig_table_begin_context_menu_popup(table &C.ImGuiTable) bool {
	return C.igTableBeginContextMenuPopup(table)
}

fn C.igTableMergeDrawChannels(table &C.ImGuiTable)

pub fn ig_table_merge_draw_channels(table &C.ImGuiTable) {
	C.igTableMergeDrawChannels(table)
}

fn C.igTableGetInstanceData(table &C.ImGuiTable, instance_no int) &C.ImGuiTableInstanceData

pub fn ig_table_get_instance_data(table &C.ImGuiTable, instance_no int) &C.ImGuiTableInstanceData {
	return C.igTableGetInstanceData(table, instance_no)
}

fn C.igTableGetInstanceID(table &C.ImGuiTable, instance_no int) ImGuiID

pub fn ig_table_get_instance_id(table &C.ImGuiTable, instance_no int) ImGuiID {
	return C.igTableGetInstanceID(table, instance_no)
}

fn C.igTableSortSpecsSanitize(table &C.ImGuiTable)

pub fn ig_table_sort_specs_sanitize(table &C.ImGuiTable) {
	C.igTableSortSpecsSanitize(table)
}

fn C.igTableSortSpecsBuild(table &C.ImGuiTable)

pub fn ig_table_sort_specs_build(table &C.ImGuiTable) {
	C.igTableSortSpecsBuild(table)
}

fn C.igTableGetColumnNextSortDirection(column &C.ImGuiTableColumn) ImGuiSortDirection

pub fn ig_table_get_column_next_sort_direction(column &C.ImGuiTableColumn) ImGuiSortDirection {
	return C.igTableGetColumnNextSortDirection(column)
}

fn C.igTableFixColumnSortDirection(table &C.ImGuiTable, column &C.ImGuiTableColumn)

pub fn ig_table_fix_column_sort_direction(table &C.ImGuiTable, column &C.ImGuiTableColumn) {
	C.igTableFixColumnSortDirection(table, column)
}

fn C.igTableGetColumnWidthAuto(table &C.ImGuiTable, column &C.ImGuiTableColumn) f32

pub fn ig_table_get_column_width_auto(table &C.ImGuiTable, column &C.ImGuiTableColumn) f32 {
	return C.igTableGetColumnWidthAuto(table, column)
}

fn C.igTableBeginRow(table &C.ImGuiTable)

pub fn ig_table_begin_row(table &C.ImGuiTable) {
	C.igTableBeginRow(table)
}

fn C.igTableEndRow(table &C.ImGuiTable)

pub fn ig_table_end_row(table &C.ImGuiTable) {
	C.igTableEndRow(table)
}

fn C.igTableBeginCell(table &C.ImGuiTable, column_n int)

pub fn ig_table_begin_cell(table &C.ImGuiTable, column_n int) {
	C.igTableBeginCell(table, column_n)
}

fn C.igTableEndCell(table &C.ImGuiTable)

pub fn ig_table_end_cell(table &C.ImGuiTable) {
	C.igTableEndCell(table)
}

fn C.igTableGetCellBgRect(p_out &C.ImRect, table &C.ImGuiTable, column_n int)

pub fn ig_table_get_cell_bg_rect(p_out &C.ImRect, table &C.ImGuiTable, column_n int) {
	C.igTableGetCellBgRect(p_out, table, column_n)
}

fn C.igTableGetColumnName_TablePtr(table &C.ImGuiTable, column_n int) &i8

pub fn ig_table_get_column_name_table_ptr(table &C.ImGuiTable, column_n int) &i8 {
	return C.igTableGetColumnName_TablePtr(table, column_n)
}

fn C.igTableGetColumnResizeID(table &C.ImGuiTable, column_n int, instance_no int) ImGuiID

pub fn ig_table_get_column_resize_id(table &C.ImGuiTable, column_n int, instance_no int) ImGuiID {
	return C.igTableGetColumnResizeID(table, column_n, instance_no)
}

fn C.igTableCalcMaxColumnWidth(table &C.ImGuiTable, column_n int) f32

pub fn ig_table_calc_max_column_width(table &C.ImGuiTable, column_n int) f32 {
	return C.igTableCalcMaxColumnWidth(table, column_n)
}

fn C.igTableSetColumnWidthAutoSingle(table &C.ImGuiTable, column_n int)

pub fn ig_table_set_column_width_auto_single(table &C.ImGuiTable, column_n int) {
	C.igTableSetColumnWidthAutoSingle(table, column_n)
}

fn C.igTableSetColumnWidthAutoAll(table &C.ImGuiTable)

pub fn ig_table_set_column_width_auto_all(table &C.ImGuiTable) {
	C.igTableSetColumnWidthAutoAll(table)
}

fn C.igTableRemove(table &C.ImGuiTable)

pub fn ig_table_remove(table &C.ImGuiTable) {
	C.igTableRemove(table)
}

fn C.igTableGcCompactTransientBuffers_TablePtr(table &C.ImGuiTable)

pub fn ig_table_gc_compact_transient_buffers_table_ptr(table &C.ImGuiTable) {
	C.igTableGcCompactTransientBuffers_TablePtr(table)
}

fn C.igTableGcCompactTransientBuffers_TableTempDataPtr(table &C.ImGuiTableTempData)

pub fn ig_table_gc_compact_transient_buffers_table_temp_data_ptr(table &C.ImGuiTableTempData) {
	C.igTableGcCompactTransientBuffers_TableTempDataPtr(table)
}

fn C.igTableGcCompactSettings()

pub fn ig_table_gc_compact_settings() {
	C.igTableGcCompactSettings()
}

fn C.igTableLoadSettings(table &C.ImGuiTable)

pub fn ig_table_load_settings(table &C.ImGuiTable) {
	C.igTableLoadSettings(table)
}

fn C.igTableSaveSettings(table &C.ImGuiTable)

pub fn ig_table_save_settings(table &C.ImGuiTable) {
	C.igTableSaveSettings(table)
}

fn C.igTableResetSettings(table &C.ImGuiTable)

pub fn ig_table_reset_settings(table &C.ImGuiTable) {
	C.igTableResetSettings(table)
}

fn C.igTableGetBoundSettings(table &C.ImGuiTable) &C.ImGuiTableSettings

pub fn ig_table_get_bound_settings(table &C.ImGuiTable) &C.ImGuiTableSettings {
	return C.igTableGetBoundSettings(table)
}

fn C.igTableSettingsAddSettingsHandler()

pub fn ig_table_settings_add_settings_handler() {
	C.igTableSettingsAddSettingsHandler()
}

fn C.igTableSettingsCreate(id ImGuiID, columns_count int) &C.ImGuiTableSettings

pub fn ig_table_settings_create(id ImGuiID, columns_count int) &C.ImGuiTableSettings {
	return C.igTableSettingsCreate(id, columns_count)
}

fn C.igTableSettingsFindByID(id ImGuiID) &C.ImGuiTableSettings

pub fn ig_table_settings_find_by_id(id ImGuiID) &C.ImGuiTableSettings {
	return C.igTableSettingsFindByID(id)
}

fn C.igGetCurrentTabBar() &C.ImGuiTabBar

pub fn ig_get_current_tab_bar() &C.ImGuiTabBar {
	return C.igGetCurrentTabBar()
}

fn C.igBeginTabBarEx(tab_bar &C.ImGuiTabBar, bb C.ImRect, flags ImGuiTabBarFlags) bool

pub fn ig_begin_tab_bar_ex(tab_bar &C.ImGuiTabBar, bb C.ImRect, flags ImGuiTabBarFlags) bool {
	return C.igBeginTabBarEx(tab_bar, bb, flags)
}

fn C.igTabBarFindTabByID(tab_bar &C.ImGuiTabBar, tab_id ImGuiID) &C.ImGuiTabItem

pub fn ig_tab_bar_find_tab_by_id(tab_bar &C.ImGuiTabBar, tab_id ImGuiID) &C.ImGuiTabItem {
	return C.igTabBarFindTabByID(tab_bar, tab_id)
}

fn C.igTabBarFindTabByOrder(tab_bar &C.ImGuiTabBar, order int) &C.ImGuiTabItem

pub fn ig_tab_bar_find_tab_by_order(tab_bar &C.ImGuiTabBar, order int) &C.ImGuiTabItem {
	return C.igTabBarFindTabByOrder(tab_bar, order)
}

fn C.igTabBarFindMostRecentlySelectedTabForActiveWindow(tab_bar &C.ImGuiTabBar) &C.ImGuiTabItem

pub fn ig_tab_bar_find_most_recently_selected_tab_for_active_window(tab_bar &C.ImGuiTabBar) &C.ImGuiTabItem {
	return C.igTabBarFindMostRecentlySelectedTabForActiveWindow(tab_bar)
}

fn C.igTabBarGetCurrentTab(tab_bar &C.ImGuiTabBar) &C.ImGuiTabItem

pub fn ig_tab_bar_get_current_tab(tab_bar &C.ImGuiTabBar) &C.ImGuiTabItem {
	return C.igTabBarGetCurrentTab(tab_bar)
}

fn C.igTabBarGetTabOrder(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem) int

pub fn ig_tab_bar_get_tab_order(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem) int {
	return C.igTabBarGetTabOrder(tab_bar, tab)
}

fn C.igTabBarGetTabName(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem) &i8

pub fn ig_tab_bar_get_tab_name(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem) &i8 {
	return C.igTabBarGetTabName(tab_bar, tab)
}

fn C.igTabBarAddTab(tab_bar &C.ImGuiTabBar, tab_flags ImGuiTabItemFlags, window &C.ImGuiWindow)

pub fn ig_tab_bar_add_tab(tab_bar &C.ImGuiTabBar, tab_flags ImGuiTabItemFlags, window &C.ImGuiWindow) {
	C.igTabBarAddTab(tab_bar, tab_flags, window)
}

fn C.igTabBarRemoveTab(tab_bar &C.ImGuiTabBar, tab_id ImGuiID)

pub fn ig_tab_bar_remove_tab(tab_bar &C.ImGuiTabBar, tab_id ImGuiID) {
	C.igTabBarRemoveTab(tab_bar, tab_id)
}

fn C.igTabBarCloseTab(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem)

pub fn ig_tab_bar_close_tab(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem) {
	C.igTabBarCloseTab(tab_bar, tab)
}

fn C.igTabBarQueueFocus(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem)

pub fn ig_tab_bar_queue_focus(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem) {
	C.igTabBarQueueFocus(tab_bar, tab)
}

fn C.igTabBarQueueReorder(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem, offset int)

pub fn ig_tab_bar_queue_reorder(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem, offset int) {
	C.igTabBarQueueReorder(tab_bar, tab, offset)
}

fn C.igTabBarQueueReorderFromMousePos(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem, mouse_pos C.ImVec2)

pub fn ig_tab_bar_queue_reorder_from_mouse_pos(tab_bar &C.ImGuiTabBar, tab &C.ImGuiTabItem, mouse_pos C.ImVec2) {
	C.igTabBarQueueReorderFromMousePos(tab_bar, tab, mouse_pos)
}

fn C.igTabBarProcessReorder(tab_bar &C.ImGuiTabBar) bool

pub fn ig_tab_bar_process_reorder(tab_bar &C.ImGuiTabBar) bool {
	return C.igTabBarProcessReorder(tab_bar)
}

fn C.igTabItemEx(tab_bar &C.ImGuiTabBar, label &i8, p_open &bool, flags ImGuiTabItemFlags, docked_window &C.ImGuiWindow) bool

pub fn ig_tab_item_ex(tab_bar &C.ImGuiTabBar, label &i8, p_open &bool, flags ImGuiTabItemFlags, docked_window &C.ImGuiWindow) bool {
	return C.igTabItemEx(tab_bar, label, p_open, flags, docked_window)
}

fn C.igTabItemCalcSize_Str(p_out &C.ImVec2, label &i8, has_close_button_or_unsaved_marker bool)

pub fn ig_tab_item_calc_size_str(p_out &C.ImVec2, label &i8, has_close_button_or_unsaved_marker bool) {
	C.igTabItemCalcSize_Str(p_out, label, has_close_button_or_unsaved_marker)
}

fn C.igTabItemCalcSize_WindowPtr(p_out &C.ImVec2, window &C.ImGuiWindow)

pub fn ig_tab_item_calc_size_window_ptr(p_out &C.ImVec2, window &C.ImGuiWindow) {
	C.igTabItemCalcSize_WindowPtr(p_out, window)
}

fn C.igTabItemBackground(draw_list &C.ImDrawList, bb C.ImRect, flags ImGuiTabItemFlags, col ImU32)

pub fn ig_tab_item_background(draw_list &C.ImDrawList, bb C.ImRect, flags ImGuiTabItemFlags, col ImU32) {
	C.igTabItemBackground(draw_list, bb, flags, col)
}

fn C.igTabItemLabelAndCloseButton(draw_list &C.ImDrawList, bb C.ImRect, flags ImGuiTabItemFlags, frame_padding C.ImVec2, label &i8, tab_id ImGuiID, close_button_id ImGuiID, is_contents_visible bool, out_just_closed &bool, out_text_clipped &bool)

pub fn ig_tab_item_label_and_close_button(draw_list &C.ImDrawList, bb C.ImRect, flags ImGuiTabItemFlags, frame_padding C.ImVec2, label &i8, tab_id ImGuiID, close_button_id ImGuiID, is_contents_visible bool, out_just_closed &bool, out_text_clipped &bool) {
	C.igTabItemLabelAndCloseButton(draw_list, bb, flags, frame_padding, label, tab_id,
		close_button_id, is_contents_visible, out_just_closed, out_text_clipped)
}

fn C.igRenderText(pos C.ImVec2, text &i8, text_end &i8, hide_text_after_hash bool)

pub fn ig_render_text(pos C.ImVec2, text &i8, text_end &i8, hide_text_after_hash bool) {
	C.igRenderText(pos, text, text_end, hide_text_after_hash)
}

fn C.igRenderTextWrapped(pos C.ImVec2, text &i8, text_end &i8, wrap_width f32)

pub fn ig_render_text_wrapped(pos C.ImVec2, text &i8, text_end &i8, wrap_width f32) {
	C.igRenderTextWrapped(pos, text, text_end, wrap_width)
}

fn C.igRenderTextClipped(pos_min C.ImVec2, pos_max C.ImVec2, text &i8, text_end &i8, text_size_if_known &C.ImVec2, align C.ImVec2, clip_rect &C.ImRect)

pub fn ig_render_text_clipped(pos_min C.ImVec2, pos_max C.ImVec2, text &i8, text_end &i8, text_size_if_known &C.ImVec2, align C.ImVec2, clip_rect &C.ImRect) {
	C.igRenderTextClipped(pos_min, pos_max, text, text_end, text_size_if_known, align,
		clip_rect)
}

fn C.igRenderTextClippedEx(draw_list &C.ImDrawList, pos_min C.ImVec2, pos_max C.ImVec2, text &i8, text_end &i8, text_size_if_known &C.ImVec2, align C.ImVec2, clip_rect &C.ImRect)

pub fn ig_render_text_clipped_ex(draw_list &C.ImDrawList, pos_min C.ImVec2, pos_max C.ImVec2, text &i8, text_end &i8, text_size_if_known &C.ImVec2, align C.ImVec2, clip_rect &C.ImRect) {
	C.igRenderTextClippedEx(draw_list, pos_min, pos_max, text, text_end, text_size_if_known,
		align, clip_rect)
}

fn C.igRenderTextEllipsis(draw_list &C.ImDrawList, pos_min C.ImVec2, pos_max C.ImVec2, clip_max_x f32, ellipsis_max_x f32, text &i8, text_end &i8, text_size_if_known &C.ImVec2)

pub fn ig_render_text_ellipsis(draw_list &C.ImDrawList, pos_min C.ImVec2, pos_max C.ImVec2, clip_max_x f32, ellipsis_max_x f32, text &i8, text_end &i8, text_size_if_known &C.ImVec2) {
	C.igRenderTextEllipsis(draw_list, pos_min, pos_max, clip_max_x, ellipsis_max_x, text,
		text_end, text_size_if_known)
}

fn C.igRenderFrame(p_min C.ImVec2, p_max C.ImVec2, fill_col ImU32, borders bool, rounding f32)

pub fn ig_render_frame(p_min C.ImVec2, p_max C.ImVec2, fill_col ImU32, borders bool, rounding f32) {
	C.igRenderFrame(p_min, p_max, fill_col, borders, rounding)
}

fn C.igRenderFrameBorder(p_min C.ImVec2, p_max C.ImVec2, rounding f32)

pub fn ig_render_frame_border(p_min C.ImVec2, p_max C.ImVec2, rounding f32) {
	C.igRenderFrameBorder(p_min, p_max, rounding)
}

fn C.igRenderColorRectWithAlphaCheckerboard(draw_list &C.ImDrawList, p_min C.ImVec2, p_max C.ImVec2, fill_col ImU32, grid_step f32, grid_off C.ImVec2, rounding f32, flags ImDrawFlags)

pub fn ig_render_color_rect_with_alpha_checkerboard(draw_list &C.ImDrawList, p_min C.ImVec2, p_max C.ImVec2, fill_col ImU32, grid_step f32, grid_off C.ImVec2, rounding f32, flags ImDrawFlags) {
	C.igRenderColorRectWithAlphaCheckerboard(draw_list, p_min, p_max, fill_col, grid_step,
		grid_off, rounding, flags)
}

fn C.igRenderNavHighlight(bb C.ImRect, id ImGuiID, flags ImGuiNavHighlightFlags)

pub fn ig_render_nav_highlight(bb C.ImRect, id ImGuiID, flags ImGuiNavHighlightFlags) {
	C.igRenderNavHighlight(bb, id, flags)
}

fn C.igFindRenderedTextEnd(text &i8, text_end &i8) &i8

pub fn ig_find_rendered_text_end(text &i8, text_end &i8) &i8 {
	return C.igFindRenderedTextEnd(text, text_end)
}

fn C.igRenderMouseCursor(pos C.ImVec2, scale f32, mouse_cursor ImGuiMouseCursor, col_fill ImU32, col_border ImU32, col_shadow ImU32)

pub fn ig_render_mouse_cursor(pos C.ImVec2, scale f32, mouse_cursor ImGuiMouseCursor, col_fill ImU32, col_border ImU32, col_shadow ImU32) {
	C.igRenderMouseCursor(pos, scale, mouse_cursor, col_fill, col_border, col_shadow)
}

fn C.igRenderArrow(draw_list &C.ImDrawList, pos C.ImVec2, col ImU32, dir ImGuiDir, scale f32)

pub fn ig_render_arrow(draw_list &C.ImDrawList, pos C.ImVec2, col ImU32, dir ImGuiDir, scale f32) {
	C.igRenderArrow(draw_list, pos, col, dir, scale)
}

fn C.igRenderBullet(draw_list &C.ImDrawList, pos C.ImVec2, col ImU32)

pub fn ig_render_bullet(draw_list &C.ImDrawList, pos C.ImVec2, col ImU32) {
	C.igRenderBullet(draw_list, pos, col)
}

fn C.igRenderCheckMark(draw_list &C.ImDrawList, pos C.ImVec2, col ImU32, sz f32)

pub fn ig_render_check_mark(draw_list &C.ImDrawList, pos C.ImVec2, col ImU32, sz f32) {
	C.igRenderCheckMark(draw_list, pos, col, sz)
}

fn C.igRenderArrowPointingAt(draw_list &C.ImDrawList, pos C.ImVec2, half_sz C.ImVec2, direction ImGuiDir, col ImU32)

pub fn ig_render_arrow_pointing_at(draw_list &C.ImDrawList, pos C.ImVec2, half_sz C.ImVec2, direction ImGuiDir, col ImU32) {
	C.igRenderArrowPointingAt(draw_list, pos, half_sz, direction, col)
}

fn C.igRenderArrowDockMenu(draw_list &C.ImDrawList, p_min C.ImVec2, sz f32, col ImU32)

pub fn ig_render_arrow_dock_menu(draw_list &C.ImDrawList, p_min C.ImVec2, sz f32, col ImU32) {
	C.igRenderArrowDockMenu(draw_list, p_min, sz, col)
}

fn C.igRenderRectFilledRangeH(draw_list &C.ImDrawList, rect C.ImRect, col ImU32, x_start_norm f32, x_end_norm f32, rounding f32)

pub fn ig_render_rect_filled_range_h(draw_list &C.ImDrawList, rect C.ImRect, col ImU32, x_start_norm f32, x_end_norm f32, rounding f32) {
	C.igRenderRectFilledRangeH(draw_list, rect, col, x_start_norm, x_end_norm, rounding)
}

fn C.igRenderRectFilledWithHole(draw_list &C.ImDrawList, outer C.ImRect, inner C.ImRect, col ImU32, rounding f32)

pub fn ig_render_rect_filled_with_hole(draw_list &C.ImDrawList, outer C.ImRect, inner C.ImRect, col ImU32, rounding f32) {
	C.igRenderRectFilledWithHole(draw_list, outer, inner, col, rounding)
}

fn C.igCalcRoundingFlagsForRectInRect(r_in C.ImRect, r_outer C.ImRect, threshold f32) ImDrawFlags

pub fn ig_calc_rounding_flags_for_rect_in_rect(r_in C.ImRect, r_outer C.ImRect, threshold f32) ImDrawFlags {
	return C.igCalcRoundingFlagsForRectInRect(r_in, r_outer, threshold)
}

fn C.igTextEx(text &i8, text_end &i8, flags ImGuiTextFlags)

pub fn ig_text_ex(text &i8, text_end &i8, flags ImGuiTextFlags) {
	C.igTextEx(text, text_end, flags)
}

fn C.igButtonEx(label &i8, size_arg C.ImVec2, flags ImGuiButtonFlags) bool

pub fn ig_button_ex(label &i8, size_arg C.ImVec2, flags ImGuiButtonFlags) bool {
	return C.igButtonEx(label, size_arg, flags)
}

fn C.igArrowButtonEx(str_id &i8, dir ImGuiDir, size_arg C.ImVec2, flags ImGuiButtonFlags) bool

pub fn ig_arrow_button_ex(str_id &i8, dir ImGuiDir, size_arg C.ImVec2, flags ImGuiButtonFlags) bool {
	return C.igArrowButtonEx(str_id, dir, size_arg, flags)
}

fn C.igImageButtonEx(id ImGuiID, texture_id ImTextureID, image_size C.ImVec2, uv0 C.ImVec2, uv1 C.ImVec2, bg_col C.ImVec4, tint_col C.ImVec4, flags ImGuiButtonFlags) bool

pub fn ig_image_button_ex(id ImGuiID, texture_id ImTextureID, image_size C.ImVec2, uv0 C.ImVec2, uv1 C.ImVec2, bg_col C.ImVec4, tint_col C.ImVec4, flags ImGuiButtonFlags) bool {
	return C.igImageButtonEx(id, texture_id, image_size, uv0, uv1, bg_col, tint_col, flags)
}

fn C.igSeparatorEx(flags ImGuiSeparatorFlags, thickness f32)

pub fn ig_separator_ex(flags ImGuiSeparatorFlags, thickness f32) {
	C.igSeparatorEx(flags, thickness)
}

fn C.igSeparatorTextEx(id ImGuiID, label &i8, label_end &i8, extra_width f32)

pub fn ig_separator_text_ex(id ImGuiID, label &i8, label_end &i8, extra_width f32) {
	C.igSeparatorTextEx(id, label, label_end, extra_width)
}

fn C.igCheckboxFlags_S64Ptr(label &i8, flags &ImS64, flags_value ImS64) bool

pub fn ig_checkbox_flags_s64_ptr(label &i8, flags &ImS64, flags_value ImS64) bool {
	return C.igCheckboxFlags_S64Ptr(label, flags, flags_value)
}

fn C.igCheckboxFlags_U64Ptr(label &i8, flags &ImU64, flags_value ImU64) bool

pub fn ig_checkbox_flags_u64_ptr(label &i8, flags &ImU64, flags_value ImU64) bool {
	return C.igCheckboxFlags_U64Ptr(label, flags, flags_value)
}

fn C.igCloseButton(id ImGuiID, pos C.ImVec2) bool

pub fn ig_close_button(id ImGuiID, pos C.ImVec2) bool {
	return C.igCloseButton(id, pos)
}

fn C.igCollapseButton(id ImGuiID, pos C.ImVec2, dock_node &C.ImGuiDockNode) bool

pub fn ig_collapse_button(id ImGuiID, pos C.ImVec2, dock_node &C.ImGuiDockNode) bool {
	return C.igCollapseButton(id, pos, dock_node)
}

fn C.igScrollbar(axis ImGuiAxis)

pub fn ig_scrollbar(axis ImGuiAxis) {
	C.igScrollbar(axis)
}

fn C.igScrollbarEx(bb C.ImRect, id ImGuiID, axis ImGuiAxis, p_scroll_v &ImS64, avail_v ImS64, contents_v ImS64, flags ImDrawFlags) bool

pub fn ig_scrollbar_ex(bb C.ImRect, id ImGuiID, axis ImGuiAxis, p_scroll_v &ImS64, avail_v ImS64, contents_v ImS64, flags ImDrawFlags) bool {
	return C.igScrollbarEx(bb, id, axis, p_scroll_v, avail_v, contents_v, flags)
}

fn C.igGetWindowScrollbarRect(p_out &C.ImRect, window &C.ImGuiWindow, axis ImGuiAxis)

pub fn ig_get_window_scrollbar_rect(p_out &C.ImRect, window &C.ImGuiWindow, axis ImGuiAxis) {
	C.igGetWindowScrollbarRect(p_out, window, axis)
}

fn C.igGetWindowScrollbarID(window &C.ImGuiWindow, axis ImGuiAxis) ImGuiID

pub fn ig_get_window_scrollbar_id(window &C.ImGuiWindow, axis ImGuiAxis) ImGuiID {
	return C.igGetWindowScrollbarID(window, axis)
}

fn C.igGetWindowResizeCornerID(window &C.ImGuiWindow, n int) ImGuiID

pub fn ig_get_window_resize_corner_id(window &C.ImGuiWindow, n int) ImGuiID {
	return C.igGetWindowResizeCornerID(window, n)
}

fn C.igGetWindowResizeBorderID(window &C.ImGuiWindow, dir ImGuiDir) ImGuiID

pub fn ig_get_window_resize_border_id(window &C.ImGuiWindow, dir ImGuiDir) ImGuiID {
	return C.igGetWindowResizeBorderID(window, dir)
}

fn C.igButtonBehavior(bb C.ImRect, id ImGuiID, out_hovered &bool, out_held &bool, flags ImGuiButtonFlags) bool

pub fn ig_button_behavior(bb C.ImRect, id ImGuiID, out_hovered &bool, out_held &bool, flags ImGuiButtonFlags) bool {
	return C.igButtonBehavior(bb, id, out_hovered, out_held, flags)
}

fn C.igDragBehavior(id ImGuiID, data_type ImGuiDataType, p_v voidptr, v_speed f32, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool

pub fn ig_drag_behavior(id ImGuiID, data_type ImGuiDataType, p_v voidptr, v_speed f32, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags) bool {
	return C.igDragBehavior(id, data_type, p_v, v_speed, p_min, p_max, format, flags)
}

fn C.igSliderBehavior(bb C.ImRect, id ImGuiID, data_type ImGuiDataType, p_v voidptr, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags, out_grab_bb &C.ImRect) bool

pub fn ig_slider_behavior(bb C.ImRect, id ImGuiID, data_type ImGuiDataType, p_v voidptr, p_min voidptr, p_max voidptr, format &i8, flags ImGuiSliderFlags, out_grab_bb &C.ImRect) bool {
	return C.igSliderBehavior(bb, id, data_type, p_v, p_min, p_max, format, flags, out_grab_bb)
}

fn C.igSplitterBehavior(bb C.ImRect, id ImGuiID, axis ImGuiAxis, size1 &f32, size2 &f32, min_size1 f32, min_size2 f32, hover_extend f32, hover_visibility_delay f32, bg_col ImU32) bool

pub fn ig_splitter_behavior(bb C.ImRect, id ImGuiID, axis ImGuiAxis, size1 &f32, size2 &f32, min_size1 f32, min_size2 f32, hover_extend f32, hover_visibility_delay f32, bg_col ImU32) bool {
	return C.igSplitterBehavior(bb, id, axis, size1, size2, min_size1, min_size2, hover_extend,
		hover_visibility_delay, bg_col)
}

fn C.igTreeNodeBehavior(id ImGuiID, flags ImGuiTreeNodeFlags, label &i8, label_end &i8) bool

pub fn ig_tree_node_behavior(id ImGuiID, flags ImGuiTreeNodeFlags, label &i8, label_end &i8) bool {
	return C.igTreeNodeBehavior(id, flags, label, label_end)
}

fn C.igTreePushOverrideID(id ImGuiID)

pub fn ig_tree_push_override_id(id ImGuiID) {
	C.igTreePushOverrideID(id)
}

fn C.igTreeNodeGetOpen(storage_id ImGuiID) bool

pub fn ig_tree_node_get_open(storage_id ImGuiID) bool {
	return C.igTreeNodeGetOpen(storage_id)
}

fn C.igTreeNodeSetOpen(storage_id ImGuiID, open bool)

pub fn ig_tree_node_set_open(storage_id ImGuiID, open bool) {
	C.igTreeNodeSetOpen(storage_id, open)
}

fn C.igTreeNodeUpdateNextOpen(storage_id ImGuiID, flags ImGuiTreeNodeFlags) bool

pub fn ig_tree_node_update_next_open(storage_id ImGuiID, flags ImGuiTreeNodeFlags) bool {
	return C.igTreeNodeUpdateNextOpen(storage_id, flags)
}

fn C.igDataTypeGetInfo(data_type ImGuiDataType) &C.ImGuiDataTypeInfo

pub fn ig_data_type_get_info(data_type ImGuiDataType) &C.ImGuiDataTypeInfo {
	return C.igDataTypeGetInfo(data_type)
}

fn C.igDataTypeFormatString(buf &i8, buf_size int, data_type ImGuiDataType, p_data voidptr, format &i8) int

pub fn ig_data_type_format_string(buf &i8, buf_size int, data_type ImGuiDataType, p_data voidptr, format &i8) int {
	return C.igDataTypeFormatString(buf, buf_size, data_type, p_data, format)
}

fn C.igDataTypeApplyOp(data_type ImGuiDataType, op int, output voidptr, arg_1 voidptr, arg_2 voidptr)

pub fn ig_data_type_apply_op(data_type ImGuiDataType, op int, output voidptr, arg_1 voidptr, arg_2 voidptr) {
	C.igDataTypeApplyOp(data_type, op, output, arg_1, arg_2)
}

fn C.igDataTypeApplyFromText(buf &i8, data_type ImGuiDataType, p_data voidptr, format &i8, p_data_when_empty voidptr) bool

pub fn ig_data_type_apply_from_text(buf &i8, data_type ImGuiDataType, p_data voidptr, format &i8, p_data_when_empty voidptr) bool {
	return C.igDataTypeApplyFromText(buf, data_type, p_data, format, p_data_when_empty)
}

fn C.igDataTypeCompare(data_type ImGuiDataType, arg_1 voidptr, arg_2 voidptr) int

pub fn ig_data_type_compare(data_type ImGuiDataType, arg_1 voidptr, arg_2 voidptr) int {
	return C.igDataTypeCompare(data_type, arg_1, arg_2)
}

fn C.igDataTypeClamp(data_type ImGuiDataType, p_data voidptr, p_min voidptr, p_max voidptr) bool

pub fn ig_data_type_clamp(data_type ImGuiDataType, p_data voidptr, p_min voidptr, p_max voidptr) bool {
	return C.igDataTypeClamp(data_type, p_data, p_min, p_max)
}

// fn C.igInputTextEx(label &i8, hint &i8, buf &i8, buf_size int, size_arg C.ImVec2, flags ImGuiInputTextFlags, callback ImGuiInputTextCallback, user_data voidptr) bool

// pub fn ig_input_text_ex(label &i8, hint &i8, buf &i8, buf_size int, size_arg C.ImVec2, flags ImGuiInputTextFlags, callback ImGuiInputTextCallback, user_data voidptr) bool {
// 	return C.igInputTextEx(label, hint, buf, buf_size, size_arg, flags, callback, user_data)
// }

fn C.igInputTextDeactivateHook(id ImGuiID)

pub fn ig_input_text_deactivate_hook(id ImGuiID) {
	C.igInputTextDeactivateHook(id)
}

fn C.igTempInputText(bb C.ImRect, id ImGuiID, label &i8, buf &i8, buf_size int, flags ImGuiInputTextFlags) bool

pub fn ig_temp_input_text(bb C.ImRect, id ImGuiID, label &i8, buf &i8, buf_size int, flags ImGuiInputTextFlags) bool {
	return C.igTempInputText(bb, id, label, buf, buf_size, flags)
}

fn C.igTempInputScalar(bb C.ImRect, id ImGuiID, label &i8, data_type ImGuiDataType, p_data voidptr, format &i8, p_clamp_min voidptr, p_clamp_max voidptr) bool

pub fn ig_temp_input_scalar(bb C.ImRect, id ImGuiID, label &i8, data_type ImGuiDataType, p_data voidptr, format &i8, p_clamp_min voidptr, p_clamp_max voidptr) bool {
	return C.igTempInputScalar(bb, id, label, data_type, p_data, format, p_clamp_min,
		p_clamp_max)
}

fn C.igTempInputIsActive(id ImGuiID) bool

pub fn ig_temp_input_is_active(id ImGuiID) bool {
	return C.igTempInputIsActive(id)
}

fn C.igGetInputTextState(id ImGuiID) &C.ImGuiInputTextState

pub fn ig_get_input_text_state(id ImGuiID) &C.ImGuiInputTextState {
	return C.igGetInputTextState(id)
}

fn C.igSetNextItemRefVal(data_type ImGuiDataType, p_data voidptr)

pub fn ig_set_next_item_ref_val(data_type ImGuiDataType, p_data voidptr) {
	C.igSetNextItemRefVal(data_type, p_data)
}

fn C.igColorTooltip(text &i8, col &f32, flags ImGuiColorEditFlags)

pub fn ig_color_tooltip(text &i8, col &f32, flags ImGuiColorEditFlags) {
	C.igColorTooltip(text, col, flags)
}

fn C.igColorEditOptionsPopup(col &f32, flags ImGuiColorEditFlags)

pub fn ig_color_edit_options_popup(col &f32, flags ImGuiColorEditFlags) {
	C.igColorEditOptionsPopup(col, flags)
}

fn C.igColorPickerOptionsPopup(ref_col &f32, flags ImGuiColorEditFlags)

pub fn ig_color_picker_options_popup(ref_col &f32, flags ImGuiColorEditFlags) {
	C.igColorPickerOptionsPopup(ref_col, flags)
}

fn C.igPlotEx(plot_type ImGuiPlotType, label &i8, values_getter fn (voidptr, int) f32, data voidptr, values_count int, values_offset int, overlay_text &i8, scale_min f32, scale_max f32, size_arg C.ImVec2) int

pub fn ig_plot_ex(plot_type ImGuiPlotType, label &i8, values_getter fn (voidptr, int) f32, data voidptr, values_count int, values_offset int, overlay_text &i8, scale_min f32, scale_max f32, size_arg C.ImVec2) int {
	return C.igPlotEx(plot_type, label, values_getter, data, values_count, values_offset,
		overlay_text, scale_min, scale_max, size_arg)
}

fn C.igShadeVertsLinearColorGradientKeepAlpha(draw_list &C.ImDrawList, vert_start_idx int, vert_end_idx int, gradient_p0 C.ImVec2, gradient_p1 C.ImVec2, col0 ImU32, col1 ImU32)

pub fn ig_shade_verts_linear_color_gradient_keep_alpha(draw_list &C.ImDrawList, vert_start_idx int, vert_end_idx int, gradient_p0 C.ImVec2, gradient_p1 C.ImVec2, col0 ImU32, col1 ImU32) {
	C.igShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx,
		gradient_p0, gradient_p1, col0, col1)
}

fn C.igShadeVertsLinearUV(draw_list &C.ImDrawList, vert_start_idx int, vert_end_idx int, a C.ImVec2, b C.ImVec2, uv_a C.ImVec2, uv_b C.ImVec2, clamp bool)

pub fn ig_shade_verts_linear_uv(draw_list &C.ImDrawList, vert_start_idx int, vert_end_idx int, a C.ImVec2, b C.ImVec2, uv_a C.ImVec2, uv_b C.ImVec2, clamp bool) {
	C.igShadeVertsLinearUV(draw_list, vert_start_idx, vert_end_idx, a, b, uv_a, uv_b,
		clamp)
}

fn C.igShadeVertsTransformPos(draw_list &C.ImDrawList, vert_start_idx int, vert_end_idx int, pivot_in C.ImVec2, cos_a f32, sin_a f32, pivot_out C.ImVec2)

pub fn ig_shade_verts_transform_pos(draw_list &C.ImDrawList, vert_start_idx int, vert_end_idx int, pivot_in C.ImVec2, cos_a f32, sin_a f32, pivot_out C.ImVec2) {
	C.igShadeVertsTransformPos(draw_list, vert_start_idx, vert_end_idx, pivot_in, cos_a,
		sin_a, pivot_out)
}

fn C.igGcCompactTransientMiscBuffers()

pub fn ig_gc_compact_transient_misc_buffers() {
	C.igGcCompactTransientMiscBuffers()
}

fn C.igGcCompactTransientWindowBuffers(window &C.ImGuiWindow)

pub fn ig_gc_compact_transient_window_buffers(window &C.ImGuiWindow) {
	C.igGcCompactTransientWindowBuffers(window)
}

fn C.igGcAwakeTransientWindowBuffers(window &C.ImGuiWindow)

pub fn ig_gc_awake_transient_window_buffers(window &C.ImGuiWindow) {
	C.igGcAwakeTransientWindowBuffers(window)
}

fn C.igDebugAllocHook(info &C.ImGuiDebugAllocInfo, frame_count int, ptr voidptr, size usize)

pub fn ig_debug_alloc_hook(info &C.ImGuiDebugAllocInfo, frame_count int, ptr voidptr, size usize) {
	C.igDebugAllocHook(info, frame_count, ptr, size)
}

fn C.igErrorCheckEndFrameRecover(log_callback ImGuiErrorLogCallback, user_data voidptr)

pub fn ig_error_check_end_frame_recover(log_callback ImGuiErrorLogCallback, user_data voidptr) {
	C.igErrorCheckEndFrameRecover(log_callback, user_data)
}

fn C.igErrorCheckEndWindowRecover(log_callback ImGuiErrorLogCallback, user_data voidptr)

pub fn ig_error_check_end_window_recover(log_callback ImGuiErrorLogCallback, user_data voidptr) {
	C.igErrorCheckEndWindowRecover(log_callback, user_data)
}

fn C.igErrorCheckUsingSetCursorPosToExtendParentBoundaries()

pub fn ig_error_check_using_set_cursor_pos_to_extend_parent_boundaries() {
	C.igErrorCheckUsingSetCursorPosToExtendParentBoundaries()
}

fn C.igDebugDrawCursorPos(col ImU32)

pub fn ig_debug_draw_cursor_pos(col ImU32) {
	C.igDebugDrawCursorPos(col)
}

fn C.igDebugDrawLineExtents(col ImU32)

pub fn ig_debug_draw_line_extents(col ImU32) {
	C.igDebugDrawLineExtents(col)
}

fn C.igDebugDrawItemRect(col ImU32)

pub fn ig_debug_draw_item_rect(col ImU32) {
	C.igDebugDrawItemRect(col)
}

fn C.igDebugTextUnformattedWithLocateItem(line_begin &i8, line_end &i8)

pub fn ig_debug_text_unformatted_with_locate_item(line_begin &i8, line_end &i8) {
	C.igDebugTextUnformattedWithLocateItem(line_begin, line_end)
}

fn C.igDebugLocateItem(target_id ImGuiID)

pub fn ig_debug_locate_item(target_id ImGuiID) {
	C.igDebugLocateItem(target_id)
}

fn C.igDebugLocateItemOnHover(target_id ImGuiID)

pub fn ig_debug_locate_item_on_hover(target_id ImGuiID) {
	C.igDebugLocateItemOnHover(target_id)
}

fn C.igDebugLocateItemResolveWithLastItem()

pub fn ig_debug_locate_item_resolve_with_last_item() {
	C.igDebugLocateItemResolveWithLastItem()
}

fn C.igDebugBreakClearData()

pub fn ig_debug_break_clear_data() {
	C.igDebugBreakClearData()
}

fn C.igDebugBreakButton(label &i8, description_of_location &i8) bool

pub fn ig_debug_break_button(label &i8, description_of_location &i8) bool {
	return C.igDebugBreakButton(label, description_of_location)
}

fn C.igDebugBreakButtonTooltip(keyboard_only bool, description_of_location &i8)

pub fn ig_debug_break_button_tooltip(keyboard_only bool, description_of_location &i8) {
	C.igDebugBreakButtonTooltip(keyboard_only, description_of_location)
}

fn C.igShowFontAtlas(atlas &C.ImFontAtlas)

pub fn ig_show_font_atlas(atlas &C.ImFontAtlas) {
	C.igShowFontAtlas(atlas)
}

fn C.igDebugHookIdInfo(id ImGuiID, data_type ImGuiDataType, data_id voidptr, data_id_end voidptr)

pub fn ig_debug_hook_id_info(id ImGuiID, data_type ImGuiDataType, data_id voidptr, data_id_end voidptr) {
	C.igDebugHookIdInfo(id, data_type, data_id, data_id_end)
}

fn C.igDebugNodeColumns(columns &C.ImGuiOldColumns)

pub fn ig_debug_node_columns(columns &C.ImGuiOldColumns) {
	C.igDebugNodeColumns(columns)
}

fn C.igDebugNodeDockNode(node &C.ImGuiDockNode, label &i8)

pub fn ig_debug_node_dock_node(node &C.ImGuiDockNode, label &i8) {
	C.igDebugNodeDockNode(node, label)
}

fn C.igDebugNodeDrawList(window &C.ImGuiWindow, viewport &C.ImGuiViewportP, draw_list &C.ImDrawList, label &i8)

pub fn ig_debug_node_draw_list(window &C.ImGuiWindow, viewport &C.ImGuiViewportP, draw_list &C.ImDrawList, label &i8) {
	C.igDebugNodeDrawList(window, viewport, draw_list, label)
}

fn C.igDebugNodeDrawCmdShowMeshAndBoundingBox(out_draw_list &C.ImDrawList, draw_list &C.ImDrawList, draw_cmd &C.ImDrawCmd, show_mesh bool, show_aabb bool)

pub fn ig_debug_node_draw_cmd_show_mesh_and_bounding_box(out_draw_list &C.ImDrawList, draw_list &C.ImDrawList, draw_cmd &C.ImDrawCmd, show_mesh bool, show_aabb bool) {
	C.igDebugNodeDrawCmdShowMeshAndBoundingBox(out_draw_list, draw_list, draw_cmd, show_mesh,
		show_aabb)
}

fn C.igDebugNodeFont(font &C.ImFont)

pub fn ig_debug_node_font(font &C.ImFont) {
	C.igDebugNodeFont(font)
}

fn C.igDebugNodeFontGlyph(font &C.ImFont, glyph &C.ImFontGlyph)

pub fn ig_debug_node_font_glyph(font &C.ImFont, glyph &C.ImFontGlyph) {
	C.igDebugNodeFontGlyph(font, glyph)
}

fn C.igDebugNodeStorage(storage &C.ImGuiStorage, label &i8)

pub fn ig_debug_node_storage(storage &C.ImGuiStorage, label &i8) {
	C.igDebugNodeStorage(storage, label)
}

fn C.igDebugNodeTabBar(tab_bar &C.ImGuiTabBar, label &i8)

pub fn ig_debug_node_tab_bar(tab_bar &C.ImGuiTabBar, label &i8) {
	C.igDebugNodeTabBar(tab_bar, label)
}

fn C.igDebugNodeTable(table &C.ImGuiTable)

pub fn ig_debug_node_table(table &C.ImGuiTable) {
	C.igDebugNodeTable(table)
}

fn C.igDebugNodeTableSettings(settings &C.ImGuiTableSettings)

pub fn ig_debug_node_table_settings(settings &C.ImGuiTableSettings) {
	C.igDebugNodeTableSettings(settings)
}

fn C.igDebugNodeInputTextState(state &C.ImGuiInputTextState)

pub fn ig_debug_node_input_text_state(state &C.ImGuiInputTextState) {
	C.igDebugNodeInputTextState(state)
}

fn C.igDebugNodeTypingSelectState(state &C.ImGuiTypingSelectState)

pub fn ig_debug_node_typing_select_state(state &C.ImGuiTypingSelectState) {
	C.igDebugNodeTypingSelectState(state)
}

fn C.igDebugNodeMultiSelectState(state &C.ImGuiMultiSelectState)

pub fn ig_debug_node_multi_select_state(state &C.ImGuiMultiSelectState) {
	C.igDebugNodeMultiSelectState(state)
}

fn C.igDebugNodeWindow(window &C.ImGuiWindow, label &i8)

pub fn ig_debug_node_window(window &C.ImGuiWindow, label &i8) {
	C.igDebugNodeWindow(window, label)
}

fn C.igDebugNodeWindowSettings(settings &C.ImGuiWindowSettings)

pub fn ig_debug_node_window_settings(settings &C.ImGuiWindowSettings) {
	C.igDebugNodeWindowSettings(settings)
}

fn C.igDebugNodeWindowsList(windows &C.ImVector_ImGuiWindowPtr, label &i8)

pub fn ig_debug_node_windows_list(windows &C.ImVector_ImGuiWindowPtr, label &i8) {
	C.igDebugNodeWindowsList(windows, label)
}

fn C.igDebugNodeWindowsListByBeginStackParent(windows &&C.ImGuiWindow, windows_size int, parent_in_begin_stack &C.ImGuiWindow)

pub fn ig_debug_node_windows_list_by_begin_stack_parent(windows &&C.ImGuiWindow, windows_size int, parent_in_begin_stack &C.ImGuiWindow) {
	C.igDebugNodeWindowsListByBeginStackParent(windows, windows_size, parent_in_begin_stack)
}

fn C.igDebugNodeViewport(viewport &C.ImGuiViewportP)

pub fn ig_debug_node_viewport(viewport &C.ImGuiViewportP) {
	C.igDebugNodeViewport(viewport)
}

fn C.igDebugNodePlatformMonitor(monitor &C.ImGuiPlatformMonitor, label &i8, idx int)

pub fn ig_debug_node_platform_monitor(monitor &C.ImGuiPlatformMonitor, label &i8, idx int) {
	C.igDebugNodePlatformMonitor(monitor, label, idx)
}

fn C.igDebugRenderKeyboardPreview(draw_list &C.ImDrawList)

pub fn ig_debug_render_keyboard_preview(draw_list &C.ImDrawList) {
	C.igDebugRenderKeyboardPreview(draw_list)
}

fn C.igDebugRenderViewportThumbnail(draw_list &C.ImDrawList, viewport &C.ImGuiViewportP, bb C.ImRect)

pub fn ig_debug_render_viewport_thumbnail(draw_list &C.ImDrawList, viewport &C.ImGuiViewportP, bb C.ImRect) {
	C.igDebugRenderViewportThumbnail(draw_list, viewport, bb)
}

fn C.igImFontAtlasGetBuilderForStbTruetype() &C.ImFontBuilderIO

pub fn ig_im_font_atlas_get_builder_for_stb_truetype() &C.ImFontBuilderIO {
	return C.igImFontAtlasGetBuilderForStbTruetype()
}

fn C.igImFontAtlasUpdateConfigDataPointers(atlas &C.ImFontAtlas)

pub fn ig_im_font_atlas_update_config_data_pointers(atlas &C.ImFontAtlas) {
	C.igImFontAtlasUpdateConfigDataPointers(atlas)
}

fn C.igImFontAtlasBuildInit(atlas &C.ImFontAtlas)

pub fn ig_im_font_atlas_build_init(atlas &C.ImFontAtlas) {
	C.igImFontAtlasBuildInit(atlas)
}

fn C.igImFontAtlasBuildSetupFont(atlas &C.ImFontAtlas, font &C.ImFont, font_config &C.ImFontConfig, ascent f32, descent f32)

pub fn ig_im_font_atlas_build_setup_font(atlas &C.ImFontAtlas, font &C.ImFont, font_config &C.ImFontConfig, ascent f32, descent f32) {
	C.igImFontAtlasBuildSetupFont(atlas, font, font_config, ascent, descent)
}

fn C.igImFontAtlasBuildPackCustomRects(atlas &C.ImFontAtlas, stbrp_context_opaque voidptr)

pub fn ig_im_font_atlas_build_pack_custom_rects(atlas &C.ImFontAtlas, stbrp_context_opaque voidptr) {
	C.igImFontAtlasBuildPackCustomRects(atlas, stbrp_context_opaque)
}

fn C.igImFontAtlasBuildFinish(atlas &C.ImFontAtlas)

pub fn ig_im_font_atlas_build_finish(atlas &C.ImFontAtlas) {
	C.igImFontAtlasBuildFinish(atlas)
}

fn C.igImFontAtlasBuildRender8bppRectFromString(atlas &C.ImFontAtlas, x int, y int, w int, h int, in_str &i8, in_marker_char i8, in_marker_pixel_value u8)

pub fn ig_im_font_atlas_build_render8bpp_rect_from_string(atlas &C.ImFontAtlas, x int, y int, w int, h int, in_str &i8, in_marker_char i8, in_marker_pixel_value u8) {
	C.igImFontAtlasBuildRender8bppRectFromString(atlas, x, y, w, h, in_str, in_marker_char,
		in_marker_pixel_value)
}

fn C.igImFontAtlasBuildRender32bppRectFromString(atlas &C.ImFontAtlas, x int, y int, w int, h int, in_str &i8, in_marker_char i8, in_marker_pixel_value u32)

pub fn ig_im_font_atlas_build_render32bpp_rect_from_string(atlas &C.ImFontAtlas, x int, y int, w int, h int, in_str &i8, in_marker_char i8, in_marker_pixel_value u32) {
	C.igImFontAtlasBuildRender32bppRectFromString(atlas, x, y, w, h, in_str, in_marker_char,
		in_marker_pixel_value)
}

fn C.igImFontAtlasBuildMultiplyCalcLookupTable(out_table &u8, in_multiply_factor f32)

pub fn ig_im_font_atlas_build_multiply_calc_lookup_table(out_table &u8, in_multiply_factor f32) {
	C.igImFontAtlasBuildMultiplyCalcLookupTable(out_table, in_multiply_factor)
}

fn C.igImFontAtlasBuildMultiplyRectAlpha8(table &u8, pixels &u8, x int, y int, w int, h int, stride int)

pub fn ig_im_font_atlas_build_multiply_rect_alpha8(table &u8, pixels &u8, x int, y int, w int, h int, stride int) {
	C.igImFontAtlasBuildMultiplyRectAlpha8(table, pixels, x, y, w, h, stride)
}

/////////////////////////hand written functions
// no LogTextV
@[c2v_variadic]
fn C.igLogText(fmt ...&i8)

pub fn ig_log_text(fmt &i8) {
	C.igLogText(fmt)
}

// no appendfV
@[c2v_variadic]
fn C.ImGuiTextBuffer_appendf(buffer &C.ImGuiTextBuffer, fmt ...&i8)

pub fn im_gui_text_buffer_appendf(buffer &C.ImGuiTextBuffer, fmt &i8) {
	C.ImGuiTextBuffer_appendf(buffer, fmt)
}

// for getting FLT_MAX in bindings
fn C.igGET_FLT_MAX() f32

pub fn ig_get_flt_max() f32 {
	return C.igGET_FLT_MAX()
}

// for getting FLT_MIN in bindings
fn C.igGET_FLT_MIN() f32

pub fn ig_get_flt_min() f32 {
	return C.igGET_FLT_MIN()
}

fn C.ImVector_ImWchar_create() &C.ImVector_ImWchar

pub fn im_vector_im_wchar_create() &C.ImVector_ImWchar {
	return C.ImVector_ImWchar_create()
}

fn C.ImVector_ImWchar_destroy(self &C.ImVector_ImWchar)

pub fn im_vector_im_wchar_destroy(self &C.ImVector_ImWchar) {
	C.ImVector_ImWchar_destroy(self)
}

fn C.ImVector_ImWchar_Init(p &C.ImVector_ImWchar)

pub fn im_vector_im_wchar_init(p &C.ImVector_ImWchar) {
	C.ImVector_ImWchar_Init(p)
}

fn C.ImVector_ImWchar_UnInit(p &C.ImVector_ImWchar)

pub fn im_vector_im_wchar_un_init(p &C.ImVector_ImWchar) {
	C.ImVector_ImWchar_UnInit(p)
}

fn C.ImGuiPlatformIO_Set_Platform_GetWindowPos(platform_io &C.ImGuiPlatformIO, user_callback fn (&C.ImGuiViewport, C.ImVec2))

pub fn im_gui_platform_io_set_platform_get_window_pos(platform_io &C.ImGuiPlatformIO, user_callback fn (&C.ImGuiViewport, C.ImVec2)) {
	C.ImGuiPlatformIO_Set_Platform_GetWindowPos(platform_io, user_callback)
}

fn C.ImGuiPlatformIO_Set_Platform_GetWindowSize(platform_io &C.ImGuiPlatformIO, user_callback fn (&C.ImGuiViewport, C.ImVec2))

pub fn im_gui_platform_io_set_platform_get_window_size(platform_io &C.ImGuiPlatformIO, user_callback fn (&C.ImGuiViewport, C.ImVec2)) {
	C.ImGuiPlatformIO_Set_Platform_GetWindowSize(platform_io, user_callback)
}

// CIMGUI_INCLUDED
