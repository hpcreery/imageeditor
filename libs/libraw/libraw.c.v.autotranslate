@[translated]
module libraw

import libs.libraw.c as _

// -* C++ -*
// *File: libraw_const.h
// *Copyright 2008-2024 LibRaw LLC (info@libraw.org)
// *Created: Sat Mar  8 , 2008
// *LibRaw error codes
//LibRaw is free software; you can redistribute it and/or modify
//it under the terms of the one of two licenses as you choose:
//
//1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
//   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
//
//2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
//   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
//
// 
// limit allocation size, default is 2Gb 
// limit thumbnail size, default is 512Mb
// Check if enough file space exists before tag read 
// LibRaw uses own memory pool management, with LIBRAW_MSIZE (512)
//entries. It is enough for parsing/decoding non-damaged files, but
//may overflow on specially crafted files (eg. with many string values
//like XMP blocks.
//LIBRAW_MEMPOOL_CHECK define will result in error on pool overflow 
enum LibRaw_openbayer_patterns {
	libraw_openbayer_rggb = 148
	libraw_openbayer_bggr = 22
	libraw_openbayer_grbg = 97
	libraw_openbayer_gbrg = 73
}

enum LibRaw_dngfields_marks {
	libraw_dngfm_forwardmatrix = 1
	libraw_dngfm_illuminant = 1 << 1
	libraw_dngfm_colormatrix = 1 << 2
	libraw_dngfm_calibration = 1 << 3
	libraw_dngfm_analogbalance = 1 << 4
	libraw_dngfm_black = 1 << 5
	libraw_dngfm_white = 1 << 6
	libraw_dngfm_opcode_2 = 1 << 7
	libraw_dngfm_lintable = 1 << 8
	libraw_dngfm_croporigin = 1 << 9
	libraw_dngfm_cropsize = 1 << 10
	libraw_dngfm_previewcs = 1 << 11
	libraw_dngfm_asshotneutral = 1 << 12
	libraw_dngfm_baselineexposure = 1 << 13
	libraw_dngfm_linearresponselimit = 1 << 14
	libraw_dngfm_usercrop = 1 << 15
	libraw_dngfm_opcode_1 = 1 << 16
	libraw_dngfm_opcode_3 = 1 << 17
}

enum LibRaw_As_Shot_WB_Applied_codes {
	libraw_aswb_applied = 1
	libraw_aswb_canon = 2
	libraw_aswb_nikon = 4
	libraw_aswb_nikon_sraw = 8
	libraw_aswb_pentax = 16
	libraw_aswb_sony = 32
}

enum LibRaw_ExifTagTypes {
	libraw_exiftag_type_unknown = 0
	libraw_exiftag_type_byte = 1
	libraw_exiftag_type_ascii = 2
	libraw_exiftag_type_short = 3
	libraw_exiftag_type_long = 4
	libraw_exiftag_type_rational = 5
	libraw_exiftag_type_sbyte = 6
	libraw_exiftag_type_undefined = 7
	libraw_exiftag_type_sshort = 8
	libraw_exiftag_type_slong = 9
	libraw_exiftag_type_srational = 10
	libraw_exiftag_type_float = 11
	libraw_exiftag_type_double = 12
	libraw_exiftag_type_ifd = 13
	libraw_exiftag_type_unicode = 14
	libraw_exiftag_type_complex = 15
	libraw_exiftag_type_long_8 = 16
	libraw_exiftag_type_slong_8 = 17
	libraw_exiftag_type_ifd_8 = 18
}

enum LibRaw_whitebalance_code {
// clang-format off
//
//      EXIF light sources
//      12 = FL-D; Daylight fluorescent (D 5700K â 7100K) (F1,F5)
//      13 = FL-N; Day white fluorescent (N 4600K â 5400K) (F7,F8)
//      14 = FL-W; Cool white fluorescent (W 3900K â 4500K) (F2,F6, office, store, warehouse)
//      15 = FL-WW; White fluorescent (WW 3200K â 3700K) (F3, residential)
//      16 = FL-L; Soft/Warm white fluorescent (L 2600K - 3250K) (F4, kitchen, bath)
//  
//clang-format on
	libraw_wbi_unknown = 0
	libraw_wbi_daylight = 1
	libraw_wbi_fluorescent = 2
	libraw_wbi_tungsten = 3
	libraw_wbi_flash = 4
	libraw_wbi_fine_weather = 9
	libraw_wbi_cloudy = 10
	libraw_wbi_shade = 11
	libraw_wbi_fl_d = 12
	libraw_wbi_fl_n = 13
	libraw_wbi_fl_w = 14
	libraw_wbi_fl_ww = 15
	libraw_wbi_fl_l = 16
	libraw_wbi_ill_a = 17
	libraw_wbi_ill_b = 18
	libraw_wbi_ill_c = 19
	libraw_wbi_d55 = 20
	libraw_wbi_d65 = 21
	libraw_wbi_d75 = 22
	libraw_wbi_d50 = 23
	libraw_wbi_studio_tungsten = 24
	libraw_wbi_sunset = 64
	libraw_wbi_underwater = 65
	libraw_wbi_fluorescent_high = 66
	libraw_wbi_ht_mercury = 67
	libraw_wbi_as_shot = 81
	libraw_wbi_auto = 82
	libraw_wbi_custom = 83
	libraw_wbi_auto1 = 85
	libraw_wbi_auto2 = 86
	libraw_wbi_auto3 = 87
	libraw_wbi_auto4 = 88
	libraw_wbi_custom1 = 90
	libraw_wbi_custom2 = 91
	libraw_wbi_custom3 = 92
	libraw_wbi_custom4 = 93
	libraw_wbi_custom5 = 94
	libraw_wbi_custom6 = 95
	libraw_wbi_pc_set1 = 96
	libraw_wbi_pc_set2 = 97
	libraw_wbi_pc_set3 = 98
	libraw_wbi_pc_set4 = 99
	libraw_wbi_pc_set5 = 100
	libraw_wbi_measured = 110
	libraw_wbi_bw = 120
	libraw_wbi_kelvin = 254
	libraw_wbi_other = 255
	libraw_wbi_none = 65535
}

enum LibRaw_MultiExposure_related {
	libraw_me_none = 0
	libraw_me_simple = 1
	libraw_me_overlay = 2
	libraw_me_hdr = 3
}

enum LibRaw_dng_processing {
	libraw_dng_none = 0
	libraw_dng_float = 1
	libraw_dng_linear = 2
	libraw_dng_deflate = 4
	libraw_dng_xtrans = 8
	libraw_dng_other = 16
	libraw_dng_8_bit = 32
//LIBRAW_DNG_LARGERANGE=64,
// more than 16 bit integer 
	// libraw_dng_all = libraw_dng_float | libraw_dng_linear | libraw_dng_deflate | libraw_dng_xtrans | libraw_dng_8_bit | libraw_dng_other
// |LIBRAW_DNG_LARGERANGE 
	// libraw_dng_default = libraw_dng_float | libraw_dng_linear | libraw_dng_deflate | libraw_dng_8_bit
}

enum LibRaw_output_flags {
	libraw_output_flags_none = 0
	libraw_output_flags_ppmmeta = 1
}

enum LibRaw_runtime_capabilities {
	libraw_caps_rawspeed = 1
	libraw_caps_dngsdk = 1 << 1
	libraw_caps_gprsdk = 1 << 2
	libraw_caps_unicodepaths = 1 << 3
	libraw_caps_x3_ftools = 1 << 4
	libraw_caps_rpi_6_by_9 = 1 << 5
	libraw_caps_zlib = 1 << 6
	libraw_caps_jpeg = 1 << 7
	libraw_caps_rawspeed_3 = 1 << 8
	libraw_caps_rawspeed_bits = 1 << 9
}

enum LibRaw_colorspace {
	libraw_colorspace_not_found = 0
	libraw_colorspace_s_rgb
	libraw_colorspace_adobe_rgb
	libraw_colorspace_wide_gamut_rgb
	libraw_colorspace_pro_photo_rgb
	libraw_colorspace_icc
	libraw_colorspace_uncalibrated
// Tag 0x0001 InteropIndex containing "R03" + LIBRAW_COLORSPACE_Uncalibrated = Adobe RGB
	libraw_colorspace_camera_linear_uni_wb
	libraw_colorspace_camera_linear
	libraw_colorspace_camera_gamma_uni_wb
	libraw_colorspace_camera_gamma
	libraw_colorspace_monochrome_linear
	libraw_colorspace_monochrome_gamma
	libraw_colorspace_rec2020
	libraw_colorspace_unknown = 255
}

enum LibRaw_cameramaker_index {
	libraw_cameramaker_unknown = 0
	libraw_cameramaker_agfa
	libraw_cameramaker_alcatel
	libraw_cameramaker_apple
	libraw_cameramaker_aptina
	libraw_cameramaker_avt
	libraw_cameramaker_baumer
	libraw_cameramaker_broadcom
	libraw_cameramaker_canon
	libraw_cameramaker_casio
	libraw_cameramaker_cine
	libraw_cameramaker_clauss
	libraw_cameramaker_contax
	libraw_cameramaker_creative
	libraw_cameramaker_dji
	libraw_cameramaker_dxo
	libraw_cameramaker_epson
	libraw_cameramaker_foculus
	libraw_cameramaker_fujifilm
	libraw_cameramaker_generic
	libraw_cameramaker_gione
	libraw_cameramaker_gitup
	libraw_cameramaker_google
	libraw_cameramaker_go_pro
	libraw_cameramaker_hasselblad
	libraw_cameramaker_htc
	libraw_cameramaker_i_mobile
	libraw_cameramaker_imacon
	libraw_cameramaker_jk_imaging
	libraw_cameramaker_kodak
	libraw_cameramaker_konica
	libraw_cameramaker_leaf
	libraw_cameramaker_leica
	libraw_cameramaker_lenovo
	libraw_cameramaker_lg
	libraw_cameramaker_logitech
	libraw_cameramaker_mamiya
	libraw_cameramaker_matrix
	libraw_cameramaker_meizu
	libraw_cameramaker_micron
	libraw_cameramaker_minolta
	libraw_cameramaker_motorola
	libraw_cameramaker_ngm
	libraw_cameramaker_nikon
	libraw_cameramaker_nokia
	libraw_cameramaker_olympus
	libraw_cameramaker_omni_vison
	libraw_cameramaker_panasonic
	libraw_cameramaker_parrot
	libraw_cameramaker_pentax
	libraw_cameramaker_phase_one
	libraw_cameramaker_photo_control
	libraw_cameramaker_photron
	libraw_cameramaker_pixelink
	libraw_cameramaker_polaroid
	libraw_cameramaker_red
	libraw_cameramaker_ricoh
	libraw_cameramaker_rollei
	libraw_cameramaker_rover_shot
	libraw_cameramaker_samsung
	libraw_cameramaker_sigma
	libraw_cameramaker_sinar
	libraw_cameramaker_sm_a_l
	libraw_cameramaker_sony
	libraw_cameramaker_st_micro
	libraw_cameramaker_thl
	libraw_cameramaker_vluu
	libraw_cameramaker_xiaomi
	libraw_cameramaker_xiaoyi
	libraw_cameramaker_yi
	libraw_cameramaker_yuneec
	libraw_cameramaker_zeiss
	libraw_cameramaker_one_plus
	libraw_cameramaker_isg
	libraw_cameramaker_vivo
	libraw_cameramaker_hmd_global
	libraw_cameramaker_huawei
	libraw_cameramaker_raspberry_pi
	libraw_cameramaker_om_digital
// Insert additional indexes here
	libraw_cameramaker_the_last_one
}

enum LibRaw_camera_mounts {
	libraw_mount_unknown = 0
	libraw_mount_alpa
	libraw_mount_c
// C-mount 
	libraw_mount_canon_ef_m
	libraw_mount_canon_ef_s
	libraw_mount_canon_ef
	libraw_mount_canon_rf
	libraw_mount_contax_n
	libraw_mount_contax645
	libraw_mount_ft
// original 4/3 
	libraw_mount_m_ft
// micro 4/3 
	libraw_mount_fuji_gf
// Fujifilm GFX cameras, G mount 
	libraw_mount_fuji_gx
// Fujifilm GX680 
	libraw_mount_fuji_x
	libraw_mount_hasselblad_h
// Hasselblad Hn cameras, HC & HCD lenses 
	libraw_mount_hasselblad_v
	libraw_mount_hasselblad_xcd
// Hasselblad Xn cameras, XCD lenses 
	libraw_mount_leica_m
// Leica rangefinder bayonet 
	libraw_mount_leica_r
// Leica SLRs, 'R' for reflex 
	libraw_mount_leica_s
// LIBRAW_FORMAT_LeicaS 'MF' 
	libraw_mount_leica_sl
// lens, mounts on 'L' throat, FF 
	libraw_mount_leica_tl
// lens, mounts on 'L' throat, APS-C 
	libraw_mount_lps_l
// Leica/Panasonic/Sigma camera mount, takes L, SL and TL lenses 
	libraw_mount_mamiya67
// Mamiya RB67, RZ67 
	libraw_mount_mamiya645
	libraw_mount_minolta_a
	libraw_mount_nikon_cx
// used in 'Nikon 1' series 
	libraw_mount_nikon_f
	libraw_mount_nikon_z
	libraw_mount_phase_one_i_xm_mv
	libraw_mount_phase_one_i_xm_rs
	libraw_mount_phase_one_i_xm
	libraw_mount_pentax_645
	libraw_mount_pentax_k
	libraw_mount_pentax_q
	libraw_mount_ricoh_module
	libraw_mount_rollei_bayonet
// Rollei Hy-6: Leaf AFi, Sinar Hy6- models 
	libraw_mount_samsung_nx_m
	libraw_mount_samsung_nx
	libraw_mount_sigma_x3_f
	libraw_mount_sony_e
	libraw_mount_lf
	libraw_mount_digital_back
	libraw_mount_fixed_lens
	libraw_mount_il_um
// Interchangeable lens, mount unknown 
	libraw_mount_the_last_one
}

enum LibRaw_camera_formats {
	libraw_format_unknown = 0
	libraw_format_apsc
	libraw_format_ff
	libraw_format_mf
	libraw_format_apsh
	libraw_format_1_inch
	libraw_format_1div2p3_inch
// 1/2.3" 
	libraw_format_1div1p7_inch
// 1/1.7" 
	libraw_format_ft
// sensor size in FT & mFT cameras 
	libraw_format_crop_645
// 44x33mm 
	libraw_format_leica_s
// 'MF' Leicas 
	libraw_format_645
	libraw_format_66
	libraw_format_69
	libraw_format_lf
	libraw_format_leica_dmr
	libraw_format_67
	libraw_format_sigma_apsc
// DP1, DP2, SD15, SD14, SD10, SD9 
	libraw_format_sigma_merrill
// SD1,  'SD1 Merrill',  'DP1 Merrill',  'DP2 Merrill' 
	libraw_format_sigma_apsh
// 'sd Quattro H' 
	libraw_format_3648
// DALSA FTF4052C (Mamiya ZD) 
	libraw_format_68
// Fujifilm GX680 
	libraw_format_the_last_one
}

enum LibRawImageAspects {
	libraw_image_aspect_unknown = 0
	libraw_image_aspect_other = 1
	libraw_image_aspect_minimal_real_aspect_value = 99
// 1:10
	libraw_image_aspect_maximal_real_aspect_value = 10000
// 10: 1
// Value:  width / height * 1000
	libraw_image_aspect_3to2 = 1000 * 3 / 2
	libraw_image_aspect_1to1 = 1000
	libraw_image_aspect_4to3 = 1000 * 4 / 3
	libraw_image_aspect_16to9 = 1000 * 16 / 9
//LIBRAW_IMAGE_ASPECT_6to6, // what is the difference with 1:1 ?
	libraw_image_aspect_5to4 = 1000 * 5 / 4
	libraw_image_aspect_7to6 = 1000 * 7 / 6
	libraw_image_aspect_6to5 = 1000 * 6 / 5
	libraw_image_aspect_7to5 = 1000 * 7 / 5
}

enum LibRaw_lens_focal_types {
	libraw_ft_undefined = 0
	libraw_ft_prime_lens = 1
	libraw_ft_zoom_lens = 2
	libraw_ft_zoom_lens_constant_aperture = 3
	libraw_ft_zoom_lens_variable_aperture = 4
}

enum LibRaw_Canon_RecordModes {
	libraw_canon_record_mode_undefined = 0
	libraw_canon_record_mode_jpeg
	libraw_canon_record_mode_crw_thm
	libraw_canon_record_mode_avi_thm
	libraw_canon_record_mode_tif
	libraw_canon_record_mode_tif_jpeg
	libraw_canon_record_mode_cr_2
	libraw_canon_record_mode_cr_2_jpeg
	libraw_canon_record_mode_unknown
	libraw_canon_record_mode_mov
	libraw_canon_record_mode_mp_4
	libraw_canon_record_mode_crm
	libraw_canon_record_mode_cr_3
	libraw_canon_record_mode_cr_3_jpeg
	libraw_canon_record_mode_heif
	libraw_canon_record_mode_cr_3_heif
	libraw_canon_record_mode_the_last_one
}

enum LibRaw_minolta_storagemethods {
	libraw_minolta_unpacked = 82
	libraw_minolta_packed = 89
}

enum LibRaw_minolta_bayerpatterns {
	libraw_minolta_rggb = 1
	libraw_minolta_g2_brg_1 = 4
}

enum LibRaw_sony_cameratypes {
	libraw_sony_dsc = 1
	libraw_sony_dslr = 2
	libraw_sony_nex = 3
	libraw_sony_slt = 4
	libraw_sony_ilce = 5
	libraw_sony_ilca = 6
	libraw_sony_camera_type_unknown = 65535
}

enum LibRaw_Sony_0x2010_Type {
	libraw_sony_tag2010_none = 0
	libraw_sony_tag2010a
	libraw_sony_tag2010b
	libraw_sony_tag2010c
	libraw_sony_tag2010d
	libraw_sony_tag2010e
	libraw_sony_tag2010f
	libraw_sony_tag2010g
	libraw_sony_tag2010h
	libraw_sony_tag2010i
}

enum LibRaw_Sony_0x9050_Type {
	libraw_sony_tag9050_none = 0
	libraw_sony_tag9050a
	libraw_sony_tag9050b
	libraw_sony_tag9050c
	libraw_sony_tag9050d
}

enum LIBRAW_SONY_FOCUSMODEmodes {
	libraw_sony_focusmode_mf = 0
	libraw_sony_focusmode_af_s = 2
	libraw_sony_focusmode_af_c = 3
	libraw_sony_focusmode_af_a = 4
	libraw_sony_focusmode_dmf = 6
	libraw_sony_focusmode_af_d = 7
	libraw_sony_focusmode_af = 101
	libraw_sony_focusmode_permanent_af = 104
	libraw_sony_focusmode_semi_mf = 105
	libraw_sony_focusmode_unknown = -1
}

enum LibRaw_KodakSensors {
	libraw_kodak_unknown_sensor = 0
	libraw_kodak_m1 = 1
	libraw_kodak_m15 = 2
	libraw_kodak_m16 = 3
	libraw_kodak_m17 = 4
	libraw_kodak_m2 = 5
	libraw_kodak_m23 = 6
	libraw_kodak_m24 = 7
	libraw_kodak_m3 = 8
	libraw_kodak_m5 = 9
	libraw_kodak_m6 = 10
	libraw_kodak_c14 = 11
	libraw_kodak_x14 = 12
	libraw_kodak_m11 = 13
}

enum LibRaw_HasselbladFormatCodes {
	libraw_hf_unknown = 0
	libraw_hf_3_fr
	libraw_hf_fff
	libraw_hf_imacon
	libraw_hf_hasselblad_dng
	libraw_hf_adobe_dng
	libraw_hf_adobe_dng_from_phocus_dng
}

enum LibRaw_rawspecial_t {
	libraw_rawspecial_sonyarw_2_none = 0
	libraw_rawspecial_sonyarw_2_baseonly = 1
	libraw_rawspecial_sonyarw_2_deltaonly = 1 << 1
	libraw_rawspecial_sonyarw_2_deltazerobase = 1 << 2
	libraw_rawspecial_sonyarw_2_deltatovalue = 1 << 3
	// libraw_rawspecial_sonyarw_2_allflags = libraw_rawspecial_sonyarw_2_baseonly + libraw_rawspecial_sonyarw_2_deltaonly + libraw_rawspecial_sonyarw_2_deltazerobase + libraw_rawspecial_sonyarw_2_deltatovalue
	libraw_rawspecial_nodp_2_q_interpolaterg = 1 << 4
	libraw_rawspecial_nodp_2_q_interpolateaf = 1 << 5
	libraw_rawspecial_sraw_no_rgb = 1 << 6
	libraw_rawspecial_sraw_no_interpolate = 1 << 7
}

enum LibRaw_rawspeed_bits_t {
	libraw_rawspeedv_1_use = 1
	libraw_rawspeedv_1_failonunknown = 1 << 1
	libraw_rawspeedv_1_ignoreerrors = 1 << 2
//  bits 3-7 are reserved
	libraw_rawspeedv_3_use = 1 << 8
	libraw_rawspeedv_3_failonunknown = 1 << 9
	libraw_rawspeedv_3_ignoreerrors = 1 << 10
}

enum LibRaw_processing_options {
	libraw_rawoptions_pentax_ps_allframes = 1
	libraw_rawoptions_convertfloat_to_int = 1 << 1
	libraw_rawoptions_arq_skip_channel_swap = 1 << 2
	libraw_rawoptions_no_rotate_for_kodak_thumbnails = 1 << 3
//  LIBRAW_RAWOPTIONS_USE_DNG_DEFAULT_CROP = 1 << 4,
	libraw_rawoptions_use_ppm_16_thumbs = 1 << 5
	libraw_rawoptions_dont_check_dng_illuminant = 1 << 6
	libraw_rawoptions_dngsdk_zerocopy = 1 << 7
	libraw_rawoptions_zerofilters_for_monochrometiffs = 1 << 8
	libraw_rawoptions_dng_add_enhanced = 1 << 9
	libraw_rawoptions_dng_add_previews = 1 << 10
	libraw_rawoptions_dng_prefer_largest_image = 1 << 11
	libraw_rawoptions_dng_stage_2 = 1 << 12
	libraw_rawoptions_dng_stage_3 = 1 << 13
	libraw_rawoptions_dng_allowsizechange = 1 << 14
	libraw_rawoptions_dng_disablewbadjust = 1 << 15
	libraw_rawoptions_provide_nonstandard_wb = 1 << 16
	libraw_rawoptions_camerawb_fallback_to_daylight = 1 << 17
	libraw_rawoptions_check_thumbnails_known_vendors = 1 << 18
	libraw_rawoptions_check_thumbnails_all_vendors = 1 << 19
	libraw_rawoptions_dng_stage_2_ifpresent = 1 << 20
	libraw_rawoptions_dng_stage_3_ifpresent = 1 << 21
	libraw_rawoptions_dng_add_masks = 1 << 22
	libraw_rawoptions_canon_ignore_makernotes_rotation = 1 << 23
	libraw_rawoptions_allow_jpegxl_previews = 1 << 24
}

enum LibRaw_decoder_flags {
	libraw_decoder_hascurve = 1 << 4
	libraw_decoder_sonyarw_2 = 1 << 5
	libraw_decoder_tryrawspeed = 1 << 6
	libraw_decoder_ownalloc = 1 << 7
	libraw_decoder_fixedmaxc = 1 << 8
	libraw_decoder_adobecopypixel = 1 << 9
	libraw_decoder_legacy_with_margins = 1 << 10
	libraw_decoder_3_channel = 1 << 11
	libraw_decoder_sinar_4_shot = 1 << 11
	libraw_decoder_flatdata = 1 << 12
	libraw_decoder_flat_bg_2_swapped = 1 << 13
	libraw_decoder_unsupported_format = 1 << 14
	libraw_decoder_notset = 1 << 15
	libraw_decoder_tryrawspeed_3 = 1 << 16
}

enum LibRaw_constructor_flags {
	libraw_options_none = 0
	libraw_options_no_dataerr_callback = 1 << 1
// Compatibility w/ years old typo 
	// libraw_opions_no_dataerr_callback = libraw_options_no_dataerr_callback
}

enum LibRaw_warnings {
	libraw_warn_none = 0
	libraw_warn_bad_camera_wb = 1 << 2
	libraw_warn_no_metadata = 1 << 3
	libraw_warn_no_jpeglib = 1 << 4
	libraw_warn_no_embedded_profile = 1 << 5
	libraw_warn_no_input_profile = 1 << 6
	libraw_warn_bad_output_profile = 1 << 7
	libraw_warn_no_badpixelmap = 1 << 8
	libraw_warn_bad_darkframe_file = 1 << 9
	libraw_warn_bad_darkframe_dim = 1 << 10
	libraw_warn_rawspeed_problem = 1 << 12
	libraw_warn_rawspeed_unsupported = 1 << 13
	libraw_warn_rawspeed_processed = 1 << 14
	libraw_warn_fallback_to_ahd = 1 << 15
	libraw_warn_parsefuji_processed = 1 << 16
	libraw_warn_dngsdk_processed = 1 << 17
	libraw_warn_dng_images_reordered = 1 << 18
	libraw_warn_dng_stage_2_applied = 1 << 19
	libraw_warn_dng_stage_3_applied = 1 << 20
	libraw_warn_rawspeed_3_problem = 1 << 21
	libraw_warn_rawspeed_3_unsupported = 1 << 22
	libraw_warn_rawspeed_3_processed = 1 << 23
	libraw_warn_rawspeed_3_notlisted = 1 << 24
	libraw_warn_vendor_crop_suggested = 1 << 25
}

enum LibRaw_exceptions {
	libraw_exception_none = 0
	libraw_exception_alloc = 1
	libraw_exception_decode_raw = 2
	libraw_exception_decode_jpeg = 3
	libraw_exception_io_eof = 4
	libraw_exception_io_corrupt = 5
	libraw_exception_cancelled_by_callback = 6
	libraw_exception_bad_crop = 7
	libraw_exception_io_badfile = 8
	libraw_exception_decode_jpeg_2000 = 9
	libraw_exception_toobig = 10
	libraw_exception_mempool = 11
	libraw_exception_unsupported_format = 12
}

enum LibRaw_progress {
	libraw_progress_start = 0
	libraw_progress_open = 1
	libraw_progress_identify = 1 << 1
	libraw_progress_size_adjust = 1 << 2
	libraw_progress_load_raw = 1 << 3
	libraw_progress_raw_2_image = 1 << 4
	libraw_progress_remove_zeroes = 1 << 5
	libraw_progress_bad_pixels = 1 << 6
	libraw_progress_dark_frame = 1 << 7
	libraw_progress_foveon_interpolate = 1 << 8
	libraw_progress_scale_colors = 1 << 9
	libraw_progress_pre_interpolate = 1 << 10
	libraw_progress_interpolate = 1 << 11
	libraw_progress_mix_green = 1 << 12
	libraw_progress_median_filter = 1 << 13
	libraw_progress_highlights = 1 << 14
	libraw_progress_fuji_rotate = 1 << 15
	libraw_progress_flip = 1 << 16
	libraw_progress_apply_profile = 1 << 17
	libraw_progress_convert_rgb = 1 << 18
	libraw_progress_stretch = 1 << 19
// reserved 
	libraw_progress_stage_20 = 1 << 20
	libraw_progress_stage_21 = 1 << 21
	libraw_progress_stage_22 = 1 << 22
	libraw_progress_stage_23 = 1 << 23
	libraw_progress_stage_24 = 1 << 24
	libraw_progress_stage_25 = 1 << 25
	libraw_progress_stage_26 = 1 << 26
	libraw_progress_stage_27 = 1 << 27
	libraw_progress_thumb_load = 1 << 28
	libraw_progress_treserved_1 = 1 << 29
	libraw_progress_treserved_2 = 1 << 30
}

enum LibRaw_errors {
	libraw_success = 0
	libraw_unspecified_error = -1
	libraw_file_unsupported = -2
	libraw_request_for_nonexistent_image = -3
	libraw_out_of_order_call = -4
	libraw_no_thumbnail = -5
	libraw_unsupported_thumbnail = -6
	libraw_input_closed = -7
	libraw_not_implemented = -8
	libraw_request_for_nonexistent_thumbnail = -9
	libraw_unsufficient_memory = -100007
	libraw_data_error = -100008
	libraw_io_error = -100009
	libraw_cancelled_by_callback = -100010
	libraw_bad_crop = -100011
	libraw_too_big = -100012
	libraw_mempool_overflow = -100013
}

enum LibRaw_internal_thumbnail_formats {
	libraw_internal_thumbnail_unknown = 0
	libraw_internal_thumbnail_kodak_thumb = 1
	libraw_internal_thumbnail_kodak_ycbcr = 2
	libraw_internal_thumbnail_kodak_rgb = 3
	libraw_internal_thumbnail_jpeg = 4
	libraw_internal_thumbnail_layer
	libraw_internal_thumbnail_rollei
	libraw_internal_thumbnail_ppm
	libraw_internal_thumbnail_ppm_16
	libraw_internal_thumbnail_x3_f
	libraw_internal_thumbnail_dng_ycbcr
	libraw_internal_thumbnail_jpegxl
}

enum LibRaw_thumbnail_formats {
	libraw_thumbnail_unknown = 0
	libraw_thumbnail_jpeg = 1
	libraw_thumbnail_bitmap = 2
	libraw_thumbnail_bitmap_16 = 3
	libraw_thumbnail_layer = 4
	libraw_thumbnail_rollei = 5
	libraw_thumbnail_h265 = 6
	libraw_thumbnail_jpegxl = 7
}

enum INT64 {
	libraw_image_jpeg = 1
	libraw_image_bitmap = 2
}

// -* C++ -*
// *File: libraw_types.h
// *Copyright 2008-2024 LibRaw LLC (info@libraw.org)
// *Created: Sat Mar  8 , 2008
// *
// *LibRaw C data structures
// *
//
//LibRaw is free software; you can redistribute it and/or modify
//it under the terms of the one of two licenses as you choose:
//
//1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
//   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
//
//2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
//   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
//
// 
// WIN32, but not old MSVC 
// _WIN32 
// VS2010+ : OpenMP works OK, VS2008: have tested by cgilles 
//  Have not tested on 9.x and 10.x, but Intel documentation claims OpenMP 2.5
// *support in 9.1 
// Not Win32 
// Latest XCode works with OpenMP, need to recheck here 
type UINT64 = i64
type Uchar = u8
type Ushort = u16
struct Libraw_decoder_info_t { 
	decoder_name &i8
	decoder_flags u32
}
struct Libraw_internal_output_params_t { 
	mix_green u32
	raw_color u32
	zero_is_bad u32
	shrink Ushort
	fuji_width Ushort
}
type Memory_callback = fn (voidptr, &i8, &i8)
type Exif_parser_callback = fn (voidptr, int, int, int, u32, voidptr, INT64)
type Data_callback = fn (voidptr, &i8, int)
type Progress_callback = fn (voidptr, Enum LibRaw_progress, int, int) int
type Pre_identify_callback = fn (voidptr) int
type Post_identify_callback = fn (voidptr)
type Process_step_callback = fn (voidptr)
struct Libraw_callbacks_t { 
	data_cb Data_callback
	datacb_data voidptr
	progress_cb Progress_callback
	progresscb_data voidptr
	exif_cb Exif_parser_callback
	exifparser_data voidptr
	pre_identify_cb Pre_identify_callback
	post_identify_cb Post_identify_callback
	pre_subtractblack_cb Process_step_callback
	pre_scalecolors_cb Process_step_callback
	pre_preinterpolate_cb Process_step_callback
	pre_interpolate_cb Process_step_callback
	interpolate_bayer_cb Process_step_callback
	interpolate_xtrans_cb Process_step_callback
	post_interpolate_cb Process_step_callback
	pre_converttorgb_cb Process_step_callback
	post_converttorgb_cb Process_step_callback
}
struct Libraw_processed_image_t { 
	// type_ LibRaw_image_formats
	height Ushort
	width Ushort
	colors Ushort
	bits Ushort
	data_size u32
	data [1]u8
}
struct Libraw_iparams_t { 
	guard [4]i8
	make [64]i8
	model [64]i8
	software [64]i8
	normalized_make [64]i8
	normalized_model [64]i8
	maker_index u32
	raw_count u32
	dng_version u32
	is_foveon u32
	colors int
	filters u32
	xtrans [6][6]i8
	xtrans_abs [6][6]i8
	cdesc [5]i8
	xmplen u32
	xmpdata &i8
}
struct Libraw_raw_inset_crop_t { 
	cleft Ushort
	ctop Ushort
	cwidth Ushort
	cheight Ushort
}
struct Libraw_image_sizes_t { 
	raw_height Ushort
	raw_width Ushort
	height Ushort
	width Ushort
	top_margin Ushort
	left_margin Ushort
	iheight Ushort
	iwidth Ushort
	raw_pitch u32
	pixel_aspect f64
	flip int
	mask [8][4]int
	raw_aspect Ushort
	raw_inset_crops [2]Libraw_raw_inset_crop_t
}
struct Libraw_area_t { 
	t i16
	l i16
	b i16
	r i16
// top, left, bottom, right pixel coordinates, (0,0) is top left pixel;
}
struct Ph1_t { 
	format int
	key_off int
	tag_21a int
	t_black int
	split_col int
	black_col int
	split_row int
	black_row int
	tag_210 f32
}
struct Libraw_dng_color_t { 
	parsedfields u32
	illuminant Ushort
	calibration [4][4]f32
	colormatrix [4][3]f32
	forwardmatrix [3][4]f32
}
struct Libraw_dng_levels_t { 
	parsedfields u32
	dng_cblack [4104]u32
	dng_black u32
	dng_fcblack [4104]f32
	dng_fblack f32
	dng_whitelevel [4]u32
	default_crop [4]Ushort
// Origin and size 
	user_crop [4]f32
// top-left-bottom-right relative to default_crop
	preview_colorspace u32
	analogbalance [4]f32
	asshotneutral [4]f32
	baseline_exposure f32
	linearResponseLimit f32
}
struct Libraw_P1_color_t { 
	romm_cam [9]f32
}
struct Libraw_canon_makernotes_t { 
	colorDataVer int
	colorDataSubVer int
	specularWhiteLevel int
	normalWhiteLevel int
	channelBlackLevel [4]int
	averageBlackLevel int
// multishot 
	multishot [4]u32
// metering 
	meteringMode i16
	spotMeteringMode i16
	flashMeteringMode Uchar
	flashExposureLock i16
	exposureMode i16
	aESetting i16
// stabilization 
	imageStabilization i16
// flash 
	flashMode i16
	flashActivity i16
	flashBits i16
	manualFlashOutput i16
	flashOutput i16
	flashGuideNumber i16
// drive 
	continuousDrive i16
// sensor 
	sensorWidth i16
	sensorHeight i16
	aFMicroAdjMode int
	aFMicroAdjValue f32
	makernotesFlip i16
	recordMode i16
	sRAWQuality i16
	wbi u32
	rF_lensID i16
	autoLightingOptimizer int
	highlightTonePriority int
// -1 = n/a            1 = Economy
//        2 = Normal         3 = Fine
//        4 = RAW            5 = Superfine
//        7 = CRAW         130 = Normal Movie, CRM LightRaw
//      131 = CRM  StandardRaw 
	quality i16
// data compression curve
//        0 = OFF  1 = CLogV1 2 = CLogV2? 3 = CLogV3 
	canonLog int
	defaultCropAbsolute Libraw_area_t
	recommendedImageArea Libraw_area_t
// contains the image in proper aspect ratio?
	leftOpticalBlack Libraw_area_t
// use this, when present, to estimate black levels?
	upperOpticalBlack Libraw_area_t
	activeArea Libraw_area_t
	iSOgain [2]i16
// AutoISO & BaseISO per ExifTool
}
struct Libraw_hasselblad_makernotes_t { 
	baseISO int
	gain f64
	sensor [8]i8
	sensorUnit [64]i8
// SU
	hostBody [64]i8
// HB
	sensorCode int
	sensorSubCode int
	coatingCode int
	uncropped int
// CaptureSequenceInitiator is based on the content of the 'model' tag
//  - values like 'Pinhole', 'Flash Sync', '500 Mech.' etc in .3FR 'model' tag
//    come from MAIN MENU > SETTINGS > Camera;
//  - otherwise 'model' contains:
//    1. if CF/CFV/CFH, SU enclosure, can be with SU type if '-' is present
//    2. else if '-' is present, HB + SU type;
//    3. HB;
//
	captureSequenceInitiator [32]i8
// SensorUnitConnector, makernotes 0x0015 tag:
// - in .3FR - SU side
// - in .FFF - HB side
//
	sensorUnitConnector [64]i8
	format int
// 3FR, FFF, Imacon (H3D-39 and maybe others), Hasselblad/Phocus DNG, Adobe DNG
	nIFD_CM [2]int
// number of IFD containing CM
	recommendedCrop [2]int
// mnColorMatrix is in makernotes tag 0x002a;
//  not present in .3FR files and Imacon/H3D-39 .FFF files;
//  when present in .FFF and Phocus .DNG files, it is a copy of CM1 from .3FR;
//  available samples contain all '1's in the first 3 elements
//
	mnColorMatrix [4][3]f64
}
struct Libraw_fuji_info_t { 
	expoMidPointShift f32
	dynamicRange Ushort
	filmMode Ushort
	dynamicRangeSetting Ushort
	developmentDynamicRange Ushort
	autoDynamicRange Ushort
	dRangePriority Ushort
	dRangePriorityAuto Ushort
	dRangePriorityFixed Ushort
	fujiModel [33]i8
	fujiModel2 [33]i8
//
//    tag 0x9200, converted to BrightnessCompensation
//    F700, S3Pro, S5Pro, S20Pro, S200EXR
//    E550, E900, F810, S5600, S6500fd, S9000, S9500, S100FS
//    
	brightnessCompensation f32
// in EV, if =4, raw data *2^4 
	focusMode Ushort
	aFMode Ushort
	focusPixel [2]Ushort
	prioritySettings Ushort
	focusSettings u32
	aF_C_Settings u32
	focusWarning Ushort
	imageStabilization [3]Ushort
	flashMode Ushort
	wB_Preset Ushort
// ShutterType:
//       0 - mechanical
//       1 = electronic
//       2 = electronic, long shutter speed
//       3 = electronic, front curtain
//    
	shutterType Ushort
	exrMode Ushort
	macro Ushort
	rating u32
// CropMode:
//       1 - FF on GFX,
//       2 - sports finder (mechanical shutter),
//       4 - 1.25x crop (electronic shutter, continuous high)
//    
	cropMode Ushort
	serialSignature [13]i8
	sensorID [5]i8
	rAFVersion [5]i8
	rAFDataGeneration int
// 0 (none), 1..4, 4096
	rAFDataVersion Ushort
	isTSNERDTS int
// DriveMode:
//       0 - single frame
//       1 - continuous low
//       2 - continuous high
//    
	driveMode i16
//
//    tag 0x4000 BlackLevel:
//    S9100, S9000, S7000, S6000fd, S5200, S5100, S5000,
//    S5Pro, S3Pro, S2Pro, S20Pro,
//    S200EXR, S100FS,
//    F810, F700,
//    E900, E550,
//    DBP, and aliases for all of the above
//    
	blackLevel [9]Ushort
	rAFData_ImageSizeTable [32]u32
	autoBracketing int
	sequenceNumber int
	seriesLength int
	pixelShiftOffset [2]f32
	imageCount int
}
struct Libraw_sensor_highspeed_crop_t { 
	cleft Ushort
	ctop Ushort
	cwidth Ushort
	cheight Ushort
}
struct Libraw_nikon_makernotes_t { 
	exposureBracketValue f64
	activeDLighting Ushort
	shootingMode Ushort
// stabilization 
	imageStabilization [7]Uchar
	vibrationReduction Uchar
	vRMode Uchar
// flash 
	flashSetting [13]i8
	flashType [20]i8
	flashExposureCompensation [4]Uchar
	externalFlashExposureComp [4]Uchar
	flashExposureBracketValue [4]Uchar
	flashMode Uchar
	flashExposureCompensation2 i8
	flashExposureCompensation3 i8
	flashExposureCompensation4 i8
	flashSource Uchar
	flashFirmware [2]Uchar
	externalFlashFlags Uchar
	flashControlCommanderMode Uchar
	flashOutputAndCompensation Uchar
	flashFocalLength Uchar
	flashGNDistance Uchar
	flashGroupControlMode [4]Uchar
	flashGroupOutputAndCompensation [4]Uchar
	flashColorFilter Uchar
// NEF compression, comments follow those for ExifTool tag 0x0093:
//	 1: Lossy (type 1)
//	 2: Uncompressed
//	 3: Lossless
//	 4: Lossy (type 2)
//	 5: Striped packed 12-bit
//	 6: Uncompressed (14-bit reduced to 12-bit)
//	 7: Unpacked 12-bit
//	 8: Small raw
//	 9: Packed 12-bit
//	10: Packed 14-bit
//	13: High Efficiency  (HE)
//	14: High Efficiency*(HE*
//
	nEFCompression Ushort
	exposureMode int
	exposureProgram int
	nMEshots int
	mEgainOn int
	mE_WB [4]f64
	aFFineTune Uchar
	aFFineTuneIndex Uchar
	aFFineTuneAdj u8
	lensDataVersion u32
	flashInfoVersion u32
	colorBalanceVersion u32
	key Uchar
	nEFBitDepth [4]Ushort
	highSpeedCropFormat Ushort
// 1 -> 1.3x; 2 -> DX; 3 -> 5:4; 4 -> 3:2; 6 ->
//                                   16:9; 11 -> FX uncropped; 12 -> DX uncropped;
//                                   17 -> 1:1 
	sensorHighSpeedCrop Libraw_sensor_highspeed_crop_t
	sensorWidth Ushort
	sensorHeight Ushort
	active_D_Lighting Ushort
	pictureControlVersion u32
	pictureControlName [20]i8
	pictureControlBase [20]i8
	shotInfoVersion u32
	makernotesFlip i16
	rollAngle f64
// positive is clockwise, CW
	pitchAngle f64
// positive is upwords
	yawAngle f64
// positive is to the right
}
struct Libraw_olympus_makernotes_t { 
	cameraType2 [6]i8
	validBits Ushort
	sensorCalibration [2]int
	driveMode [5]Ushort
	colorSpace Ushort
	focusMode [2]Ushort
	autoFocus Ushort
	aFPoint Ushort
	aFAreas [64]u32
	aFPointSelected [5]f64
	aFResult Ushort
	aFFineTune Uchar
	aFFineTuneAdj [3]i16
	specialMode [3]u32
	zoomStepCount Ushort
	focusStepCount Ushort
	focusStepInfinity Ushort
	focusStepNear Ushort
	focusDistance f64
	aspectFrame [4]Ushort
// left, top, width, height
	stackedImage [2]u32
	isLiveND Uchar
	liveNDfactor u32
	panorama_mode Ushort
	panorama_frameNum Ushort
}
struct Libraw_panasonic_makernotes_t { 
// Compression:
//     34826 (Panasonic RAW 2): LEICA DIGILUX 2;
//     34828 (Panasonic RAW 3): LEICA D-LUX 3; LEICA V-LUX 1; Panasonic DMC-LX1;
//     Panasonic DMC-LX2; Panasonic DMC-FZ30; Panasonic DMC-FZ50; 34830 (not in
//     exiftool): LEICA DIGILUX 3; Panasonic DMC-L1; 34316 (Panasonic RAW 1):
//     others (LEICA, Panasonic, YUNEEC);
//    
	compression Ushort
	blackLevelDim Ushort
	blackLevel [8]f32
	multishot u32
// 0 is Off, 65536 is Pixel Shift 
	gamma f32
	highISOMultiplier [3]int
// 0->R, 1->G, 2->B 
	focusStepNear i16
	focusStepCount i16
	zoomPosition u32
	lensManufacturer u32
}
struct Libraw_pentax_makernotes_t { 
	driveMode [4]Uchar
	focusMode [2]Ushort
	aFPointSelected [2]Ushort
	aFPointSelected_Area Ushort
	aFPointsInFocus_version int
	aFPointsInFocus u32
	focusPosition Ushort
	aFAdjustment i16
	aFPointMode Uchar
	multiExposure Uchar
// last bit is not "1" if ME is not used 
	quality Ushort
// 4 is raw, 7 is raw w/ pixel shift, 8 is raw w/ dynamic
//                       pixel shift 
}
struct Libraw_ricoh_makernotes_t { 
	aFStatus Ushort
	aFAreaXPosition [2]u32
	aFAreaYPosition [2]u32
	aFAreaMode Ushort
	sensorWidth u32
	sensorHeight u32
	croppedImageWidth u32
	croppedImageHeight u32
	wideAdapter Ushort
	cropMode Ushort
	nDFilter Ushort
	autoBracketing Ushort
	macroMode Ushort
	flashMode Ushort
	flashExposureComp f64
	manualFlashOutput f64
}
struct Libraw_samsung_makernotes_t { 
	imageSizeFull [4]u32
	imageSizeCrop [4]u32
	colorSpace [2]int
	key [11]u32
	digitalGain f64
// PostAEGain, digital stretch 
	deviceType int
	lensFirmware [32]i8
}
struct Libraw_kodak_makernotes_t { 
	blackLevelTop Ushort
	blackLevelBottom Ushort
	offset_left i16
	offset_top i16
// KDC files, negative values or zeros 
	clipBlack Ushort
	clipWhite Ushort
// valid for P712, P850, P880 
	romm_camDaylight [3][3]f32
	romm_camTungsten [3][3]f32
	romm_camFluorescent [3][3]f32
	romm_camFlash [3][3]f32
	romm_camCustom [3][3]f32
	romm_camAuto [3][3]f32
	val018percent Ushort
	val100percent Ushort
	val170percent Ushort
	makerNoteKodak8a i16
	iSOCalibrationGain f32
	analogISO f32
}
struct Libraw_p1_makernotes_t { 
	software [64]i8
// tag 0x0203
	systemType [64]i8
// tag 0x0204
	firmwareString [256]i8
// tag 0x0301
	systemModel [64]i8
}
struct Libraw_sony_info_t { 
// afdata:
//  0x0010 CameraInfo
//  0x2020 AFPointsUsed
//  0x2022 FocalPlaneAFPointsUsed
//  0x202a Tag202a
//  0x940e AFInfo
//
	cameraType Ushort
// init in 0xffff
	sony0x9400_version Uchar
// 0 if not found/deciphered,
//                                    0xa, 0xb, 0xc following exiftool convention 
	sony0x9400_ReleaseMode2 Uchar
	sony0x9400_SequenceImageNumber u32
	sony0x9400_SequenceLength1 Uchar
	sony0x9400_SequenceFileNumber u32
	sony0x9400_SequenceLength2 Uchar
	aFAreaModeSetting u8
// init in 0xff; +
	aFAreaMode u16
// init in 0xffff; +
	flexibleSpotPosition [2]Ushort
// init in (0xffff, 0xffff)
	aFPointSelected u8
// init in 0xff
	aFPointSelected_0x201e u8
// init in 0xff
	nAFPointsUsed i16
	aFPointsUsed [10]u8
	aFTracking u8
// init in 0xff
	aFType u8
	focusLocation [4]Ushort
	focusPosition Ushort
// init in 0xffff
	aFMicroAdjValue u8
// init in 0x7f
	aFMicroAdjOn u8
// init in -1
	aFMicroAdjRegisteredLenses Uchar
// init in 0xff
	variableLowPassFilter Ushort
	longExposureNoiseReduction u32
// init in 0xffffffff
	highISONoiseReduction Ushort
// init in 0xffff
	hDR [2]Ushort
	group2010 Ushort
	group9050 Ushort
	len_group9050 Ushort
// currently, for debugging only
	real_iso_offset Ushort
// init in 0xffff
	meteringMode_offset Ushort
	exposureProgram_offset Ushort
	releaseMode2_offset Ushort
	minoltaCamID u32
// init in 0xffffffff
	firmware f32
	imageCount3_offset Ushort
// init in 0xffff
	imageCount3 u32
	electronicFrontCurtainShutter u32
// init in 0xffffffff
	meteringMode2 Ushort
	sonyDateTime [20]i8
	shotNumberSincePowerUp u32
	pixelShiftGroupPrefix Ushort
	pixelShiftGroupID u32
	nShotsInPixelShiftGroup i8
	numInPixelShiftGroup i8
// '0' if ARQ, first shot in the group has '1'
//                                  here 
	prd_ImageHeight Ushort
	prd_ImageWidth Ushort
	prd_Total_bps Ushort
	prd_Active_bps Ushort
	prd_StorageMethod Ushort
// 82 -> Padded; 89 -> Linear 
	prd_BayerPattern Ushort
// 0 -> not valid; 1 -> RGGB; 4 -> GBRG 
	sonyRawFileType Ushort
// init in 0xffff
//                               valid for ARW 2.0 and up (FileFormat >= 3000)
//                               takes precedence over RAWFileType and Quality:
//                               0  for uncompressed 14-bit raw
//                               1  for uncompressed 12-bit raw
//                               2  for compressed raw (lossy)
//                               3  for lossless compressed raw
//                               4  for lossless compressed raw v.2 (ILCE-1)
//                            
	rAWFileType Ushort
// init in 0xffff
//                               takes precedence over Quality
//                               0 for compressed raw,
//                               1 for uncompressed;
//                               2 lossless compressed raw v.2
//                            
	rawSizeType Ushort
// init in 0xffff
//                               1 - large,
//                               2 - small,
//                               3 - medium
//                            
	quality u32
// init in 0xffffffff
//                               0 or 6 for raw, 7 or 8 for compressed raw 
	fileFormat Ushort
//  1000 SR2
//                                2000 ARW 1.0
//                                3000 ARW 2.0
//                                3100 ARW 2.1
//                                3200 ARW 2.2
//                                3300 ARW 2.3
//                                3310 ARW 2.3.1
//                                3320 ARW 2.3.2
//                                3330 ARW 2.3.3
//                                3350 ARW 2.3.5
//                                4000 ARW 4.0
//                                4010 ARW 4.0.1
//                             
	metaVersion [16]i8
	aspectRatio f32
}
struct Libraw_colordata_t { 
	curve [65536]Ushort
	cblack [4104]u32
	black u32
	data_maximum u32
	maximum u32
// Canon (SpecularWhiteLevel)
// Kodak (14N, 14nx, SLR/c/n, DCS720X, DCS760C, DCS760M, ProBack, ProBack645, P712, P880, P850)
// Olympus, except:
//	C5050Z, C5060WZ, C7070WZ, C8080WZ
//	SP350, SP500UZ, SP510UZ, SP565UZ
//	E-10, E-20
//	E-300, E-330, E-400, E-410, E-420, E-450, E-500, E-510, E-520
//	E-1, E-3
//	XZ-1
// Panasonic
// Pentax
// Sony
// and aliases of the above
// DNG
	linear_max [4]int
	fmaximum f32
	fnorm f32
	white [8][8]Ushort
	cam_mul [4]f32
	pre_mul [4]f32
	cmatrix [3][4]f32
	ccm [3][4]f32
	rgb_cam [3][4]f32
	cam_xyz [4][3]f32
	phase_one_data Ph1_t
	flash_used f32
	canon_ev f32
	model2 [64]i8
	uniqueCameraModel [64]i8
	localizedCameraModel [64]i8
	imageUniqueID [64]i8
	rawDataUniqueID [17]i8
	originalRawFileName [64]i8
	profile voidptr
	profile_length u32
	black_stat [8]u32
	dng_color [2]Libraw_dng_color_t
	dng_levels Libraw_dng_levels_t
	wB_Coeffs [256][4]int
// R, G1, B, G2 coeffs 
	wBCT_Coeffs [64][5]f32
// CCT, than R, G1, B, G2 coeffs 
	as_shot_wb_applied int
	p1_color [2]Libraw_P1_color_t
	raw_bps u32
// for Phase One: raw format; For other cameras: bits per pixel (copy of tiff_bps in most cases) 
// Phase One raw format values, makernotes tag 0x010e:
//                      0    Name unknown
//                      1    "RAW 1"
//                      2    "RAW 2"
//                      3    "IIQ L" (IIQ L14)
//                      4    Never seen
//                      5    "IIQ S"
//                      6    "IIQ Sv2" (S14 / S14+)
//                      7    Never seen
//                      8    "IIQ L16" (IIQ L16EX / IIQ L16)
//                      
	exifColorSpace int
}
struct Libraw_thumbnail_t { 
	tformat LibRaw_thumbnail_formats
	twidth Ushort
	theight Ushort
	tlength u32
	tcolors int
	thumb &i8
}
struct Libraw_thumbnail_item_t { 
	tformat LibRaw_internal_thumbnail_formats
	twidth Ushort
	theight Ushort
	tflip Ushort
	tlength u32
	tmisc u32
	toffset INT64
}
struct Libraw_thumbnail_list_t { 
	thumbcount int
	thumblist [8]Libraw_thumbnail_item_t
}
struct Libraw_gps_info_t { 
	latitude [3]f32
// Deg,min,sec 
	longitude [3]f32
// Deg,min,sec 
	gpstimestamp [3]f32
// Deg,min,sec 
	altitude f32
	altref i8
	latref i8
	longref i8
	gpsstatus i8
	gpsparsed i8
}
struct Libraw_imgother_t { 
	iso_speed f32
	shutter f32
	aperture f32
	focal_len f32
	// timestamp Time_t
	shot_order u32
	gpsdata [32]u32
	parsed_gps Libraw_gps_info_t
	desc [512]i8
	artist [64]i8
	analogbalance [4]f32
}
struct Libraw_afinfo_item_t { 
	aFInfoData_tag u32
	aFInfoData_order i16
	aFInfoData_version u32
	aFInfoData_length u32
	aFInfoData &Uchar
}
struct Libraw_metadata_common_t { 
	flashEC f32
	flashGN f32
	cameraTemperature f32
	sensorTemperature f32
	sensorTemperature2 f32
	lensTemperature f32
	ambientTemperature f32
	batteryTemperature f32
	exifAmbientTemperature f32
	exifHumidity f32
	exifPressure f32
	exifWaterDepth f32
	exifAcceleration f32
	exifCameraElevationAngle f32
	real_ISO f32
	exifExposureIndex f32
	colorSpace Ushort
	firmware [128]i8
	exposureCalibrationShift f32
	afdata [4]Libraw_afinfo_item_t
	afcount int
}
struct Libraw_output_params_t { 
	greybox [4]u32
// -A  x1 y1 x2 y2 
	cropbox [4]u32
// -B x1 y1 x2 y2 
	aber [4]f64
// -C 
	gamm [6]f64
// -g 
	user_mul [4]f32
// -r mul0 mul1 mul2 mul3 
	bright f32
// -b 
	threshold f32
// -n 
	half_size int
// -h 
	four_color_rgb int
// -f 
	highlight int
// -H 
	use_auto_wb int
// -a 
	use_camera_wb int
// -w 
	use_camera_matrix int
// +M/-M 
	output_color int
// -o 
	output_profile &i8
// -o 
	camera_profile &i8
// -p 
	bad_pixels &i8
// -P 
	dark_frame &i8
// -K 
	output_bps int
// -4 
	output_tiff int
// -T 
	output_flags int
	user_flip int
// -t 
	user_qual int
// -q 
	user_black int
// -k 
	user_cblack [4]int
	user_sat int
// -S 
	med_passes int
// -m 
	auto_bright_thr f32
	adjust_maximum_thr f32
	no_auto_bright int
// -W 
	use_fuji_rotate int
// -j 
	use_p1_correction int
	green_matching int
// DCB parameters 
	dcb_iterations int
	dcb_enhance_fl int
	fbdd_noiserd int
	exp_correc int
	exp_shift f32
	exp_preser f32
// Disable Auto-scale 
	no_auto_scale int
// Disable intepolation 
	no_interpolation int
}
struct Libraw_raw_unpack_params_t { 
// Raw speed 
	use_rawspeed int
// DNG SDK 
	use_dngsdk int
	options u32
	shot_select u32
// -s 
	specials u32
	max_raw_memory_mb u32
	sony_arw2_posterization_thr int
// Nikon Coolscan 
	coolscan_nef_gamma f32
	p4shot_order [5]i8
// Custom camera list 
	custom_camera_strings &&u8
}
struct Libraw_rawdata_t { 
// really allocated bitmap 
	raw_alloc voidptr
// alias to single_channel variant 
	raw_image &Ushort
// alias to 4-channel variant 
	color4_image [4]fn () Ushort
// alias to 3-color variand decoded by RawSpeed 
	color3_image [3]fn () Ushort
// float bayer 
	float_image &f32
// float 3-component 
	float3_image [3]fn () f32
// float 4-component 
	float4_image [4]fn () f32
// Phase One black level data; 
	ph1_cblack [2]fn () i16
	ph1_rblack [2]fn () i16
// save color and sizes here, too.... 
	iparams Libraw_iparams_t
	sizes Libraw_image_sizes_t
	ioparams Libraw_internal_output_params_t
	color Libraw_colordata_t
}
struct Libraw_makernotes_lens_t { 
	lensID i64
	lens [128]i8
	lensFormat Ushort
// to characterize the image circle the lens covers 
	lensMount Ushort
// 'male', lens itself 
	camID i64
	cameraFormat Ushort
// some of the sensor formats 
	cameraMount Ushort
// 'female', body throat 
	body [64]i8
	focalType i16
// -1/0 is unknown; 1 is fixed focal; 2 is zoom 
	lensFeatures_pre [16]i8
	lensFeatures_suf [16]i8
	minFocal f32
	maxFocal f32
	maxAp4MinFocal f32
	maxAp4MaxFocal f32
	minAp4MinFocal f32
	minAp4MaxFocal f32
	maxAp f32
	minAp f32
	curFocal f32
	curAp f32
	maxAp4CurFocal f32
	minAp4CurFocal f32
	minFocusDistance f32
	focusRangeIndex f32
	lensFStops f32
	teleconverterID i64
	teleconverter [128]i8
	adapterID i64
	adapter [128]i8
	attachmentID i64
	attachment [128]i8
	focalUnits Ushort
	focalLengthIn35mmFormat f32
}
struct Libraw_nikonlens_t { 
	effectiveMaxAp f32
	lensIDNumber Uchar
	lensFStops Uchar
	mCUVersion Uchar
	lensType Uchar
}
struct Libraw_dnglens_t { 
	minFocal f32
	maxFocal f32
	maxAp4MinFocal f32
	maxAp4MaxFocal f32
}
struct Libraw_lensinfo_t { 
	minFocal f32
	maxFocal f32
	maxAp4MinFocal f32
	maxAp4MaxFocal f32
	eXIF_MaxAp f32
	lensMake [128]i8
	lens [128]i8
	lensSerial [128]i8
	internalLensSerial [128]i8
	focalLengthIn35mmFormat Ushort
	nikon Libraw_nikonlens_t
	dng Libraw_dnglens_t
	makernotes Libraw_makernotes_lens_t
}
struct Libraw_makernotes_t { 
	canon Libraw_canon_makernotes_t
	nikon Libraw_nikon_makernotes_t
	hasselblad Libraw_hasselblad_makernotes_t
	fuji Libraw_fuji_info_t
	olympus Libraw_olympus_makernotes_t
	sony Libraw_sony_info_t
	kodak Libraw_kodak_makernotes_t
	panasonic Libraw_panasonic_makernotes_t
	pentax Libraw_pentax_makernotes_t
	phaseone Libraw_p1_makernotes_t
	ricoh Libraw_ricoh_makernotes_t
	samsung Libraw_samsung_makernotes_t
	common Libraw_metadata_common_t
}
struct Libraw_shootinginfo_t { 
	driveMode i16
	focusMode i16
	meteringMode i16
	aFPoint i16
	exposureMode i16
	exposureProgram i16
	imageStabilization i16
	bodySerial [64]i8
	internalBodySerial [64]i8
// this may be PCB or sensor serial, depends on
//                                    make/model 
}
struct Libraw_custom_camera_t { 
	fsize u32
	rw Ushort
	rh Ushort
	lm Uchar
	tm Uchar
	rm Uchar
	bm Uchar
	lf Ushort
	cf Uchar
	max Uchar
	flags Uchar
	t_make [10]i8
	t_model [20]i8
	offset Ushort
}
struct Libraw_data_t { 
	image [4]fn () Ushort
	sizes Libraw_image_sizes_t
	idata Libraw_iparams_t
	lens Libraw_lensinfo_t
	makernotes Libraw_makernotes_t
	shootinginfo Libraw_shootinginfo_t
	params Libraw_output_params_t
	rawparams Libraw_raw_unpack_params_t
	progress_flags u32
	process_warnings u32
	color Libraw_colordata_t
	other Libraw_imgother_t
	thumbnail Libraw_thumbnail_t
	thumbs_list Libraw_thumbnail_list_t
	rawdata Libraw_rawdata_t
	parent_class voidptr
}
struct Fuji_q_table { 
	q_table &u8
// quantization table 
	raw_bits int
	total_values int
	max_grad int
// sdp val
	q_grad_mult int
// quant_gradient multiplier
	q_base int
}
struct Fuji_compressed_params { 
	qt [4]Fuji_q_table
	buf voidptr
	max_bits int
	min_value int
	max_value int
// q_point[4]
	line_width Ushort
}
// Byte order 
// -* C++ -*
// *File: libraw_internal.h
// *Copyright 2008-2024 LibRaw LLC (info@libraw.org)
// *Created: Sat Mar  8 , 2008
// *
// *LibRaw internal data structures (not visible outside)
//
//LibRaw is free software; you can redistribute it and/or modify
//it under the terms of the one of two licenses as you choose:
//
//1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
//   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
//
//2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
//   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
//
// 
// __cplusplus 
struct Internal_data_t { 
	input &LibRaw_abstract_datastream
	output &C.FILE
	input_internal int
	meta_data &i8
	profile_offset INT64
	toffset INT64
	pana_black [4]u32
}
struct Output_data_t { 
	histogram [8192]fn () int
	oprof &u32
}
struct Identify_data_t { 
	olympus_exif_cfa u32
	unique_id i64
	olyID i64
	tiff_nifds u32
	tiff_flip int
	metadata_blocks int
}
struct Crx_sample_to_chunk_t { 
	first u32
	count u32
	id u32
}
// contents of tag CMP1 for relevant track in CR3 file
struct Crx_data_header_t { 
	version int
	f_width int
	f_height int
	tileWidth int
	tileHeight int
	nBits int
	nPlanes int
	cfaLayout int
	encType int
	imageLevels int
	hasTileCols int
	hasTileRows int
	mdatHdrSize int
	medianBits int
// Not from header, but from datastream
	mediaSize u32
	mediaOffset INT64
	mediaType u32
// 1 -> /C/RAW, 2-> JPEG, 3-> CTMD metadata
	stsc_data &Crx_sample_to_chunk_t
// samples to chunk 
	stsc_count u32
	sample_count u32
	sample_size u32
// zero if not fixed sample size 
	sample_sizes &int
	chunk_count u32
	chunk_offsets &INT64
}
struct Pana8_tags_t { 
	tag39 [6]u32
	tag3A [6]u16
	tag3B u16
	initial [4]u16
	tag40a [17]u16
	tag40b [17]u16
	tag41 [17]u16
	stripe_count u16
// 0x42
	tag43 u16
	stripe_offsets [5]INT64
//0x44
	stripe_left [5]u16
// 0x45
	stripe_compressed_size [5]u32
//0x46
	stripe_width [5]u16
//0x47
	stripe_height [5]u16
}
struct Unpacker_data_t { 
	order i16
	sraw_mul [4]Ushort
	cr2_slice [3]Ushort
	kodak_cbpp u32
	strip_offset INT64
	data_offset INT64
	meta_offset INT64
	exif_offset INT64
	exif_subdir_offset INT64
	ifd0_offset INT64
	data_size u32
	meta_length u32
	cr3_exif_length u32
	cr3_ifd0_length u32
	thumb_misc u32
	thumb_format LibRaw_internal_thumbnail_formats
	fuji_layout u32
	tiff_samples u32
	tiff_bps u32
	tiff_compress u32
	tiff_sampleformat u32
	zero_after_ff u32
	tile_width u32
	tile_length u32
	load_flags u32
	data_error u32
	hasselblad_parser_flag int
	posRAFData i64
	lenRAFData u32
	fuji_total_lines int
	fuji_total_blocks int
	fuji_block_width int
	fuji_bits int
	fuji_raw_type int
	fuji_lossless int
	pana_encoding int
	pana_bpp int
	pana8 Pana8_tags_t
	crx_header [16]Crx_data_header_t
	crx_track_selected int
	crx_track_count int
	cR3_CTMDtag i16
	cR3_Version i16
	cM_found int
	is_NikonTransfer u32
	is_Olympus u32
	olympusDNG_SubDirOffsetValid int
	is_Sony u32
	is_pana_raw u32
	is_PentaxRicohMakernotes u32
// =1 for Ricoh software by Pentax, Camera DNG 
	dng_frames [20]u32
// bits: 0-7: shot_select, 8-15: IFD#, 16-31: low 16 bit of newsubfile type 
	raw_stride u16
}
struct Libraw_internal_data_t { 
	internal_data Internal_data_t
	internal_output_params Libraw_internal_output_params_t
	output_data Output_data_t
	identify_data Identify_data_t
	unpacker_data Unpacker_data_t
}
struct Decode { 
	branch [2]&Decode
	leaf int
}
struct Tiff_ifd_t { 
	t_width int
	t_height int
	bps int
	comp int
	phint int
	offset int
	t_flip int
	samples int
	bytes int
	extrasamples int
	t_tile_width int
	t_tile_length int
	sample_format int
	predictor int
	rows_per_strip int
	strip_offsets &int
	strip_offsets_count int
	strip_byte_counts &int
	strip_byte_counts_count int
	t_filters u32
	t_vwidth int
	t_vheight int
	t_lm int
	t_tm int
	t_fuji_width int
	t_shutter f32
// Per-IFD DNG fields 
	opcode2_offset INT64
	lineartable_offset INT64
	lineartable_len int
	dng_color [2]Libraw_dng_color_t
	dng_levels Libraw_dng_levels_t
	newsubfiletype int
}
struct Jhead { 
	algo int
	bits int
	high int
	wide int
	clrs int
	sraw int
	psv int
	restart int
	vpred [6]int
	quant [64]Ushort
	idct [64]Ushort
	huff [20]&Ushort
	// c.free [20]&Ushort
	// row &Ushort
}
struct Libraw_tiff_tag { 
	// tag Ushort
	// type_ Ushort
	count int
	// val Union (unnamed union at C
}
struct Tiff_hdr { 
	t_order Ushort
	magic Ushort
	ifd int
	pad Ushort
	ntag Ushort
	tag [23]Libraw_tiff_tag
	nextifd int
	pad2 Ushort
	nexif Ushort
	exif [4]Libraw_tiff_tag
	pad3 Ushort
	ngps Ushort
	gpst [10]Libraw_tiff_tag
	bps [4]i16
	rat [10]int
	gps [26]u32
	t_desc [512]i8
	t_make [64]i8
	t_model [64]i8
	soft [32]i8
	date [20]i8
	t_artist [64]i8
}
// -* C++ -*
// *File: libraw.h
// *Copyright 2008-2024 LibRaw LLC (info@libraw.org)
// *Created: Sat Mar  8, 2008
// *
// *LibRaw C++ interface
// *
//
//LibRaw is free software; you can redistribute it and/or modify
//it under the terms of the one of two licenses as you choose:
//
//1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1
//   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).
//
//2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0
//   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).
//
//
// maximum file size to use LibRaw_file_datastream (fully buffered) I/O 
// better WIN32 defines 
// better WIN32 defines 
// Win32 API 
// DLLs: Microsoft or Intel compiler 
// wchar_t*API for std::filebuf 
fn C.libraw_strerror(errorcode int) &i8

pub fn libraw_strerror(errorcode int) &i8 {
	return C.libraw_strerror(errorcode)
}

fn C.libraw_strprogress(arg0 LibRaw_progress) &i8

pub fn libraw_strprogress(arg0 LibRaw_progress) &i8 {
	return C.libraw_strprogress(arg0)
}

// LibRaw C API 
fn C.libraw_init(flags u32) &Libraw_data_t

pub fn libraw_init(flags u32) &Libraw_data_t {
	return C.libraw_init(flags)
}

fn C.libraw_open_file(arg0 &Libraw_data_t, arg1 &i8) int

pub fn libraw_open_file(arg0 &Libraw_data_t, arg1 &i8) int {
	return C.libraw_open_file(arg0, arg1)
}

fn C.libraw_open_wfile(arg0 &Libraw_data_t, arg1 &Wchar_t) int

pub fn libraw_open_wfile(arg0 &Libraw_data_t, arg1 &Wchar_t) int {
	return C.libraw_open_wfile(arg0, arg1)
}

fn C.libraw_open_buffer(arg0 &Libraw_data_t, buffer voidptr, size usize) int

pub fn libraw_open_buffer(arg0 &Libraw_data_t, buffer voidptr, size usize) int {
	return C.libraw_open_buffer(arg0, buffer, size)
}

fn C.libraw_open_bayer(lr &Libraw_data_t, data &u8, datalen u32, _raw_width Ushort, _raw_height Ushort, _left_margin Ushort, _top_margin Ushort, _right_margin Ushort, _bottom_margin Ushort, procflags u8, bayer_battern u8, unused_bits u32, otherflags u32, black_level u32) int

pub fn libraw_open_bayer(lr &Libraw_data_t, data &u8, datalen u32, _raw_width Ushort, _raw_height Ushort, _left_margin Ushort, _top_margin Ushort, _right_margin Ushort, _bottom_margin Ushort, procflags u8, bayer_battern u8, unused_bits u32, otherflags u32, black_level u32) int {
	return C.libraw_open_bayer(lr, data, datalen, _raw_width, _raw_height, _left_margin, _top_margin, _right_margin, _bottom_margin, procflags, bayer_battern, unused_bits, otherflags, black_level)
}

fn C.libraw_unpack(arg0 &Libraw_data_t) int

pub fn libraw_unpack(arg0 &Libraw_data_t) int {
	return C.libraw_unpack(arg0)
}

fn C.libraw_unpack_thumb(arg0 &Libraw_data_t) int

pub fn libraw_unpack_thumb(arg0 &Libraw_data_t) int {
	return C.libraw_unpack_thumb(arg0)
}

fn C.libraw_unpack_thumb_ex(arg0 &Libraw_data_t, arg1 int) int

pub fn libraw_unpack_thumb_ex(arg0 &Libraw_data_t, arg1 int) int {
	return C.libraw_unpack_thumb_ex(arg0, arg1)
}

fn C.libraw_recycle_datastream(arg0 &Libraw_data_t)

pub fn libraw_recycle_datastream(arg0 &Libraw_data_t) {
	C.libraw_recycle_datastream(arg0)
}

fn C.libraw_recycle(arg0 &Libraw_data_t)

pub fn libraw_recycle(arg0 &Libraw_data_t) {
	C.libraw_recycle(arg0)
}

fn C.libraw_close(arg0 &Libraw_data_t)

pub fn libraw_close(arg0 &Libraw_data_t) {
	C.libraw_close(arg0)
}

fn C.libraw_subtract_black(arg0 &Libraw_data_t)

pub fn libraw_subtract_black(arg0 &Libraw_data_t) {
	C.libraw_subtract_black(arg0)
}

fn C.libraw_raw2image(arg0 &Libraw_data_t) int

pub fn libraw_raw2image(arg0 &Libraw_data_t) int {
	return C.libraw_raw2image(arg0)
}

fn C.libraw_free_image(arg0 &Libraw_data_t)

pub fn libraw_free_image(arg0 &Libraw_data_t) {
	C.libraw_free_image(arg0)
}

// version helpers 
fn C.libraw_version() &i8

pub fn libraw_version() &i8 {
	return C.libraw_version()
}

fn C.libraw_versionNumber() int

pub fn libraw_version_number() int {
	return C.libraw_versionNumber()
}

// Camera list 
fn C.libraw_cameraList() &&u8

pub fn libraw_camera_list() &&u8 {
	return C.libraw_cameraList()
}

fn C.libraw_cameraCount() int

pub fn libraw_camera_count() int {
	return C.libraw_cameraCount()
}

// helpers 
fn C.libraw_set_exifparser_handler(arg0 &Libraw_data_t, cb Exif_parser_callback, datap voidptr)

pub fn libraw_set_exifparser_handler(arg0 &Libraw_data_t, cb Exif_parser_callback, datap voidptr) {
	C.libraw_set_exifparser_handler(arg0, cb, datap)
}

fn C.libraw_set_dataerror_handler(arg0 &Libraw_data_t, func Data_callback, datap voidptr)

pub fn libraw_set_dataerror_handler(arg0 &Libraw_data_t, func Data_callback, datap voidptr) {
	C.libraw_set_dataerror_handler(arg0, func, datap)
}

fn C.libraw_set_progress_handler(arg0 &Libraw_data_t, cb Progress_callback, datap voidptr)

pub fn libraw_set_progress_handler(arg0 &Libraw_data_t, cb Progress_callback, datap voidptr) {
	C.libraw_set_progress_handler(arg0, cb, datap)
}

fn C.libraw_unpack_function_name(lr &Libraw_data_t) &i8

pub fn libraw_unpack_function_name(lr &Libraw_data_t) &i8 {
	return C.libraw_unpack_function_name(lr)
}

fn C.libraw_get_decoder_info(lr &Libraw_data_t, d &Libraw_decoder_info_t) int

pub fn libraw_get_decoder_info(lr &Libraw_data_t, d &Libraw_decoder_info_t) int {
	return C.libraw_get_decoder_info(lr, d)
}

fn C.libraw_COLOR(arg0 &Libraw_data_t, row int, col int) int

pub fn libraw_color(arg0 &Libraw_data_t, row int, col int) int {
	return C.libraw_COLOR(arg0, row, col)
}

fn C.libraw_capabilities() u32

pub fn libraw_capabilities() u32 {
	return C.libraw_capabilities()
}

fn C.libraw_adjust_to_raw_inset_crop(lr &Libraw_data_t, mask u32, maxcrop f32) int

pub fn libraw_adjust_to_raw_inset_crop(lr &Libraw_data_t, mask u32, maxcrop f32) int {
	return C.libraw_adjust_to_raw_inset_crop(lr, mask, maxcrop)
}

// DCRAW compatibility 
fn C.libraw_adjust_sizes_info_only(arg0 &Libraw_data_t) int

pub fn libraw_adjust_sizes_info_only(arg0 &Libraw_data_t) int {
	return C.libraw_adjust_sizes_info_only(arg0)
}

fn C.libraw_dcraw_ppm_tiff_writer(lr &Libraw_data_t, filename &i8) int

pub fn libraw_dcraw_ppm_tiff_writer(lr &Libraw_data_t, filename &i8) int {
	return C.libraw_dcraw_ppm_tiff_writer(lr, filename)
}

fn C.libraw_dcraw_thumb_writer(lr &Libraw_data_t, fname &i8) int

pub fn libraw_dcraw_thumb_writer(lr &Libraw_data_t, fname &i8) int {
	return C.libraw_dcraw_thumb_writer(lr, fname)
}

fn C.libraw_dcraw_process(lr &Libraw_data_t) int

pub fn libraw_dcraw_process(lr &Libraw_data_t) int {
	return C.libraw_dcraw_process(lr)
}

fn C.libraw_dcraw_make_mem_image(lr &Libraw_data_t, errc &int) &Libraw_processed_image_t

pub fn libraw_dcraw_make_mem_image(lr &Libraw_data_t, errc &int) &Libraw_processed_image_t {
	return C.libraw_dcraw_make_mem_image(lr, errc)
}

fn C.libraw_dcraw_make_mem_thumb(lr &Libraw_data_t, errc &int) &Libraw_processed_image_t

pub fn libraw_dcraw_make_mem_thumb(lr &Libraw_data_t, errc &int) &Libraw_processed_image_t {
	return C.libraw_dcraw_make_mem_thumb(lr, errc)
}

fn C.libraw_dcraw_clear_mem(arg0 &Libraw_processed_image_t)

pub fn libraw_dcraw_clear_mem(arg0 &Libraw_processed_image_t) {
	C.libraw_dcraw_clear_mem(arg0)
}

// getters/setters used by 3DLut Creator 
fn C.libraw_set_demosaic(lr &Libraw_data_t, value int)

pub fn libraw_set_demosaic(lr &Libraw_data_t, value int) {
	C.libraw_set_demosaic(lr, value)
}

fn C.libraw_set_output_color(lr &Libraw_data_t, value int)

pub fn libraw_set_output_color(lr &Libraw_data_t, value int) {
	C.libraw_set_output_color(lr, value)
}

fn C.libraw_set_adjust_maximum_thr(lr &Libraw_data_t, value f32)

pub fn libraw_set_adjust_maximum_thr(lr &Libraw_data_t, value f32) {
	C.libraw_set_adjust_maximum_thr(lr, value)
}

fn C.libraw_set_user_mul(lr &Libraw_data_t, index int, val f32)

pub fn libraw_set_user_mul(lr &Libraw_data_t, index int, val f32) {
	C.libraw_set_user_mul(lr, index, val)
}

fn C.libraw_set_output_bps(lr &Libraw_data_t, value int)

pub fn libraw_set_output_bps(lr &Libraw_data_t, value int) {
	C.libraw_set_output_bps(lr, value)
}

fn C.libraw_set_gamma(lr &Libraw_data_t, index int, value f32)

pub fn libraw_set_gamma(lr &Libraw_data_t, index int, value f32) {
	C.libraw_set_gamma(lr, index, value)
}

fn C.libraw_set_no_auto_bright(lr &Libraw_data_t, value int)

pub fn libraw_set_no_auto_bright(lr &Libraw_data_t, value int) {
	C.libraw_set_no_auto_bright(lr, value)
}

fn C.libraw_set_bright(lr &Libraw_data_t, value f32)

pub fn libraw_set_bright(lr &Libraw_data_t, value f32) {
	C.libraw_set_bright(lr, value)
}

fn C.libraw_set_highlight(lr &Libraw_data_t, value int)

pub fn libraw_set_highlight(lr &Libraw_data_t, value int) {
	C.libraw_set_highlight(lr, value)
}

fn C.libraw_set_fbdd_noiserd(lr &Libraw_data_t, value int)

pub fn libraw_set_fbdd_noiserd(lr &Libraw_data_t, value int) {
	C.libraw_set_fbdd_noiserd(lr, value)
}

fn C.libraw_get_raw_height(lr &Libraw_data_t) int

pub fn libraw_get_raw_height(lr &Libraw_data_t) int {
	return C.libraw_get_raw_height(lr)
}

fn C.libraw_get_raw_width(lr &Libraw_data_t) int

pub fn libraw_get_raw_width(lr &Libraw_data_t) int {
	return C.libraw_get_raw_width(lr)
}

fn C.libraw_get_iheight(lr &Libraw_data_t) int

pub fn libraw_get_iheight(lr &Libraw_data_t) int {
	return C.libraw_get_iheight(lr)
}

fn C.libraw_get_iwidth(lr &Libraw_data_t) int

pub fn libraw_get_iwidth(lr &Libraw_data_t) int {
	return C.libraw_get_iwidth(lr)
}

fn C.libraw_get_cam_mul(lr &Libraw_data_t, index int) f32

pub fn libraw_get_cam_mul(lr &Libraw_data_t, index int) f32 {
	return C.libraw_get_cam_mul(lr, index)
}

fn C.libraw_get_pre_mul(lr &Libraw_data_t, index int) f32

pub fn libraw_get_pre_mul(lr &Libraw_data_t, index int) f32 {
	return C.libraw_get_pre_mul(lr, index)
}

fn C.libraw_get_rgb_cam(lr &Libraw_data_t, index1 int, index2 int) f32

pub fn libraw_get_rgb_cam(lr &Libraw_data_t, index1 int, index2 int) f32 {
	return C.libraw_get_rgb_cam(lr, index1, index2)
}

fn C.libraw_get_color_maximum(lr &Libraw_data_t) int

pub fn libraw_get_color_maximum(lr &Libraw_data_t) int {
	return C.libraw_get_color_maximum(lr)
}

fn C.libraw_set_output_tif(lr &Libraw_data_t, value int)

pub fn libraw_set_output_tif(lr &Libraw_data_t, value int) {
	C.libraw_set_output_tif(lr, value)
}

fn C.libraw_get_iparams(lr &Libraw_data_t) &Libraw_iparams_t

pub fn libraw_get_iparams(lr &Libraw_data_t) &Libraw_iparams_t {
	return C.libraw_get_iparams(lr)
}

fn C.libraw_get_lensinfo(lr &Libraw_data_t) &Libraw_lensinfo_t

pub fn libraw_get_lensinfo(lr &Libraw_data_t) &Libraw_lensinfo_t {
	return C.libraw_get_lensinfo(lr)
}

fn C.libraw_get_imgother(lr &Libraw_data_t) &Libraw_imgother_t

pub fn libraw_get_imgother(lr &Libraw_data_t) &Libraw_imgother_t {
	return C.libraw_get_imgother(lr)
}

// helpers 
// dcraw emulation 
// information calls 
// memory writers 
// Additional calls for make_mem_image 
// free all internal data structures 
// Special value 0+1+2+3 
// Phase one correction/subtractBL calls 
// Returns libraw error code 
// Hotspots 
// Fujifilm compressed decoder public interface (to make parallel decoder) 
// CR3 decoder public interface to make parallel decoder 
// Panasonic Compression 8 parallel decoder stubs
// return: 0 if OK, non-zero on error
//void (LibRaw::*write_thumb)();
//void (LibRaw::*thumb_load_raw)();
// RawSpeed data 
// returns LIBRAW_SUCCESS on success 
// Fast cancel flag 
// DNG SDK data 
// X3F data 
// keep it even if USE_X3FTOOLS is not defined to do not change sizeof(LibRaw)
// __cplusplus 
// _LIBRAW_CLASS_H 
